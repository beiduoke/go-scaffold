// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: admin/v1/admin.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	protobuf "github.com/beiduoke/go-scaffold/api/protobuf"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = protobuf.UserGender(0)
)

// Validate checks the field values on Auth with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Auth with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AuthMultiError, or nil if none found.
func (m *Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := AuthValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 25 {
		err := AuthValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 25 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AuthMultiError(errors)
	}

	return nil
}

// AuthMultiError is an error wrapping multiple validation errors returned by
// Auth.ValidateAll() if the designated constraints aren't met.
type AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthMultiError) AllErrors() []error { return m }

// AuthValidationError is the validation error returned by Auth.Validate if the
// designated constraints aren't met.
type AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthValidationError) ErrorName() string { return "AuthValidationError" }

// Error satisfies the builtin error interface
func (e AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthValidationError{}

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on RegisterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReplyMultiError, or
// nil if none found.
func (m *RegisterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterReplyMultiError(errors)
	}

	return nil
}

// RegisterReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReplyMultiError) AllErrors() []error { return m }

// RegisterReplyValidationError is the validation error returned by
// RegisterReply.Validate if the designated constraints aren't met.
type RegisterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReplyValidationError) ErrorName() string { return "RegisterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReplyValidationError{}

// Validate checks the field values on LogoutReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutReplyMultiError, or
// nil if none found.
func (m *LogoutReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogoutReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogoutReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogoutReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogoutReplyMultiError(errors)
	}

	return nil
}

// LogoutReplyMultiError is an error wrapping multiple validation errors
// returned by LogoutReply.ValidateAll() if the designated constraints aren't met.
type LogoutReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutReplyMultiError) AllErrors() []error { return m }

// LogoutReplyValidationError is the validation error returned by
// LogoutReply.Validate if the designated constraints aren't met.
type LogoutReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutReplyValidationError) ErrorName() string { return "LogoutReplyValidationError" }

// Error satisfies the builtin error interface
func (e LogoutReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutReplyValidationError{}

// Validate checks the field values on PassLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PassLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PassLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PassLoginReqMultiError, or
// nil if none found.
func (m *PassLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PassLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := PassLoginReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PassLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PassLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PassLoginReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PassLoginReqMultiError(errors)
	}

	return nil
}

// PassLoginReqMultiError is an error wrapping multiple validation errors
// returned by PassLoginReq.ValidateAll() if the designated constraints aren't met.
type PassLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PassLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PassLoginReqMultiError) AllErrors() []error { return m }

// PassLoginReqValidationError is the validation error returned by
// PassLoginReq.Validate if the designated constraints aren't met.
type PassLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PassLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PassLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PassLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PassLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PassLoginReqValidationError) ErrorName() string { return "PassLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e PassLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPassLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PassLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PassLoginReqValidationError{}

// Validate checks the field values on SmsLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SmsLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SmsLoginReqMultiError, or
// nil if none found.
func (m *SmsLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := SmsLoginReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmsLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmsLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmsLoginReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SmsLoginReqMultiError(errors)
	}

	return nil
}

// SmsLoginReqMultiError is an error wrapping multiple validation errors
// returned by SmsLoginReq.ValidateAll() if the designated constraints aren't met.
type SmsLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginReqMultiError) AllErrors() []error { return m }

// SmsLoginReqValidationError is the validation error returned by
// SmsLoginReq.Validate if the designated constraints aren't met.
type SmsLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginReqValidationError) ErrorName() string { return "SmsLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e SmsLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginReqValidationError{}

// Validate checks the field values on EmailLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailLoginReqMultiError, or
// nil if none found.
func (m *EmailLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := EmailLoginReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailLoginReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EmailLoginReqMultiError(errors)
	}

	return nil
}

// EmailLoginReqMultiError is an error wrapping multiple validation errors
// returned by EmailLoginReq.ValidateAll() if the designated constraints
// aren't met.
type EmailLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginReqMultiError) AllErrors() []error { return m }

// EmailLoginReqValidationError is the validation error returned by
// EmailLoginReq.Validate if the designated constraints aren't met.
type EmailLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginReqValidationError) ErrorName() string { return "EmailLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e EmailLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginReqValidationError{}

// Validate checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReqMultiError, or
// nil if none found.
func (m *RegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := RegisterReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterReqMultiError(errors)
	}

	return nil
}

// RegisterReqMultiError is an error wrapping multiple validation errors
// returned by RegisterReq.ValidateAll() if the designated constraints aren't met.
type RegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReqMultiError) AllErrors() []error { return m }

// RegisterReqValidationError is the validation error returned by
// RegisterReq.Validate if the designated constraints aren't met.
type RegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReqValidationError) ErrorName() string { return "RegisterReqValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReqValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for NickName

	// no validation rules for RealName

	// no validation rules for Birthday

	// no validation rules for Gender

	// no validation rules for Mobile

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on GetUserProfileReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileReplyMultiError, or nil if none found.
func (m *GetUserProfileReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserProfileReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserProfileReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserProfileReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserProfileReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserProfileReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserProfileReplyValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserProfileReplyMultiError(errors)
	}

	return nil
}

// GetUserProfileReplyMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileReply.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileReplyMultiError) AllErrors() []error { return m }

// GetUserProfileReplyValidationError is the validation error returned by
// GetUserProfileReply.Validate if the designated constraints aren't met.
type GetUserProfileReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileReplyValidationError) ErrorName() string {
	return "GetUserProfileReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileReplyValidationError{}

// Validate checks the field values on ListUserDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserDomainReplyMultiError, or nil if none found.
func (m *ListUserDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserDomainReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserDomainReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserDomainReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListUserDomainReplyMultiError(errors)
	}

	return nil
}

// ListUserDomainReplyMultiError is an error wrapping multiple validation
// errors returned by ListUserDomainReply.ValidateAll() if the designated
// constraints aren't met.
type ListUserDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserDomainReplyMultiError) AllErrors() []error { return m }

// ListUserDomainReplyValidationError is the validation error returned by
// ListUserDomainReply.Validate if the designated constraints aren't met.
type ListUserDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserDomainReplyValidationError) ErrorName() string {
	return "ListUserDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserDomainReplyValidationError{}

// Validate checks the field values on ListUserRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleReplyMultiError, or nil if none found.
func (m *ListUserRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListUserRoleReplyMultiError(errors)
	}

	return nil
}

// ListUserRoleReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserRoleReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleReplyMultiError) AllErrors() []error { return m }

// ListUserRoleReplyValidationError is the validation error returned by
// ListUserRoleReply.Validate if the designated constraints aren't met.
type ListUserRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleReplyValidationError) ErrorName() string {
	return "ListUserRoleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleReplyValidationError{}

// Validate checks the field values on ListUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListUserReplyMultiError, or
// nil if none found.
func (m *ListUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListUserReplyMultiError(errors)
	}

	return nil
}

// ListUserReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserReplyMultiError) AllErrors() []error { return m }

// ListUserReplyValidationError is the validation error returned by
// ListUserReply.Validate if the designated constraints aren't met.
type ListUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserReplyValidationError) ErrorName() string { return "ListUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserReplyValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReqMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRoleMenuTreeReqValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReqMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReqMultiError is an error wrapping multiple validation
// errors returned by ListUserRoleMenuTreeReq.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReqMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReqValidationError is the validation error returned by
// ListUserRoleMenuTreeReq.Validate if the designated constraints aren't met.
type ListUserRoleMenuTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReqValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReqValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReply_Deprecated
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListUserRoleMenuTreeReply_Deprecated) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReply_Deprecated
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_DeprecatedMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Deprecated) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Deprecated) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_DeprecatedValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_DeprecatedValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReply_DeprecatedValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_DeprecatedMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_DeprecatedMultiError is an error wrapping multiple
// validation errors returned by
// ListUserRoleMenuTreeReply_Deprecated.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_DeprecatedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_DeprecatedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_DeprecatedMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_DeprecatedValidationError is the validation error
// returned by ListUserRoleMenuTreeReply_Deprecated.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_DeprecatedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_DeprecatedValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Deprecated.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_DeprecatedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_DeprecatedValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReplyMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReplyMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReplyMultiError is an error wrapping multiple validation
// errors returned by ListUserRoleMenuTreeReply.ValidateAll() if the
// designated constraints aren't met.
type ListUserRoleMenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReplyMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReplyValidationError is the validation error returned by
// ListUserRoleMenuTreeReply.Validate if the designated constraints aren't met.
type ListUserRoleMenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReplyValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReplyValidationError{}

// Validate checks the field values on ListUserRolePermissionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRolePermissionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRolePermissionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRolePermissionReqMultiError, or nil if none found.
func (m *ListUserRolePermissionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRolePermissionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRolePermissionReqValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUserRolePermissionReqMultiError(errors)
	}

	return nil
}

// ListUserRolePermissionReqMultiError is an error wrapping multiple validation
// errors returned by ListUserRolePermissionReq.ValidateAll() if the
// designated constraints aren't met.
type ListUserRolePermissionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRolePermissionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRolePermissionReqMultiError) AllErrors() []error { return m }

// ListUserRolePermissionReqValidationError is the validation error returned by
// ListUserRolePermissionReq.Validate if the designated constraints aren't met.
type ListUserRolePermissionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRolePermissionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRolePermissionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRolePermissionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRolePermissionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRolePermissionReqValidationError) ErrorName() string {
	return "ListUserRolePermissionReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRolePermissionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRolePermissionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRolePermissionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRolePermissionReqValidationError{}

// Validate checks the field values on ListUserRolePermissionReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRolePermissionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRolePermissionReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRolePermissionReplyMultiError, or nil if none found.
func (m *ListUserRolePermissionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRolePermissionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	if len(errors) > 0 {
		return ListUserRolePermissionReplyMultiError(errors)
	}

	return nil
}

// ListUserRolePermissionReplyMultiError is an error wrapping multiple
// validation errors returned by ListUserRolePermissionReply.ValidateAll() if
// the designated constraints aren't met.
type ListUserRolePermissionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRolePermissionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRolePermissionReplyMultiError) AllErrors() []error { return m }

// ListUserRolePermissionReplyValidationError is the validation error returned
// by ListUserRolePermissionReply.Validate if the designated constraints
// aren't met.
type ListUserRolePermissionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRolePermissionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRolePermissionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRolePermissionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRolePermissionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRolePermissionReplyValidationError) ErrorName() string {
	return "ListUserRolePermissionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRolePermissionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRolePermissionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRolePermissionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRolePermissionReplyValidationError{}

// Validate checks the field values on CreateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateUserReqMultiError, or
// nil if none found.
func (m *CreateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateUserReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateUserReq_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := CreateUserReqValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateUserReq_State_NotInLookup[m.GetState()]; ok {
		err := CreateUserReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.UserState_name[int32(m.GetState())]; !ok {
		err := CreateUserReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if m.Password != nil {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
			err := CreateUserReqValidationError{
				field:  "Password",
				reason: "value length must be between 6 and 28 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NickName != nil {

		if l := utf8.RuneCountInString(m.GetNickName()); l < 1 || l > 10 {
			err := CreateUserReqValidationError{
				field:  "NickName",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RealName != nil {

		if l := utf8.RuneCountInString(m.GetRealName()); l < 2 || l > 10 {
			err := CreateUserReqValidationError{
				field:  "RealName",
				reason: "value length must be between 2 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Birthday != nil {

		if !_CreateUserReq_Birthday_Pattern.MatchString(m.GetBirthday()) {
			err := CreateUserReqValidationError{
				field:  "Birthday",
				reason: "value does not match regex pattern \"^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Gender != nil {

		if _, ok := _CreateUserReq_Gender_NotInLookup[m.GetGender()]; ok {
			err := CreateUserReqValidationError{
				field:  "Gender",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.UserGender_name[int32(m.GetGender())]; !ok {
			err := CreateUserReqValidationError{
				field:  "Gender",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = CreateUserReqValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateUserReqMultiError(errors)
	}

	return nil
}

func (m *CreateUserReq) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserReq) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserReqMultiError is an error wrapping multiple validation errors
// returned by CreateUserReq.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReqMultiError) AllErrors() []error { return m }

// CreateUserReqValidationError is the validation error returned by
// CreateUserReq.Validate if the designated constraints aren't met.
type CreateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReqValidationError) ErrorName() string { return "CreateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReqValidationError{}

var _CreateUserReq_Birthday_Pattern = regexp.MustCompile("^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$")

var _CreateUserReq_Gender_NotInLookup = map[protobuf.UserGender]struct{}{
	0: {},
}

var _CreateUserReq_Mobile_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _CreateUserReq_State_NotInLookup = map[protobuf.UserState]struct{}{
	0: {},
}

// Validate checks the field values on CreateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserReplyMultiError, or nil if none found.
func (m *CreateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserReplyMultiError(errors)
	}

	return nil
}

// CreateUserReplyMultiError is an error wrapping multiple validation errors
// returned by CreateUserReply.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReplyMultiError) AllErrors() []error { return m }

// CreateUserReplyValidationError is the validation error returned by
// CreateUserReply.Validate if the designated constraints aren't met.
type CreateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReplyValidationError) ErrorName() string { return "CreateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReplyValidationError{}

// Validate checks the field values on HandleUserDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserDomainReqMultiError, or nil if none found.
func (m *HandleUserDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleUserDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleUserDomainReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleUserDomainReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleUserDomainReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleUserDomainReqMultiError(errors)
	}

	return nil
}

// HandleUserDomainReqMultiError is an error wrapping multiple validation
// errors returned by HandleUserDomainReq.ValidateAll() if the designated
// constraints aren't met.
type HandleUserDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserDomainReqMultiError) AllErrors() []error { return m }

// HandleUserDomainReqValidationError is the validation error returned by
// HandleUserDomainReq.Validate if the designated constraints aren't met.
type HandleUserDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserDomainReqValidationError) ErrorName() string {
	return "HandleUserDomainReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserDomainReqValidationError{}

// Validate checks the field values on HandleUserDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserDomainReplyMultiError, or nil if none found.
func (m *HandleUserDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return HandleUserDomainReplyMultiError(errors)
	}

	return nil
}

// HandleUserDomainReplyMultiError is an error wrapping multiple validation
// errors returned by HandleUserDomainReply.ValidateAll() if the designated
// constraints aren't met.
type HandleUserDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserDomainReplyMultiError) AllErrors() []error { return m }

// HandleUserDomainReplyValidationError is the validation error returned by
// HandleUserDomainReply.Validate if the designated constraints aren't met.
type HandleUserDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserDomainReplyValidationError) ErrorName() string {
	return "HandleUserDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserDomainReplyValidationError{}

// Validate checks the field values on HandleUserDomainRoleReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserDomainRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserDomainRoleReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserDomainRoleReqMultiError, or nil if none found.
func (m *HandleUserDomainRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserDomainRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleUserDomainRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleUserDomainRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleUserDomainRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleUserDomainRoleReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleUserDomainRoleReqMultiError(errors)
	}

	return nil
}

// HandleUserDomainRoleReqMultiError is an error wrapping multiple validation
// errors returned by HandleUserDomainRoleReq.ValidateAll() if the designated
// constraints aren't met.
type HandleUserDomainRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserDomainRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserDomainRoleReqMultiError) AllErrors() []error { return m }

// HandleUserDomainRoleReqValidationError is the validation error returned by
// HandleUserDomainRoleReq.Validate if the designated constraints aren't met.
type HandleUserDomainRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserDomainRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserDomainRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserDomainRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserDomainRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserDomainRoleReqValidationError) ErrorName() string {
	return "HandleUserDomainRoleReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserDomainRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserDomainRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserDomainRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserDomainRoleReqValidationError{}

// Validate checks the field values on HandleUserDomainRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserDomainRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserDomainRoleReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserDomainRoleReplyMultiError, or nil if none found.
func (m *HandleUserDomainRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserDomainRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return HandleUserDomainRoleReplyMultiError(errors)
	}

	return nil
}

// HandleUserDomainRoleReplyMultiError is an error wrapping multiple validation
// errors returned by HandleUserDomainRoleReply.ValidateAll() if the
// designated constraints aren't met.
type HandleUserDomainRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserDomainRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserDomainRoleReplyMultiError) AllErrors() []error { return m }

// HandleUserDomainRoleReplyValidationError is the validation error returned by
// HandleUserDomainRoleReply.Validate if the designated constraints aren't met.
type HandleUserDomainRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserDomainRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserDomainRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserDomainRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserDomainRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserDomainRoleReplyValidationError) ErrorName() string {
	return "HandleUserDomainRoleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserDomainRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserDomainRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserDomainRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserDomainRoleReplyValidationError{}

// Validate checks the field values on GetUserReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserReqMultiError, or
// nil if none found.
func (m *GetUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetUserReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserReqMultiError(errors)
	}

	return nil
}

// GetUserReqMultiError is an error wrapping multiple validation errors
// returned by GetUserReq.ValidateAll() if the designated constraints aren't met.
type GetUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserReqMultiError) AllErrors() []error { return m }

// GetUserReqValidationError is the validation error returned by
// GetUserReq.Validate if the designated constraints aren't met.
type GetUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserReqValidationError) ErrorName() string { return "GetUserReqValidationError" }

// Error satisfies the builtin error interface
func (e GetUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserReqValidationError{}

// Validate checks the field values on DeleteUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteUserReqMultiError, or
// nil if none found.
func (m *DeleteUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteUserReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteUserReqMultiError(errors)
	}

	return nil
}

// DeleteUserReqMultiError is an error wrapping multiple validation errors
// returned by DeleteUserReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserReqMultiError) AllErrors() []error { return m }

// DeleteUserReqValidationError is the validation error returned by
// DeleteUserReq.Validate if the designated constraints aren't met.
type DeleteUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserReqValidationError) ErrorName() string { return "DeleteUserReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserReqValidationError{}

// Validate checks the field values on DeleteUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserReplyMultiError, or nil if none found.
func (m *DeleteUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteUserReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteUserReplyMultiError(errors)
	}

	return nil
}

// DeleteUserReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteUserReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserReplyMultiError) AllErrors() []error { return m }

// DeleteUserReplyValidationError is the validation error returned by
// DeleteUserReply.Validate if the designated constraints aren't met.
type DeleteUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserReplyValidationError) ErrorName() string { return "DeleteUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserReplyValidationError{}

// Validate checks the field values on UpdateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateUserReqMultiError, or
// nil if none found.
func (m *UpdateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateUserReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserReqMultiError(errors)
	}

	return nil
}

// UpdateUserReqMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReqMultiError) AllErrors() []error { return m }

// UpdateUserReqValidationError is the validation error returned by
// UpdateUserReq.Validate if the designated constraints aren't met.
type UpdateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReqValidationError) ErrorName() string { return "UpdateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReqValidationError{}

// Validate checks the field values on UpdateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserReplyMultiError, or nil if none found.
func (m *UpdateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserReplyMultiError(errors)
	}

	return nil
}

// UpdateUserReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReplyMultiError) AllErrors() []error { return m }

// UpdateUserReplyValidationError is the validation error returned by
// UpdateUserReply.Validate if the designated constraints aren't met.
type UpdateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReplyValidationError) ErrorName() string { return "UpdateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReplyValidationError{}

// Validate checks the field values on UserMenuTreeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserMenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMenuTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserMenuTreeReplyMultiError, or nil if none found.
func (m *UserMenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserMenuTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserMenuTreeReplyMultiError(errors)
	}

	return nil
}

// UserMenuTreeReplyMultiError is an error wrapping multiple validation errors
// returned by UserMenuTreeReply.ValidateAll() if the designated constraints
// aren't met.
type UserMenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMenuTreeReplyMultiError) AllErrors() []error { return m }

// UserMenuTreeReplyValidationError is the validation error returned by
// UserMenuTreeReply.Validate if the designated constraints aren't met.
type UserMenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMenuTreeReplyValidationError) ErrorName() string {
	return "UserMenuTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UserMenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMenuTreeReplyValidationError{}

// Validate checks the field values on ExistUserNameReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExistUserNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistUserNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistUserNameReqMultiError, or nil if none found.
func (m *ExistUserNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistUserNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ExistUserNameReqMultiError(errors)
	}

	return nil
}

// ExistUserNameReqMultiError is an error wrapping multiple validation errors
// returned by ExistUserNameReq.ValidateAll() if the designated constraints
// aren't met.
type ExistUserNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistUserNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistUserNameReqMultiError) AllErrors() []error { return m }

// ExistUserNameReqValidationError is the validation error returned by
// ExistUserNameReq.Validate if the designated constraints aren't met.
type ExistUserNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistUserNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistUserNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistUserNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistUserNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistUserNameReqValidationError) ErrorName() string { return "ExistUserNameReqValidationError" }

// Error satisfies the builtin error interface
func (e ExistUserNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistUserNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistUserNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistUserNameReqValidationError{}

// Validate checks the field values on ExistUserNameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExistUserNameReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistUserNameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistUserNameReplyMultiError, or nil if none found.
func (m *ExistUserNameReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistUserNameReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExistUserNameReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExistUserNameReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExistUserNameReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExistUserNameReplyMultiError(errors)
	}

	return nil
}

// ExistUserNameReplyMultiError is an error wrapping multiple validation errors
// returned by ExistUserNameReply.ValidateAll() if the designated constraints
// aren't met.
type ExistUserNameReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistUserNameReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistUserNameReplyMultiError) AllErrors() []error { return m }

// ExistUserNameReplyValidationError is the validation error returned by
// ExistUserNameReply.Validate if the designated constraints aren't met.
type ExistUserNameReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistUserNameReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistUserNameReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistUserNameReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistUserNameReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistUserNameReplyValidationError) ErrorName() string {
	return "ExistUserNameReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ExistUserNameReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistUserNameReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistUserNameReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistUserNameReplyValidationError{}

// Validate checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Domain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DomainMultiError, or nil if none found.
func (m *Domain) ValidateAll() error {
	return m.validate(true)
}

func (m *Domain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DomainValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DomainValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for Sort

	// no validation rules for State

	// no validation rules for DefaultRoleId

	if len(errors) > 0 {
		return DomainMultiError(errors)
	}

	return nil
}

// DomainMultiError is an error wrapping multiple validation errors returned by
// Domain.ValidateAll() if the designated constraints aren't met.
type DomainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DomainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DomainMultiError) AllErrors() []error { return m }

// DomainValidationError is the validation error returned by Domain.Validate if
// the designated constraints aren't met.
type DomainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DomainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DomainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DomainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DomainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DomainValidationError) ErrorName() string { return "DomainValidationError" }

// Error satisfies the builtin error interface
func (e DomainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDomain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DomainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DomainValidationError{}

// Validate checks the field values on LoginDomainReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginDomainReqMultiError,
// or nil if none found.
func (m *LoginDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := LoginDomainReqValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAuth() == nil {
		err := LoginDomainReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginDomainReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginDomainReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginDomainReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginDomainReqMultiError(errors)
	}

	return nil
}

// LoginDomainReqMultiError is an error wrapping multiple validation errors
// returned by LoginDomainReq.ValidateAll() if the designated constraints
// aren't met.
type LoginDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginDomainReqMultiError) AllErrors() []error { return m }

// LoginDomainReqValidationError is the validation error returned by
// LoginDomainReq.Validate if the designated constraints aren't met.
type LoginDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginDomainReqValidationError) ErrorName() string { return "LoginDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginDomainReqValidationError{}

// Validate checks the field values on RegisterDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterDomainReqMultiError, or nil if none found.
func (m *RegisterDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := RegisterDomainReqValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAuth() == nil {
		err := RegisterDomainReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterDomainReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterDomainReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterDomainReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterDomainReqMultiError(errors)
	}

	return nil
}

// RegisterDomainReqMultiError is an error wrapping multiple validation errors
// returned by RegisterDomainReq.ValidateAll() if the designated constraints
// aren't met.
type RegisterDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterDomainReqMultiError) AllErrors() []error { return m }

// RegisterDomainReqValidationError is the validation error returned by
// RegisterDomainReq.Validate if the designated constraints aren't met.
type RegisterDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterDomainReqValidationError) ErrorName() string {
	return "RegisterDomainReqValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterDomainReqValidationError{}

// Validate checks the field values on CreateDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainReqMultiError, or nil if none found.
func (m *CreateDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDomainReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ParentId != nil {

		if m.GetParentId() < 0 {
			err := CreateDomainReqValidationError{
				field:  "ParentId",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := CreateDomainReqValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.State != nil {

		if _, ok := _CreateDomainReq_State_NotInLookup[m.GetState()]; ok {
			err := CreateDomainReqValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.DomainState_name[int32(m.GetState())]; !ok {
			err := CreateDomainReqValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DefaultRoleId != nil {

		if m.GetDefaultRoleId() <= 0 {
			err := CreateDomainReqValidationError{
				field:  "DefaultRoleId",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDomainReqMultiError(errors)
	}

	return nil
}

// CreateDomainReqMultiError is an error wrapping multiple validation errors
// returned by CreateDomainReq.ValidateAll() if the designated constraints
// aren't met.
type CreateDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainReqMultiError) AllErrors() []error { return m }

// CreateDomainReqValidationError is the validation error returned by
// CreateDomainReq.Validate if the designated constraints aren't met.
type CreateDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainReqValidationError) ErrorName() string { return "CreateDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainReqValidationError{}

var _CreateDomainReq_State_NotInLookup = map[protobuf.DomainState]struct{}{
	0: {},
}

// Validate checks the field values on CreateDomainReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainReplyMultiError, or nil if none found.
func (m *CreateDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDomainReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDomainReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDomainReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDomainReplyMultiError(errors)
	}

	return nil
}

// CreateDomainReplyMultiError is an error wrapping multiple validation errors
// returned by CreateDomainReply.ValidateAll() if the designated constraints
// aren't met.
type CreateDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainReplyMultiError) AllErrors() []error { return m }

// CreateDomainReplyValidationError is the validation error returned by
// CreateDomainReply.Validate if the designated constraints aren't met.
type CreateDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainReplyValidationError) ErrorName() string {
	return "CreateDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainReplyValidationError{}

// Validate checks the field values on UpdateDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainReqMultiError, or nil if none found.
func (m *UpdateDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainReqMultiError(errors)
	}

	return nil
}

// UpdateDomainReqMultiError is an error wrapping multiple validation errors
// returned by UpdateDomainReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainReqMultiError) AllErrors() []error { return m }

// UpdateDomainReqValidationError is the validation error returned by
// UpdateDomainReq.Validate if the designated constraints aren't met.
type UpdateDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainReqValidationError) ErrorName() string { return "UpdateDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainReqValidationError{}

// Validate checks the field values on UpdateDomainReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainReplyMultiError, or nil if none found.
func (m *UpdateDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainReplyMultiError(errors)
	}

	return nil
}

// UpdateDomainReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateDomainReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainReplyMultiError) AllErrors() []error { return m }

// UpdateDomainReplyValidationError is the validation error returned by
// UpdateDomainReply.Validate if the designated constraints aren't met.
type UpdateDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainReplyValidationError) ErrorName() string {
	return "UpdateDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainReplyValidationError{}

// Validate checks the field values on UpdateDomainStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateReqMultiError, or nil if none found.
func (m *UpdateDomainStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainStateReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainStateReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainStateReqMultiError(errors)
	}

	return nil
}

// UpdateDomainStateReqMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateReqMultiError) AllErrors() []error { return m }

// UpdateDomainStateReqValidationError is the validation error returned by
// UpdateDomainStateReq.Validate if the designated constraints aren't met.
type UpdateDomainStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateReqValidationError) ErrorName() string {
	return "UpdateDomainStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateReqValidationError{}

// Validate checks the field values on UpdateDomainStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateReplyMultiError, or nil if none found.
func (m *UpdateDomainStateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainStateReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainStateReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainStateReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainStateReplyMultiError(errors)
	}

	return nil
}

// UpdateDomainStateReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainStateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateReplyMultiError) AllErrors() []error { return m }

// UpdateDomainStateReplyValidationError is the validation error returned by
// UpdateDomainStateReply.Validate if the designated constraints aren't met.
type UpdateDomainStateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateReplyValidationError) ErrorName() string {
	return "UpdateDomainStateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateReplyValidationError{}

// Validate checks the field values on GetDomainReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetDomainReqMultiError, or
// nil if none found.
func (m *GetDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainReqMultiError(errors)
	}

	return nil
}

// GetDomainReqMultiError is an error wrapping multiple validation errors
// returned by GetDomainReq.ValidateAll() if the designated constraints aren't met.
type GetDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainReqMultiError) AllErrors() []error { return m }

// GetDomainReqValidationError is the validation error returned by
// GetDomainReq.Validate if the designated constraints aren't met.
type GetDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainReqValidationError) ErrorName() string { return "GetDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainReqValidationError{}

// Validate checks the field values on DeleteDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainReqMultiError, or nil if none found.
func (m *DeleteDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDomainReqMultiError(errors)
	}

	return nil
}

// DeleteDomainReqMultiError is an error wrapping multiple validation errors
// returned by DeleteDomainReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainReqMultiError) AllErrors() []error { return m }

// DeleteDomainReqValidationError is the validation error returned by
// DeleteDomainReq.Validate if the designated constraints aren't met.
type DeleteDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainReqValidationError) ErrorName() string { return "DeleteDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainReqValidationError{}

// Validate checks the field values on DeleteDomainReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainReplyMultiError, or nil if none found.
func (m *DeleteDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDomainReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDomainReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDomainReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteDomainReplyMultiError(errors)
	}

	return nil
}

// DeleteDomainReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteDomainReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainReplyMultiError) AllErrors() []error { return m }

// DeleteDomainReplyValidationError is the validation error returned by
// DeleteDomainReply.Validate if the designated constraints aren't met.
type DeleteDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainReplyValidationError) ErrorName() string {
	return "DeleteDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainReplyValidationError{}

// Validate checks the field values on ListDomainMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuReqMultiError, or nil if none found.
func (m *ListDomainMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListDomainMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListDomainMenuReqMultiError(errors)
	}

	return nil
}

// ListDomainMenuReqMultiError is an error wrapping multiple validation errors
// returned by ListDomainMenuReq.ValidateAll() if the designated constraints
// aren't met.
type ListDomainMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuReqMultiError) AllErrors() []error { return m }

// ListDomainMenuReqValidationError is the validation error returned by
// ListDomainMenuReq.Validate if the designated constraints aren't met.
type ListDomainMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuReqValidationError) ErrorName() string {
	return "ListDomainMenuReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuReqValidationError{}

// Validate checks the field values on ListDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuReplyMultiError, or nil if none found.
func (m *ListDomainMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainMenuReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDomainMenuReplyMultiError(errors)
	}

	return nil
}

// ListDomainMenuReplyMultiError is an error wrapping multiple validation
// errors returned by ListDomainMenuReply.ValidateAll() if the designated
// constraints aren't met.
type ListDomainMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuReplyMultiError) AllErrors() []error { return m }

// ListDomainMenuReplyValidationError is the validation error returned by
// ListDomainMenuReply.Validate if the designated constraints aren't met.
type ListDomainMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuReplyValidationError) ErrorName() string {
	return "ListDomainMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuReplyValidationError{}

// Validate checks the field values on HandleDomainMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReqMultiError, or nil if none found.
func (m *HandleDomainMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleDomainMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleDomainMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleDomainMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleDomainMenuReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleDomainMenuReqMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReqMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReq.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReqMultiError) AllErrors() []error { return m }

// HandleDomainMenuReqValidationError is the validation error returned by
// HandleDomainMenuReq.Validate if the designated constraints aren't met.
type HandleDomainMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReqValidationError) ErrorName() string {
	return "HandleDomainMenuReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReqValidationError{}

// Validate checks the field values on HandleDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReplyMultiError, or nil if none found.
func (m *HandleDomainMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleDomainMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleDomainMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleDomainMenuReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleDomainMenuReplyMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReplyMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReply.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReplyMultiError) AllErrors() []error { return m }

// HandleDomainMenuReplyValidationError is the validation error returned by
// HandleDomainMenuReply.Validate if the designated constraints aren't met.
type HandleDomainMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReplyValidationError) ErrorName() string {
	return "HandleDomainMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReplyValidationError{}

// Validate checks the field values on Role with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Role) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Role with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleMultiError, or nil if none found.
func (m *Role) ValidateAll() error {
	return m.validate(true)
}

func (m *Role) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for DefaultRouter

	// no validation rules for Sort

	// no validation rules for State

	// no validation rules for Remarks

	if len(errors) > 0 {
		return RoleMultiError(errors)
	}

	return nil
}

// RoleMultiError is an error wrapping multiple validation errors returned by
// Role.ValidateAll() if the designated constraints aren't met.
type RoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMultiError) AllErrors() []error { return m }

// RoleValidationError is the validation error returned by Role.Validate if the
// designated constraints aren't met.
type RoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleValidationError) ErrorName() string { return "RoleValidationError" }

// Error satisfies the builtin error interface
func (e RoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleValidationError{}

// Validate checks the field values on CreateRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateRoleReqMultiError, or
// nil if none found.
func (m *CreateRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateRoleReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateRoleReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateRoleReq_State_NotInLookup[m.GetState()]; ok {
		err := CreateRoleReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.RoleState_name[int32(m.GetState())]; !ok {
		err := CreateRoleReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.DefaultRouter != nil {

		if l := utf8.RuneCountInString(m.GetDefaultRouter()); l < 1 || l > 100 {
			err := CreateRoleReqValidationError{
				field:  "DefaultRouter",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := CreateRoleReqValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := CreateRoleReqValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateRoleReqMultiError(errors)
	}

	return nil
}

// CreateRoleReqMultiError is an error wrapping multiple validation errors
// returned by CreateRoleReq.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleReqMultiError) AllErrors() []error { return m }

// CreateRoleReqValidationError is the validation error returned by
// CreateRoleReq.Validate if the designated constraints aren't met.
type CreateRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleReqValidationError) ErrorName() string { return "CreateRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleReqValidationError{}

var _CreateRoleReq_State_NotInLookup = map[protobuf.RoleState]struct{}{
	0: {},
}

// Validate checks the field values on CreateRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRoleReplyMultiError, or nil if none found.
func (m *CreateRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRoleReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRoleReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRoleReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRoleReplyMultiError(errors)
	}

	return nil
}

// CreateRoleReplyMultiError is an error wrapping multiple validation errors
// returned by CreateRoleReply.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleReplyMultiError) AllErrors() []error { return m }

// CreateRoleReplyValidationError is the validation error returned by
// CreateRoleReply.Validate if the designated constraints aren't met.
type CreateRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleReplyValidationError) ErrorName() string { return "CreateRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleReplyValidationError{}

// Validate checks the field values on UpdateRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateRoleReqMultiError, or
// nil if none found.
func (m *UpdateRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleReqMultiError(errors)
	}

	return nil
}

// UpdateRoleReqMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReqMultiError) AllErrors() []error { return m }

// UpdateRoleReqValidationError is the validation error returned by
// UpdateRoleReq.Validate if the designated constraints aren't met.
type UpdateRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReqValidationError) ErrorName() string { return "UpdateRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReqValidationError{}

// Validate checks the field values on UpdateRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleReplyMultiError, or nil if none found.
func (m *UpdateRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleReplyMultiError(errors)
	}

	return nil
}

// UpdateRoleReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReplyMultiError) AllErrors() []error { return m }

// UpdateRoleReplyValidationError is the validation error returned by
// UpdateRoleReply.Validate if the designated constraints aren't met.
type UpdateRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReplyValidationError) ErrorName() string { return "UpdateRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReplyValidationError{}

// Validate checks the field values on UpdateRoleStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateReqMultiError, or nil if none found.
func (m *UpdateRoleStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleStateReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleStateReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleStateReqMultiError(errors)
	}

	return nil
}

// UpdateRoleStateReqMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleStateReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateReqMultiError) AllErrors() []error { return m }

// UpdateRoleStateReqValidationError is the validation error returned by
// UpdateRoleStateReq.Validate if the designated constraints aren't met.
type UpdateRoleStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateReqValidationError) ErrorName() string {
	return "UpdateRoleStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateReqValidationError{}

// Validate checks the field values on UpdateRoleStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateReplyMultiError, or nil if none found.
func (m *UpdateRoleStateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleStateReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleStateReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleStateReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleStateReplyMultiError(errors)
	}

	return nil
}

// UpdateRoleStateReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleStateReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleStateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateReplyMultiError) AllErrors() []error { return m }

// UpdateRoleStateReplyValidationError is the validation error returned by
// UpdateRoleStateReply.Validate if the designated constraints aren't met.
type UpdateRoleStateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateReplyValidationError) ErrorName() string {
	return "UpdateRoleStateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateReplyValidationError{}

// Validate checks the field values on GetRoleReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRoleReqMultiError, or
// nil if none found.
func (m *GetRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRoleReqMultiError(errors)
	}

	return nil
}

// GetRoleReqMultiError is an error wrapping multiple validation errors
// returned by GetRoleReq.ValidateAll() if the designated constraints aren't met.
type GetRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleReqMultiError) AllErrors() []error { return m }

// GetRoleReqValidationError is the validation error returned by
// GetRoleReq.Validate if the designated constraints aren't met.
type GetRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleReqValidationError) ErrorName() string { return "GetRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleReqValidationError{}

// Validate checks the field values on DeleteRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteRoleReqMultiError, or
// nil if none found.
func (m *DeleteRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRoleReqMultiError(errors)
	}

	return nil
}

// DeleteRoleReqMultiError is an error wrapping multiple validation errors
// returned by DeleteRoleReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleReqMultiError) AllErrors() []error { return m }

// DeleteRoleReqValidationError is the validation error returned by
// DeleteRoleReq.Validate if the designated constraints aren't met.
type DeleteRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleReqValidationError) ErrorName() string { return "DeleteRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleReqValidationError{}

// Validate checks the field values on DeleteRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRoleReplyMultiError, or nil if none found.
func (m *DeleteRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRoleReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRoleReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRoleReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteRoleReplyMultiError(errors)
	}

	return nil
}

// DeleteRoleReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteRoleReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleReplyMultiError) AllErrors() []error { return m }

// DeleteRoleReplyValidationError is the validation error returned by
// DeleteRoleReply.Validate if the designated constraints aren't met.
type DeleteRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleReplyValidationError) ErrorName() string { return "DeleteRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleReplyValidationError{}

// Validate checks the field values on ListRoleMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoleMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleMenuReqMultiError, or nil if none found.
func (m *ListRoleMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListRoleMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRoleMenuReqMultiError(errors)
	}

	return nil
}

// ListRoleMenuReqMultiError is an error wrapping multiple validation errors
// returned by ListRoleMenuReq.ValidateAll() if the designated constraints
// aren't met.
type ListRoleMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleMenuReqMultiError) AllErrors() []error { return m }

// ListRoleMenuReqValidationError is the validation error returned by
// ListRoleMenuReq.Validate if the designated constraints aren't met.
type ListRoleMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleMenuReqValidationError) ErrorName() string { return "ListRoleMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e ListRoleMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleMenuReqValidationError{}

// Validate checks the field values on ListRoleMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoleMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleMenuReplyMultiError, or nil if none found.
func (m *ListRoleMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleMenuReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRoleMenuReplyMultiError(errors)
	}

	return nil
}

// ListRoleMenuReplyMultiError is an error wrapping multiple validation errors
// returned by ListRoleMenuReply.ValidateAll() if the designated constraints
// aren't met.
type ListRoleMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleMenuReplyMultiError) AllErrors() []error { return m }

// ListRoleMenuReplyValidationError is the validation error returned by
// ListRoleMenuReply.Validate if the designated constraints aren't met.
type ListRoleMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleMenuReplyValidationError) ErrorName() string {
	return "ListRoleMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoleMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleMenuReplyValidationError{}

// Validate checks the field values on HandleRoleMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReqMultiError, or nil if none found.
func (m *HandleRoleMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleMenuReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleMenuReqMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReqMultiError is an error wrapping multiple validation errors
// returned by HandleRoleMenuReq.ValidateAll() if the designated constraints
// aren't met.
type HandleRoleMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReqMultiError) AllErrors() []error { return m }

// HandleRoleMenuReqValidationError is the validation error returned by
// HandleRoleMenuReq.Validate if the designated constraints aren't met.
type HandleRoleMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReqValidationError) ErrorName() string {
	return "HandleRoleMenuReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReqValidationError{}

// Validate checks the field values on HandleRoleMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReplyMultiError, or nil if none found.
func (m *HandleRoleMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleMenuReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleMenuReplyMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReplyMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuReply.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReplyMultiError) AllErrors() []error { return m }

// HandleRoleMenuReplyValidationError is the validation error returned by
// HandleRoleMenuReply.Validate if the designated constraints aren't met.
type HandleRoleMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReplyValidationError) ErrorName() string {
	return "HandleRoleMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReplyValidationError{}

// Validate checks the field values on HandleRoleResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleResourceReqMultiError, or nil if none found.
func (m *HandleRoleResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleResourceReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleResourceReqMultiError(errors)
	}

	return nil
}

// HandleRoleResourceReqMultiError is an error wrapping multiple validation
// errors returned by HandleRoleResourceReq.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleResourceReqMultiError) AllErrors() []error { return m }

// HandleRoleResourceReqValidationError is the validation error returned by
// HandleRoleResourceReq.Validate if the designated constraints aren't met.
type HandleRoleResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleResourceReqValidationError) ErrorName() string {
	return "HandleRoleResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleResourceReqValidationError{}

// Validate checks the field values on HandleRoleResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleResourceReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleResourceReplyMultiError, or nil if none found.
func (m *HandleRoleResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleResourceReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleResourceReplyMultiError(errors)
	}

	return nil
}

// HandleRoleResourceReplyMultiError is an error wrapping multiple validation
// errors returned by HandleRoleResourceReply.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleResourceReplyMultiError) AllErrors() []error { return m }

// HandleRoleResourceReplyValidationError is the validation error returned by
// HandleRoleResourceReply.Validate if the designated constraints aren't met.
type HandleRoleResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleResourceReplyValidationError) ErrorName() string {
	return "HandleRoleResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleResourceReplyValidationError{}

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Method

	// no validation rules for Group

	// no validation rules for Description

	// no validation rules for Operation

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on ListResourceGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResourceGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResourceGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResourceGroupReplyMultiError, or nil if none found.
func (m *ListResourceGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResourceGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	if len(errors) > 0 {
		return ListResourceGroupReplyMultiError(errors)
	}

	return nil
}

// ListResourceGroupReplyMultiError is an error wrapping multiple validation
// errors returned by ListResourceGroupReply.ValidateAll() if the designated
// constraints aren't met.
type ListResourceGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResourceGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResourceGroupReplyMultiError) AllErrors() []error { return m }

// ListResourceGroupReplyValidationError is the validation error returned by
// ListResourceGroupReply.Validate if the designated constraints aren't met.
type ListResourceGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResourceGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResourceGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResourceGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResourceGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResourceGroupReplyValidationError) ErrorName() string {
	return "ListResourceGroupReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListResourceGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResourceGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResourceGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResourceGroupReplyValidationError{}

// Validate checks the field values on CreateResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateResourceReqMultiError, or nil if none found.
func (m *CreateResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateResourceReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
		err := CreateResourceReqValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateResourceReq_Method_InLookup[m.GetMethod()]; !ok {
		err := CreateResourceReqValidationError{
			field:  "Method",
			reason: "value must be in list [* GET POST HEAD PUT PATCH DELETE OPTIONS CONNECT TRACE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Group != nil {

		if l := utf8.RuneCountInString(m.GetGroup()); l < 0 || l > 100 {
			err := CreateResourceReqValidationError{
				field:  "Group",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
			err := CreateResourceReqValidationError{
				field:  "Description",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Operation != nil {

		if l := utf8.RuneCountInString(m.GetOperation()); l < 0 || l > 100 {
			err := CreateResourceReqValidationError{
				field:  "Operation",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateResourceReqMultiError(errors)
	}

	return nil
}

// CreateResourceReqMultiError is an error wrapping multiple validation errors
// returned by CreateResourceReq.ValidateAll() if the designated constraints
// aren't met.
type CreateResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResourceReqMultiError) AllErrors() []error { return m }

// CreateResourceReqValidationError is the validation error returned by
// CreateResourceReq.Validate if the designated constraints aren't met.
type CreateResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResourceReqValidationError) ErrorName() string {
	return "CreateResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResourceReqValidationError{}

var _CreateResourceReq_Method_InLookup = map[string]struct{}{
	"*":       {},
	"GET":     {},
	"POST":    {},
	"HEAD":    {},
	"PUT":     {},
	"PATCH":   {},
	"DELETE":  {},
	"OPTIONS": {},
	"CONNECT": {},
	"TRACE":   {},
}

// Validate checks the field values on CreateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateResourceReplyMultiError, or nil if none found.
func (m *CreateResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateResourceReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateResourceReplyMultiError(errors)
	}

	return nil
}

// CreateResourceReplyMultiError is an error wrapping multiple validation
// errors returned by CreateResourceReply.ValidateAll() if the designated
// constraints aren't met.
type CreateResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResourceReplyMultiError) AllErrors() []error { return m }

// CreateResourceReplyValidationError is the validation error returned by
// CreateResourceReply.Validate if the designated constraints aren't met.
type CreateResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResourceReplyValidationError) ErrorName() string {
	return "CreateResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResourceReplyValidationError{}

// Validate checks the field values on UpdateResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateResourceReqMultiError, or nil if none found.
func (m *UpdateResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateResourceReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateResourceReqMultiError(errors)
	}

	return nil
}

// UpdateResourceReqMultiError is an error wrapping multiple validation errors
// returned by UpdateResourceReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResourceReqMultiError) AllErrors() []error { return m }

// UpdateResourceReqValidationError is the validation error returned by
// UpdateResourceReq.Validate if the designated constraints aren't met.
type UpdateResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResourceReqValidationError) ErrorName() string {
	return "UpdateResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResourceReqValidationError{}

// Validate checks the field values on UpdateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateResourceReplyMultiError, or nil if none found.
func (m *UpdateResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateResourceReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateResourceReplyMultiError(errors)
	}

	return nil
}

// UpdateResourceReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateResourceReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResourceReplyMultiError) AllErrors() []error { return m }

// UpdateResourceReplyValidationError is the validation error returned by
// UpdateResourceReply.Validate if the designated constraints aren't met.
type UpdateResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResourceReplyValidationError) ErrorName() string {
	return "UpdateResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResourceReplyValidationError{}

// Validate checks the field values on GetResourceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetResourceReqMultiError,
// or nil if none found.
func (m *GetResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetResourceReqMultiError(errors)
	}

	return nil
}

// GetResourceReqMultiError is an error wrapping multiple validation errors
// returned by GetResourceReq.ValidateAll() if the designated constraints
// aren't met.
type GetResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceReqMultiError) AllErrors() []error { return m }

// GetResourceReqValidationError is the validation error returned by
// GetResourceReq.Validate if the designated constraints aren't met.
type GetResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceReqValidationError) ErrorName() string { return "GetResourceReqValidationError" }

// Error satisfies the builtin error interface
func (e GetResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceReqValidationError{}

// Validate checks the field values on DeleteResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteResourceReqMultiError, or nil if none found.
func (m *DeleteResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteResourceReqMultiError(errors)
	}

	return nil
}

// DeleteResourceReqMultiError is an error wrapping multiple validation errors
// returned by DeleteResourceReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResourceReqMultiError) AllErrors() []error { return m }

// DeleteResourceReqValidationError is the validation error returned by
// DeleteResourceReq.Validate if the designated constraints aren't met.
type DeleteResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResourceReqValidationError) ErrorName() string {
	return "DeleteResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResourceReqValidationError{}

// Validate checks the field values on DeleteResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteResourceReplyMultiError, or nil if none found.
func (m *DeleteResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteResourceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteResourceReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteResourceReplyMultiError(errors)
	}

	return nil
}

// DeleteResourceReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteResourceReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResourceReplyMultiError) AllErrors() []error { return m }

// DeleteResourceReplyValidationError is the validation error returned by
// DeleteResourceReply.Validate if the designated constraints aren't met.
type DeleteResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResourceReplyValidationError) ErrorName() string {
	return "DeleteResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResourceReplyValidationError{}

// Validate checks the field values on Menu with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MenuMultiError, or nil if none found.
func (m *Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for Hidden

	// no validation rules for Component

	// no validation rules for Permission

	// no validation rules for Sort

	// no validation rules for Icon

	// no validation rules for Title

	// no validation rules for KeepAlive

	// no validation rules for BaseMenu

	// no validation rules for CloseTab

	// no validation rules for ExtType

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuMultiError(errors)
	}

	return nil
}

// MenuMultiError is an error wrapping multiple validation errors returned by
// Menu.ValidateAll() if the designated constraints aren't met.
type MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuMultiError) AllErrors() []error { return m }

// MenuValidationError is the validation error returned by Menu.Validate if the
// designated constraints aren't met.
type MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuValidationError) ErrorName() string { return "MenuValidationError" }

// Error satisfies the builtin error interface
func (e MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuValidationError{}

// Validate checks the field values on MenuButton with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuButton) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuButton with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuButtonMultiError, or
// nil if none found.
func (m *MenuButton) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuButton) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Remarks

	if len(errors) > 0 {
		return MenuButtonMultiError(errors)
	}

	return nil
}

// MenuButtonMultiError is an error wrapping multiple validation errors
// returned by MenuButton.ValidateAll() if the designated constraints aren't met.
type MenuButtonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuButtonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuButtonMultiError) AllErrors() []error { return m }

// MenuButtonValidationError is the validation error returned by
// MenuButton.Validate if the designated constraints aren't met.
type MenuButtonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuButtonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuButtonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuButtonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuButtonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuButtonValidationError) ErrorName() string { return "MenuButtonValidationError" }

// Error satisfies the builtin error interface
func (e MenuButtonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuButton.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuButtonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuButtonValidationError{}

// Validate checks the field values on MenuParameter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuParameter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuParameterMultiError, or
// nil if none found.
func (m *MenuParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Value

	if len(errors) > 0 {
		return MenuParameterMultiError(errors)
	}

	return nil
}

// MenuParameterMultiError is an error wrapping multiple validation errors
// returned by MenuParameter.ValidateAll() if the designated constraints
// aren't met.
type MenuParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuParameterMultiError) AllErrors() []error { return m }

// MenuParameterValidationError is the validation error returned by
// MenuParameter.Validate if the designated constraints aren't met.
type MenuParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuParameterValidationError) ErrorName() string { return "MenuParameterValidationError" }

// Error satisfies the builtin error interface
func (e MenuParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuParameterValidationError{}

// Validate checks the field values on CreateMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateMenuReqMultiError, or
// nil if none found.
func (m *CreateMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _CreateMenuReq_Type_NotInLookup[m.GetType()]; ok {
		err := CreateMenuReqValidationError{
			field:  "Type",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.MenuType_name[int32(m.GetType())]; !ok {
		err := CreateMenuReqValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateMenuReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateMenuReq_Hidden_NotInLookup[m.GetHidden()]; ok {
		err := CreateMenuReqValidationError{
			field:  "Hidden",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.MenuHidden_name[int32(m.GetHidden())]; !ok {
		err := CreateMenuReqValidationError{
			field:  "Hidden",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := CreateMenuReqValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateMenuReqValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateMenuReqValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
			err := CreateMenuReqValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Path != nil {

		if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "Path",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Component != nil {

		if l := utf8.RuneCountInString(m.GetComponent()); l < 1 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "Component",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Permission != nil {

		if l := utf8.RuneCountInString(m.GetPermission()); l < 1 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "Permission",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := CreateMenuReqValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Icon != nil {

		if l := utf8.RuneCountInString(m.GetIcon()); l < 0 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "Icon",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.KeepAlive != nil {

		if _, ok := _CreateMenuReq_KeepAlive_NotInLookup[m.GetKeepAlive()]; ok {
			err := CreateMenuReqValidationError{
				field:  "KeepAlive",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuKeepAlive_name[int32(m.GetKeepAlive())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "KeepAlive",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.BaseMenu != nil {

		if _, ok := _CreateMenuReq_BaseMenu_NotInLookup[m.GetBaseMenu()]; ok {
			err := CreateMenuReqValidationError{
				field:  "BaseMenu",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuBaseMenu_name[int32(m.GetBaseMenu())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "BaseMenu",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.CloseTab != nil {

		if _, ok := _CreateMenuReq_CloseTab_NotInLookup[m.GetCloseTab()]; ok {
			err := CreateMenuReqValidationError{
				field:  "CloseTab",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuCloseTab_name[int32(m.GetCloseTab())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "CloseTab",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ExtType != nil {

		if _, ok := _CreateMenuReq_ExtType_NotInLookup[m.GetExtType()]; ok {
			err := CreateMenuReqValidationError{
				field:  "ExtType",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuExtType_name[int32(m.GetExtType())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "ExtType",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateMenuReqMultiError(errors)
	}

	return nil
}

// CreateMenuReqMultiError is an error wrapping multiple validation errors
// returned by CreateMenuReq.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuReqMultiError) AllErrors() []error { return m }

// CreateMenuReqValidationError is the validation error returned by
// CreateMenuReq.Validate if the designated constraints aren't met.
type CreateMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuReqValidationError) ErrorName() string { return "CreateMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuReqValidationError{}

var _CreateMenuReq_Type_NotInLookup = map[protobuf.MenuType]struct{}{
	0: {},
}

var _CreateMenuReq_Hidden_NotInLookup = map[protobuf.MenuHidden]struct{}{
	0: {},
}

var _CreateMenuReq_KeepAlive_NotInLookup = map[protobuf.MenuKeepAlive]struct{}{
	0: {},
}

var _CreateMenuReq_BaseMenu_NotInLookup = map[protobuf.MenuBaseMenu]struct{}{
	0: {},
}

var _CreateMenuReq_CloseTab_NotInLookup = map[protobuf.MenuCloseTab]struct{}{
	0: {},
}

var _CreateMenuReq_ExtType_NotInLookup = map[protobuf.MenuExtType]struct{}{
	0: {},
}

// Validate checks the field values on CreateMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMenuReplyMultiError, or nil if none found.
func (m *CreateMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateMenuReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateMenuReplyMultiError(errors)
	}

	return nil
}

// CreateMenuReplyMultiError is an error wrapping multiple validation errors
// returned by CreateMenuReply.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuReplyMultiError) AllErrors() []error { return m }

// CreateMenuReplyValidationError is the validation error returned by
// CreateMenuReply.Validate if the designated constraints aren't met.
type CreateMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuReplyValidationError) ErrorName() string { return "CreateMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuReplyValidationError{}

// Validate checks the field values on UpdateMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateMenuReqMultiError, or
// nil if none found.
func (m *UpdateMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMenuReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMenuReqMultiError(errors)
	}

	return nil
}

// UpdateMenuReqMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReqMultiError) AllErrors() []error { return m }

// UpdateMenuReqValidationError is the validation error returned by
// UpdateMenuReq.Validate if the designated constraints aren't met.
type UpdateMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReqValidationError) ErrorName() string { return "UpdateMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReqValidationError{}

// Validate checks the field values on UpdateMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuReplyMultiError, or nil if none found.
func (m *UpdateMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMenuReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMenuReplyMultiError(errors)
	}

	return nil
}

// UpdateMenuReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReplyMultiError) AllErrors() []error { return m }

// UpdateMenuReplyValidationError is the validation error returned by
// UpdateMenuReply.Validate if the designated constraints aren't met.
type UpdateMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReplyValidationError) ErrorName() string { return "UpdateMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReplyValidationError{}

// Validate checks the field values on GetMenuReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMenuReqMultiError, or
// nil if none found.
func (m *GetMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMenuReqMultiError(errors)
	}

	return nil
}

// GetMenuReqMultiError is an error wrapping multiple validation errors
// returned by GetMenuReq.ValidateAll() if the designated constraints aren't met.
type GetMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMenuReqMultiError) AllErrors() []error { return m }

// GetMenuReqValidationError is the validation error returned by
// GetMenuReq.Validate if the designated constraints aren't met.
type GetMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMenuReqValidationError) ErrorName() string { return "GetMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e GetMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMenuReqValidationError{}

// Validate checks the field values on DeleteMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteMenuReqMultiError, or
// nil if none found.
func (m *DeleteMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteMenuReqMultiError(errors)
	}

	return nil
}

// DeleteMenuReqMultiError is an error wrapping multiple validation errors
// returned by DeleteMenuReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMenuReqMultiError) AllErrors() []error { return m }

// DeleteMenuReqValidationError is the validation error returned by
// DeleteMenuReq.Validate if the designated constraints aren't met.
type DeleteMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMenuReqValidationError) ErrorName() string { return "DeleteMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMenuReqValidationError{}

// Validate checks the field values on DeleteMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMenuReplyMultiError, or nil if none found.
func (m *DeleteMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteMenuReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteMenuReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteMenuReplyMultiError(errors)
	}

	return nil
}

// DeleteMenuReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteMenuReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMenuReplyMultiError) AllErrors() []error { return m }

// DeleteMenuReplyValidationError is the validation error returned by
// DeleteMenuReply.Validate if the designated constraints aren't met.
type DeleteMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMenuReplyValidationError) ErrorName() string { return "DeleteMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMenuReplyValidationError{}

// Validate checks the field values on ListMenuTreeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMenuTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuTreeReqMultiError, or nil if none found.
func (m *ListMenuTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetParentId() < 0 {
		err := ListMenuTreeReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListMenuTreeReqMultiError(errors)
	}

	return nil
}

// ListMenuTreeReqMultiError is an error wrapping multiple validation errors
// returned by ListMenuTreeReq.ValidateAll() if the designated constraints
// aren't met.
type ListMenuTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuTreeReqMultiError) AllErrors() []error { return m }

// ListMenuTreeReqValidationError is the validation error returned by
// ListMenuTreeReq.Validate if the designated constraints aren't met.
type ListMenuTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuTreeReqValidationError) ErrorName() string { return "ListMenuTreeReqValidationError" }

// Error satisfies the builtin error interface
func (e ListMenuTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuTreeReqValidationError{}

// Validate checks the field values on ListMenuTreeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuTreeReplyMultiError, or nil if none found.
func (m *ListMenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMenuTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMenuTreeReplyMultiError(errors)
	}

	return nil
}

// ListMenuTreeReplyMultiError is an error wrapping multiple validation errors
// returned by ListMenuTreeReply.ValidateAll() if the designated constraints
// aren't met.
type ListMenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuTreeReplyMultiError) AllErrors() []error { return m }

// ListMenuTreeReplyValidationError is the validation error returned by
// ListMenuTreeReply.Validate if the designated constraints aren't met.
type ListMenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuTreeReplyValidationError) ErrorName() string {
	return "ListMenuTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListMenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuTreeReplyValidationError{}

// Validate checks the field values on Department with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Department) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Department with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DepartmentMultiError, or
// nil if none found.
func (m *Department) ValidateAll() error {
	return m.validate(true)
}

func (m *Department) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DepartmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DepartmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DepartmentValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DepartmentValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DepartmentValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DepartmentValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for Sort

	// no validation rules for Remarks

	// no validation rules for State

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DepartmentValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DepartmentValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DepartmentValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DepartmentMultiError(errors)
	}

	return nil
}

// DepartmentMultiError is an error wrapping multiple validation errors
// returned by Department.ValidateAll() if the designated constraints aren't met.
type DepartmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepartmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepartmentMultiError) AllErrors() []error { return m }

// DepartmentValidationError is the validation error returned by
// Department.Validate if the designated constraints aren't met.
type DepartmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepartmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepartmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepartmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepartmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepartmentValidationError) ErrorName() string { return "DepartmentValidationError" }

// Error satisfies the builtin error interface
func (e DepartmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepartment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepartmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepartmentValidationError{}

// Validate checks the field values on CreateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDepartmentReqMultiError, or nil if none found.
func (m *CreateDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDepartmentReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateDepartmentReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreateDepartmentReqValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateDepartmentReq_State_NotInLookup[m.GetState()]; ok {
		err := CreateDepartmentReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.DepartmentState_name[int32(m.GetState())]; !ok {
		err := CreateDepartmentReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := CreateDepartmentReqValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDepartmentReqMultiError(errors)
	}

	return nil
}

// CreateDepartmentReqMultiError is an error wrapping multiple validation
// errors returned by CreateDepartmentReq.ValidateAll() if the designated
// constraints aren't met.
type CreateDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDepartmentReqMultiError) AllErrors() []error { return m }

// CreateDepartmentReqValidationError is the validation error returned by
// CreateDepartmentReq.Validate if the designated constraints aren't met.
type CreateDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDepartmentReqValidationError) ErrorName() string {
	return "CreateDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDepartmentReqValidationError{}

var _CreateDepartmentReq_State_NotInLookup = map[protobuf.DepartmentState]struct{}{
	0: {},
}

// Validate checks the field values on CreateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDepartmentReplyMultiError, or nil if none found.
func (m *CreateDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDepartmentReplyMultiError(errors)
	}

	return nil
}

// CreateDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by CreateDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type CreateDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDepartmentReplyMultiError) AllErrors() []error { return m }

// CreateDepartmentReplyValidationError is the validation error returned by
// CreateDepartmentReply.Validate if the designated constraints aren't met.
type CreateDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDepartmentReplyValidationError) ErrorName() string {
	return "CreateDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDepartmentReplyValidationError{}

// Validate checks the field values on UpdateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDepartmentReqMultiError, or nil if none found.
func (m *UpdateDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDepartmentReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDepartmentReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDepartmentReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDepartmentReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDepartmentReqMultiError(errors)
	}

	return nil
}

// UpdateDepartmentReqMultiError is an error wrapping multiple validation
// errors returned by UpdateDepartmentReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDepartmentReqMultiError) AllErrors() []error { return m }

// UpdateDepartmentReqValidationError is the validation error returned by
// UpdateDepartmentReq.Validate if the designated constraints aren't met.
type UpdateDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDepartmentReqValidationError) ErrorName() string {
	return "UpdateDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDepartmentReqValidationError{}

// Validate checks the field values on UpdateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDepartmentReplyMultiError, or nil if none found.
func (m *UpdateDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDepartmentReplyMultiError(errors)
	}

	return nil
}

// UpdateDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDepartmentReplyMultiError) AllErrors() []error { return m }

// UpdateDepartmentReplyValidationError is the validation error returned by
// UpdateDepartmentReply.Validate if the designated constraints aren't met.
type UpdateDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDepartmentReplyValidationError) ErrorName() string {
	return "UpdateDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDepartmentReplyValidationError{}

// Validate checks the field values on GetDepartmentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDepartmentReqMultiError, or nil if none found.
func (m *GetDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDepartmentReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDepartmentReqMultiError(errors)
	}

	return nil
}

// GetDepartmentReqMultiError is an error wrapping multiple validation errors
// returned by GetDepartmentReq.ValidateAll() if the designated constraints
// aren't met.
type GetDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepartmentReqMultiError) AllErrors() []error { return m }

// GetDepartmentReqValidationError is the validation error returned by
// GetDepartmentReq.Validate if the designated constraints aren't met.
type GetDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepartmentReqValidationError) ErrorName() string { return "GetDepartmentReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepartmentReqValidationError{}

// Validate checks the field values on DeleteDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDepartmentReqMultiError, or nil if none found.
func (m *DeleteDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDepartmentReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDepartmentReqMultiError(errors)
	}

	return nil
}

// DeleteDepartmentReqMultiError is an error wrapping multiple validation
// errors returned by DeleteDepartmentReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDepartmentReqMultiError) AllErrors() []error { return m }

// DeleteDepartmentReqValidationError is the validation error returned by
// DeleteDepartmentReq.Validate if the designated constraints aren't met.
type DeleteDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDepartmentReqValidationError) ErrorName() string {
	return "DeleteDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDepartmentReqValidationError{}

// Validate checks the field values on DeleteDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDepartmentReplyMultiError, or nil if none found.
func (m *DeleteDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteDepartmentReplyMultiError(errors)
	}

	return nil
}

// DeleteDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDepartmentReplyMultiError) AllErrors() []error { return m }

// DeleteDepartmentReplyValidationError is the validation error returned by
// DeleteDepartmentReply.Validate if the designated constraints aren't met.
type DeleteDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDepartmentReplyValidationError) ErrorName() string {
	return "DeleteDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDepartmentReplyValidationError{}

// Validate checks the field values on ListDepartmentTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDepartmentTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDepartmentTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDepartmentTreeReqMultiError, or nil if none found.
func (m *ListDepartmentTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDepartmentTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetParentId() < 0 {
		err := ListDepartmentTreeReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListDepartmentTreeReqMultiError(errors)
	}

	return nil
}

// ListDepartmentTreeReqMultiError is an error wrapping multiple validation
// errors returned by ListDepartmentTreeReq.ValidateAll() if the designated
// constraints aren't met.
type ListDepartmentTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDepartmentTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDepartmentTreeReqMultiError) AllErrors() []error { return m }

// ListDepartmentTreeReqValidationError is the validation error returned by
// ListDepartmentTreeReq.Validate if the designated constraints aren't met.
type ListDepartmentTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDepartmentTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDepartmentTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDepartmentTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDepartmentTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDepartmentTreeReqValidationError) ErrorName() string {
	return "ListDepartmentTreeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListDepartmentTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDepartmentTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDepartmentTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDepartmentTreeReqValidationError{}

// Validate checks the field values on ListDepartmentTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDepartmentTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDepartmentTreeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDepartmentTreeReplyMultiError, or nil if none found.
func (m *ListDepartmentTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDepartmentTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDepartmentTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDepartmentTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDepartmentTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDepartmentTreeReplyMultiError(errors)
	}

	return nil
}

// ListDepartmentTreeReplyMultiError is an error wrapping multiple validation
// errors returned by ListDepartmentTreeReply.ValidateAll() if the designated
// constraints aren't met.
type ListDepartmentTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDepartmentTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDepartmentTreeReplyMultiError) AllErrors() []error { return m }

// ListDepartmentTreeReplyValidationError is the validation error returned by
// ListDepartmentTreeReply.Validate if the designated constraints aren't met.
type ListDepartmentTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDepartmentTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDepartmentTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDepartmentTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDepartmentTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDepartmentTreeReplyValidationError) ErrorName() string {
	return "ListDepartmentTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListDepartmentTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDepartmentTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDepartmentTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDepartmentTreeReplyValidationError{}

// Validate checks the field values on Post with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Post) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Post with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PostMultiError, or nil if none found.
func (m *Post) ValidateAll() error {
	return m.validate(true)
}

func (m *Post) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Code

	// no validation rules for Sort

	// no validation rules for Remarks

	// no validation rules for State

	if len(errors) > 0 {
		return PostMultiError(errors)
	}

	return nil
}

// PostMultiError is an error wrapping multiple validation errors returned by
// Post.ValidateAll() if the designated constraints aren't met.
type PostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostMultiError) AllErrors() []error { return m }

// PostValidationError is the validation error returned by Post.Validate if the
// designated constraints aren't met.
type PostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostValidationError) ErrorName() string { return "PostValidationError" }

// Error satisfies the builtin error interface
func (e PostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostValidationError{}

// Validate checks the field values on CreatePostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatePostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatePostReqMultiError, or
// nil if none found.
func (m *CreatePostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreatePostReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreatePostReqValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreatePostReq_State_NotInLookup[m.GetState()]; ok {
		err := CreatePostReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.PostState_name[int32(m.GetState())]; !ok {
		err := CreatePostReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Code != nil {

		if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 10 {
			err := CreatePostReqValidationError{
				field:  "Code",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreatePostReqValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreatePostReqMultiError(errors)
	}

	return nil
}

// CreatePostReqMultiError is an error wrapping multiple validation errors
// returned by CreatePostReq.ValidateAll() if the designated constraints
// aren't met.
type CreatePostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePostReqMultiError) AllErrors() []error { return m }

// CreatePostReqValidationError is the validation error returned by
// CreatePostReq.Validate if the designated constraints aren't met.
type CreatePostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePostReqValidationError) ErrorName() string { return "CreatePostReqValidationError" }

// Error satisfies the builtin error interface
func (e CreatePostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePostReqValidationError{}

var _CreatePostReq_State_NotInLookup = map[protobuf.PostState]struct{}{
	0: {},
}

// Validate checks the field values on CreatePostReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePostReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePostReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePostReplyMultiError, or nil if none found.
func (m *CreatePostReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePostReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePostReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePostReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePostReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePostReplyMultiError(errors)
	}

	return nil
}

// CreatePostReplyMultiError is an error wrapping multiple validation errors
// returned by CreatePostReply.ValidateAll() if the designated constraints
// aren't met.
type CreatePostReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePostReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePostReplyMultiError) AllErrors() []error { return m }

// CreatePostReplyValidationError is the validation error returned by
// CreatePostReply.Validate if the designated constraints aren't met.
type CreatePostReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePostReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePostReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePostReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePostReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePostReplyValidationError) ErrorName() string { return "CreatePostReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreatePostReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePostReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePostReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePostReplyValidationError{}

// Validate checks the field values on UpdatePostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatePostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatePostReqMultiError, or
// nil if none found.
func (m *UpdatePostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdatePostReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostReqMultiError(errors)
	}

	return nil
}

// UpdatePostReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePostReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostReqMultiError) AllErrors() []error { return m }

// UpdatePostReqValidationError is the validation error returned by
// UpdatePostReq.Validate if the designated constraints aren't met.
type UpdatePostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostReqValidationError) ErrorName() string { return "UpdatePostReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostReqValidationError{}

// Validate checks the field values on UpdatePostReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostReplyMultiError, or nil if none found.
func (m *UpdatePostReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostReplyMultiError(errors)
	}

	return nil
}

// UpdatePostReplyMultiError is an error wrapping multiple validation errors
// returned by UpdatePostReply.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostReplyMultiError) AllErrors() []error { return m }

// UpdatePostReplyValidationError is the validation error returned by
// UpdatePostReply.Validate if the designated constraints aren't met.
type UpdatePostReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostReplyValidationError) ErrorName() string { return "UpdatePostReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePostReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostReplyValidationError{}

// Validate checks the field values on GetPostReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPostReqMultiError, or
// nil if none found.
func (m *GetPostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetPostReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPostReqMultiError(errors)
	}

	return nil
}

// GetPostReqMultiError is an error wrapping multiple validation errors
// returned by GetPostReq.ValidateAll() if the designated constraints aren't met.
type GetPostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPostReqMultiError) AllErrors() []error { return m }

// GetPostReqValidationError is the validation error returned by
// GetPostReq.Validate if the designated constraints aren't met.
type GetPostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPostReqValidationError) ErrorName() string { return "GetPostReqValidationError" }

// Error satisfies the builtin error interface
func (e GetPostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPostReqValidationError{}

// Validate checks the field values on DeletePostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletePostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletePostReqMultiError, or
// nil if none found.
func (m *DeletePostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeletePostReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePostReqMultiError(errors)
	}

	return nil
}

// DeletePostReqMultiError is an error wrapping multiple validation errors
// returned by DeletePostReq.ValidateAll() if the designated constraints
// aren't met.
type DeletePostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePostReqMultiError) AllErrors() []error { return m }

// DeletePostReqValidationError is the validation error returned by
// DeletePostReq.Validate if the designated constraints aren't met.
type DeletePostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePostReqValidationError) ErrorName() string { return "DeletePostReqValidationError" }

// Error satisfies the builtin error interface
func (e DeletePostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePostReqValidationError{}

// Validate checks the field values on DeletePostReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeletePostReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePostReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePostReplyMultiError, or nil if none found.
func (m *DeletePostReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePostReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeletePostReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeletePostReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeletePostReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeletePostReplyMultiError(errors)
	}

	return nil
}

// DeletePostReplyMultiError is an error wrapping multiple validation errors
// returned by DeletePostReply.ValidateAll() if the designated constraints
// aren't met.
type DeletePostReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePostReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePostReplyMultiError) AllErrors() []error { return m }

// DeletePostReplyValidationError is the validation error returned by
// DeletePostReply.Validate if the designated constraints aren't met.
type DeletePostReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePostReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePostReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePostReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePostReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePostReplyValidationError) ErrorName() string { return "DeletePostReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeletePostReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePostReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePostReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePostReplyValidationError{}

// Validate checks the field values on UpdatePostStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateReqMultiError, or nil if none found.
func (m *UpdatePostStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdatePostStateReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostStateReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostStateReqMultiError(errors)
	}

	return nil
}

// UpdatePostStateReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePostStateReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateReqMultiError) AllErrors() []error { return m }

// UpdatePostStateReqValidationError is the validation error returned by
// UpdatePostStateReq.Validate if the designated constraints aren't met.
type UpdatePostStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateReqValidationError) ErrorName() string {
	return "UpdatePostStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateReqValidationError{}

// Validate checks the field values on UpdatePostStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateReplyMultiError, or nil if none found.
func (m *UpdatePostStateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostStateReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostStateReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostStateReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostStateReplyMultiError(errors)
	}

	return nil
}

// UpdatePostStateReplyMultiError is an error wrapping multiple validation
// errors returned by UpdatePostStateReply.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostStateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateReplyMultiError) AllErrors() []error { return m }

// UpdatePostStateReplyValidationError is the validation error returned by
// UpdatePostStateReply.Validate if the designated constraints aren't met.
type UpdatePostStateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateReplyValidationError) ErrorName() string {
	return "UpdatePostStateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateReplyValidationError{}

// Validate checks the field values on PassLoginReq_PassField with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PassLoginReq_PassField) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PassLoginReq_PassField with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PassLoginReq_PassFieldMultiError, or nil if none found.
func (m *PassLoginReq_PassField) ValidateAll() error {
	return m.validate(true)
}

func (m *PassLoginReq_PassField) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccount()); l < 1 || l > 10 {
		err := PassLoginReq_PassFieldValidationError{
			field:  "Account",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
		err := PassLoginReq_PassFieldValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 28 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PassLoginReq_PassFieldMultiError(errors)
	}

	return nil
}

// PassLoginReq_PassFieldMultiError is an error wrapping multiple validation
// errors returned by PassLoginReq_PassField.ValidateAll() if the designated
// constraints aren't met.
type PassLoginReq_PassFieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PassLoginReq_PassFieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PassLoginReq_PassFieldMultiError) AllErrors() []error { return m }

// PassLoginReq_PassFieldValidationError is the validation error returned by
// PassLoginReq_PassField.Validate if the designated constraints aren't met.
type PassLoginReq_PassFieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PassLoginReq_PassFieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PassLoginReq_PassFieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PassLoginReq_PassFieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PassLoginReq_PassFieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PassLoginReq_PassFieldValidationError) ErrorName() string {
	return "PassLoginReq_PassFieldValidationError"
}

// Error satisfies the builtin error interface
func (e PassLoginReq_PassFieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPassLoginReq_PassField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PassLoginReq_PassFieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PassLoginReq_PassFieldValidationError{}

// Validate checks the field values on SmsLoginReq_SmsField with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SmsLoginReq_SmsField) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginReq_SmsField with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SmsLoginReq_SmsFieldMultiError, or nil if none found.
func (m *SmsLoginReq_SmsField) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginReq_SmsField) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SmsLoginReq_SmsField_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := SmsLoginReq_SmsFieldValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SmsLoginReq_SmsField_Code_Pattern.MatchString(m.GetCode()) {
		err := SmsLoginReq_SmsFieldValidationError{
			field:  "Code",
			reason: "value does not match regex pattern \"^[0-9]{6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SmsLoginReq_SmsFieldMultiError(errors)
	}

	return nil
}

// SmsLoginReq_SmsFieldMultiError is an error wrapping multiple validation
// errors returned by SmsLoginReq_SmsField.ValidateAll() if the designated
// constraints aren't met.
type SmsLoginReq_SmsFieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginReq_SmsFieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginReq_SmsFieldMultiError) AllErrors() []error { return m }

// SmsLoginReq_SmsFieldValidationError is the validation error returned by
// SmsLoginReq_SmsField.Validate if the designated constraints aren't met.
type SmsLoginReq_SmsFieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginReq_SmsFieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginReq_SmsFieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginReq_SmsFieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginReq_SmsFieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginReq_SmsFieldValidationError) ErrorName() string {
	return "SmsLoginReq_SmsFieldValidationError"
}

// Error satisfies the builtin error interface
func (e SmsLoginReq_SmsFieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginReq_SmsField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginReq_SmsFieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginReq_SmsFieldValidationError{}

var _SmsLoginReq_SmsField_Mobile_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _SmsLoginReq_SmsField_Code_Pattern = regexp.MustCompile("^[0-9]{6}$")

// Validate checks the field values on EmailLoginReq_EmailField with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailLoginReq_EmailField) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginReq_EmailField with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailLoginReq_EmailFieldMultiError, or nil if none found.
func (m *EmailLoginReq_EmailField) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginReq_EmailField) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = EmailLoginReq_EmailFieldValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EmailLoginReq_EmailField_Code_Pattern.MatchString(m.GetCode()) {
		err := EmailLoginReq_EmailFieldValidationError{
			field:  "Code",
			reason: "value does not match regex pattern \"^[0-9]{6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EmailLoginReq_EmailFieldMultiError(errors)
	}

	return nil
}

func (m *EmailLoginReq_EmailField) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *EmailLoginReq_EmailField) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// EmailLoginReq_EmailFieldMultiError is an error wrapping multiple validation
// errors returned by EmailLoginReq_EmailField.ValidateAll() if the designated
// constraints aren't met.
type EmailLoginReq_EmailFieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginReq_EmailFieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginReq_EmailFieldMultiError) AllErrors() []error { return m }

// EmailLoginReq_EmailFieldValidationError is the validation error returned by
// EmailLoginReq_EmailField.Validate if the designated constraints aren't met.
type EmailLoginReq_EmailFieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginReq_EmailFieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginReq_EmailFieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginReq_EmailFieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginReq_EmailFieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginReq_EmailFieldValidationError) ErrorName() string {
	return "EmailLoginReq_EmailFieldValidationError"
}

// Error satisfies the builtin error interface
func (e EmailLoginReq_EmailFieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginReq_EmailField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginReq_EmailFieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginReq_EmailFieldValidationError{}

var _EmailLoginReq_EmailField_Code_Pattern = regexp.MustCompile("^[0-9]{6}$")

// Validate checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply_Deprecated_MenuMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Deprecated_MenuMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Deprecated_MenuMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for DynamicLevel

	// no validation rules for RealPath

	// no validation rules for IgnoreKeepAlive

	// no validation rules for Affix

	// no validation rules for Icon

	// no validation rules for FrameSrc

	// no validation rules for TransitionName

	// no validation rules for HideBreadcrumb

	// no validation rules for CarryParam

	// no validation rules for HideChildrenInMenu

	// no validation rules for CurrentActiveMenu

	// no validation rules for HideTab

	// no validation rules for HideMenu

	// no validation rules for OrderNo

	// no validation rules for IgnoreRoute

	// no validation rules for HidePathForChildren

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError is an error wrapping
// multiple validation errors returned by
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta.ValidateAll() if the
// designated constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError is the
// validation error returned by
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Deprecated_MenuMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError{}

// Validate checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply_Deprecated_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_Deprecated_MenuMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Deprecated_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Deprecated_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Component

	// no validation rules for Redirect

	// no validation rules for FullPath

	// no validation rules for Alias

	// no validation rules for CaseSensitive

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_Deprecated_MenuMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_Deprecated_MenuMultiError is an error wrapping
// multiple validation errors returned by
// ListUserRoleMenuTreeReply_Deprecated_Menu.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_Deprecated_MenuValidationError is the validation
// error returned by ListUserRoleMenuTreeReply_Deprecated_Menu.Validate if the
// designated constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_Deprecated_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Deprecated_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReply_Meta with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply_Meta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReply_Meta with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_MetaMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Meta) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Meta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	if m.IgnoreKeepAlive != nil {
		// no validation rules for IgnoreKeepAlive
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.FrameSrc != nil {
		// no validation rules for FrameSrc
	}

	if m.HideBreadcrumb != nil {
		// no validation rules for HideBreadcrumb
	}

	if m.HideMenu != nil {
		// no validation rules for HideMenu
	}

	if m.OrderNo != nil {
		// no validation rules for OrderNo
	}

	if m.CurrentActiveMenu != nil {
		// no validation rules for CurrentActiveMenu
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_MetaMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_MetaMultiError is an error wrapping multiple
// validation errors returned by ListUserRoleMenuTreeReply_Meta.ValidateAll()
// if the designated constraints aren't met.
type ListUserRoleMenuTreeReply_MetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_MetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_MetaMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_MetaValidationError is the validation error
// returned by ListUserRoleMenuTreeReply_Meta.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_MetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_MetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_MetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_MetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_MetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_MetaValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_MetaValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_MetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Meta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_MetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_MetaValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReply_Menu with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReply_Menu with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_MenuMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Component

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeReply_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeReply_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserRoleMenuTreeReply_MenuValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReply_MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Redirect != nil {
		// no validation rules for Redirect
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_MenuMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_MenuMultiError is an error wrapping multiple
// validation errors returned by ListUserRoleMenuTreeReply_Menu.ValidateAll()
// if the designated constraints aren't met.
type ListUserRoleMenuTreeReply_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_MenuMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_MenuValidationError is the validation error
// returned by ListUserRoleMenuTreeReply_Menu.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_MenuValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_MenuValidationError{}

// Validate checks the field values on HandleUserDomainReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserDomainReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserDomainReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserDomainReq_DataMultiError, or nil if none found.
func (m *HandleUserDomainReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserDomainReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetDomainIds()) < 1 {
		err := HandleUserDomainReq_DataValidationError{
			field:  "DomainIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleUserDomainReq_Data_DomainIds_Unique := make(map[uint64]struct{}, len(m.GetDomainIds()))

	for idx, item := range m.GetDomainIds() {
		_, _ = idx, item

		if _, exists := _HandleUserDomainReq_Data_DomainIds_Unique[item]; exists {
			err := HandleUserDomainReq_DataValidationError{
				field:  fmt.Sprintf("DomainIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleUserDomainReq_Data_DomainIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleUserDomainReq_DataValidationError{
				field:  fmt.Sprintf("DomainIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleUserDomainReq_DataMultiError(errors)
	}

	return nil
}

// HandleUserDomainReq_DataMultiError is an error wrapping multiple validation
// errors returned by HandleUserDomainReq_Data.ValidateAll() if the designated
// constraints aren't met.
type HandleUserDomainReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserDomainReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserDomainReq_DataMultiError) AllErrors() []error { return m }

// HandleUserDomainReq_DataValidationError is the validation error returned by
// HandleUserDomainReq_Data.Validate if the designated constraints aren't met.
type HandleUserDomainReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserDomainReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserDomainReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserDomainReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserDomainReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserDomainReq_DataValidationError) ErrorName() string {
	return "HandleUserDomainReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserDomainReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserDomainReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserDomainReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserDomainReq_DataValidationError{}

// Validate checks the field values on HandleUserDomainRoleReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserDomainRoleReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserDomainRoleReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserDomainRoleReq_DataMultiError, or nil if none found.
func (m *HandleUserDomainRoleReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserDomainRoleReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDomainId() <= 0 {
		err := HandleUserDomainRoleReq_DataValidationError{
			field:  "DomainId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRoleIds()) < 1 {
		err := HandleUserDomainRoleReq_DataValidationError{
			field:  "RoleIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleUserDomainRoleReq_Data_RoleIds_Unique := make(map[uint64]struct{}, len(m.GetRoleIds()))

	for idx, item := range m.GetRoleIds() {
		_, _ = idx, item

		if _, exists := _HandleUserDomainRoleReq_Data_RoleIds_Unique[item]; exists {
			err := HandleUserDomainRoleReq_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleUserDomainRoleReq_Data_RoleIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleUserDomainRoleReq_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleUserDomainRoleReq_DataMultiError(errors)
	}

	return nil
}

// HandleUserDomainRoleReq_DataMultiError is an error wrapping multiple
// validation errors returned by HandleUserDomainRoleReq_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleUserDomainRoleReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserDomainRoleReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserDomainRoleReq_DataMultiError) AllErrors() []error { return m }

// HandleUserDomainRoleReq_DataValidationError is the validation error returned
// by HandleUserDomainRoleReq_Data.Validate if the designated constraints
// aren't met.
type HandleUserDomainRoleReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserDomainRoleReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserDomainRoleReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserDomainRoleReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserDomainRoleReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserDomainRoleReq_DataValidationError) ErrorName() string {
	return "HandleUserDomainRoleReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserDomainRoleReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserDomainRoleReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserDomainRoleReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserDomainRoleReq_DataValidationError{}

// Validate checks the field values on UpdateUserReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserReq_DataMultiError, or nil if none found.
func (m *UpdateUserReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateUserReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateUserReq_Data_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := UpdateUserReq_DataValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateUserReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateUserReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.UserState_name[int32(m.GetState())]; !ok {
		err := UpdateUserReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Password != nil {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
			err := UpdateUserReq_DataValidationError{
				field:  "Password",
				reason: "value length must be between 6 and 28 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NickName != nil {

		if l := utf8.RuneCountInString(m.GetNickName()); l < 1 || l > 10 {
			err := UpdateUserReq_DataValidationError{
				field:  "NickName",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RealName != nil {

		if l := utf8.RuneCountInString(m.GetRealName()); l < 2 || l > 10 {
			err := UpdateUserReq_DataValidationError{
				field:  "RealName",
				reason: "value length must be between 2 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Birthday != nil {

		if !_UpdateUserReq_Data_Birthday_Pattern.MatchString(m.GetBirthday()) {
			err := UpdateUserReq_DataValidationError{
				field:  "Birthday",
				reason: "value does not match regex pattern \"^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Gender != nil {

		if _, ok := _UpdateUserReq_Data_Gender_NotInLookup[m.GetGender()]; ok {
			err := UpdateUserReq_DataValidationError{
				field:  "Gender",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.UserGender_name[int32(m.GetGender())]; !ok {
			err := UpdateUserReq_DataValidationError{
				field:  "Gender",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = UpdateUserReq_DataValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if len(errors) > 0 {
		return UpdateUserReq_DataMultiError(errors)
	}

	return nil
}

func (m *UpdateUserReq_Data) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UpdateUserReq_Data) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UpdateUserReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReq_DataMultiError) AllErrors() []error { return m }

// UpdateUserReq_DataValidationError is the validation error returned by
// UpdateUserReq_Data.Validate if the designated constraints aren't met.
type UpdateUserReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReq_DataValidationError) ErrorName() string {
	return "UpdateUserReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReq_DataValidationError{}

var _UpdateUserReq_Data_Birthday_Pattern = regexp.MustCompile("^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$")

var _UpdateUserReq_Data_Gender_NotInLookup = map[protobuf.UserGender]struct{}{
	0: {},
}

var _UpdateUserReq_Data_Mobile_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _UpdateUserReq_Data_State_NotInLookup = map[protobuf.UserState]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDomainReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainReq_DataMultiError, or nil if none found.
func (m *UpdateDomainReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDomainReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ParentId != nil {

		if m.GetParentId() < 0 {
			err := UpdateDomainReq_DataValidationError{
				field:  "ParentId",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateDomainReq_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.State != nil {

		if _, ok := _UpdateDomainReq_Data_State_NotInLookup[m.GetState()]; ok {
			err := UpdateDomainReq_DataValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.DomainState_name[int32(m.GetState())]; !ok {
			err := UpdateDomainReq_DataValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DefaultRoleId != nil {

		if m.GetDefaultRoleId() <= 0 {
			err := UpdateDomainReq_DataValidationError{
				field:  "DefaultRoleId",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainReq_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainReq_DataMultiError) AllErrors() []error { return m }

// UpdateDomainReq_DataValidationError is the validation error returned by
// UpdateDomainReq_Data.Validate if the designated constraints aren't met.
type UpdateDomainReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainReq_DataValidationError) ErrorName() string {
	return "UpdateDomainReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainReq_DataValidationError{}

var _UpdateDomainReq_Data_State_NotInLookup = map[protobuf.DomainState]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDomainStateReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateReq_DataMultiError, or nil if none found.
func (m *UpdateDomainStateReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if _, ok := _UpdateDomainStateReq_Data_State_NotInLookup[m.GetState()]; ok {
			err := UpdateDomainStateReq_DataValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.DomainState_name[int32(m.GetState())]; !ok {
			err := UpdateDomainStateReq_DataValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainStateReq_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainStateReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateReq_Data.ValidateAll() if the
// designated constraints aren't met.
type UpdateDomainStateReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateReq_DataMultiError) AllErrors() []error { return m }

// UpdateDomainStateReq_DataValidationError is the validation error returned by
// UpdateDomainStateReq_Data.Validate if the designated constraints aren't met.
type UpdateDomainStateReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateReq_DataValidationError) ErrorName() string {
	return "UpdateDomainStateReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateReq_DataValidationError{}

var _UpdateDomainStateReq_Data_State_NotInLookup = map[protobuf.DomainState]struct{}{
	0: {},
}

// Validate checks the field values on HandleDomainMenuReq_Menu with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReq_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReq_Menu with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReq_MenuMultiError, or nil if none found.
func (m *HandleDomainMenuReq_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReq_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleDomainMenuReq_MenuValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleDomainMenuReq_Menu_MenuParameterIds_Unique := make(map[uint64]struct{}, len(m.GetMenuParameterIds()))

	for idx, item := range m.GetMenuParameterIds() {
		_, _ = idx, item

		if _, exists := _HandleDomainMenuReq_Menu_MenuParameterIds_Unique[item]; exists {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleDomainMenuReq_Menu_MenuParameterIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_HandleDomainMenuReq_Menu_MenuButtonIds_Unique := make(map[uint64]struct{}, len(m.GetMenuButtonIds()))

	for idx, item := range m.GetMenuButtonIds() {
		_, _ = idx, item

		if _, exists := _HandleDomainMenuReq_Menu_MenuButtonIds_Unique[item]; exists {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleDomainMenuReq_Menu_MenuButtonIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuReq_MenuMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReq_MenuMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReq_Menu.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReq_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReq_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReq_MenuMultiError) AllErrors() []error { return m }

// HandleDomainMenuReq_MenuValidationError is the validation error returned by
// HandleDomainMenuReq_Menu.Validate if the designated constraints aren't met.
type HandleDomainMenuReq_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReq_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReq_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReq_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReq_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReq_MenuValidationError) ErrorName() string {
	return "HandleDomainMenuReq_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReq_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReq_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReq_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReq_MenuValidationError{}

// Validate checks the field values on HandleDomainMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReq_DataMultiError, or nil if none found.
func (m *HandleDomainMenuReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleDomainMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleDomainMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleDomainMenuReq_DataValidationError{
					field:  fmt.Sprintf("Menus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuReq_DataMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReq_DataMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReq_Data.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReq_DataMultiError) AllErrors() []error { return m }

// HandleDomainMenuReq_DataValidationError is the validation error returned by
// HandleDomainMenuReq_Data.Validate if the designated constraints aren't met.
type HandleDomainMenuReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReq_DataValidationError) ErrorName() string {
	return "HandleDomainMenuReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReq_DataValidationError{}

// Validate checks the field values on UpdateRoleReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleReq_DataMultiError, or nil if none found.
func (m *UpdateRoleReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateRoleReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateRoleReq_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateRoleReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateRoleReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.RoleState_name[int32(m.GetState())]; !ok {
		err := UpdateRoleReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.DefaultRouter != nil {

		if l := utf8.RuneCountInString(m.GetDefaultRouter()); l < 1 || l > 100 {
			err := UpdateRoleReq_DataValidationError{
				field:  "DefaultRouter",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateRoleReq_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := UpdateRoleReq_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateRoleReq_DataMultiError(errors)
	}

	return nil
}

// UpdateRoleReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReq_DataMultiError) AllErrors() []error { return m }

// UpdateRoleReq_DataValidationError is the validation error returned by
// UpdateRoleReq_Data.Validate if the designated constraints aren't met.
type UpdateRoleReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReq_DataValidationError) ErrorName() string {
	return "UpdateRoleReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReq_DataValidationError{}

var _UpdateRoleReq_Data_State_NotInLookup = map[protobuf.RoleState]struct{}{
	0: {},
}

// Validate checks the field values on UpdateRoleStateReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateReq_DataMultiError, or nil if none found.
func (m *UpdateRoleStateReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _UpdateRoleStateReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateRoleStateReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.RoleState_name[int32(m.GetState())]; !ok {
		err := UpdateRoleStateReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateRoleStateReq_DataMultiError(errors)
	}

	return nil
}

// UpdateRoleStateReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleStateReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleStateReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateReq_DataMultiError) AllErrors() []error { return m }

// UpdateRoleStateReq_DataValidationError is the validation error returned by
// UpdateRoleStateReq_Data.Validate if the designated constraints aren't met.
type UpdateRoleStateReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateReq_DataValidationError) ErrorName() string {
	return "UpdateRoleStateReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateReq_DataValidationError{}

var _UpdateRoleStateReq_Data_State_NotInLookup = map[protobuf.RoleState]struct{}{
	0: {},
}

// Validate checks the field values on HandleRoleMenuReq_Menu with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReq_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReq_Menu with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReq_MenuMultiError, or nil if none found.
func (m *HandleRoleMenuReq_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReq_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleMenuReq_MenuValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleRoleMenuReq_Menu_MenuParameterIds_Unique := make(map[uint64]struct{}, len(m.GetMenuParameterIds()))

	for idx, item := range m.GetMenuParameterIds() {
		_, _ = idx, item

		if _, exists := _HandleRoleMenuReq_Menu_MenuParameterIds_Unique[item]; exists {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleRoleMenuReq_Menu_MenuParameterIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_HandleRoleMenuReq_Menu_MenuButtonIds_Unique := make(map[uint64]struct{}, len(m.GetMenuButtonIds()))

	for idx, item := range m.GetMenuButtonIds() {
		_, _ = idx, item

		if _, exists := _HandleRoleMenuReq_Menu_MenuButtonIds_Unique[item]; exists {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleRoleMenuReq_Menu_MenuButtonIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleRoleMenuReq_MenuMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReq_MenuMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuReq_Menu.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuReq_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReq_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReq_MenuMultiError) AllErrors() []error { return m }

// HandleRoleMenuReq_MenuValidationError is the validation error returned by
// HandleRoleMenuReq_Menu.Validate if the designated constraints aren't met.
type HandleRoleMenuReq_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReq_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReq_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReq_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReq_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReq_MenuValidationError) ErrorName() string {
	return "HandleRoleMenuReq_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReq_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReq_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReq_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReq_MenuValidationError{}

// Validate checks the field values on HandleRoleMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReq_DataMultiError, or nil if none found.
func (m *HandleRoleMenuReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleRoleMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleRoleMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleRoleMenuReq_DataValidationError{
					field:  fmt.Sprintf("Menus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleRoleMenuReq_DataMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReq_DataMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuReq_Data.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReq_DataMultiError) AllErrors() []error { return m }

// HandleRoleMenuReq_DataValidationError is the validation error returned by
// HandleRoleMenuReq_Data.Validate if the designated constraints aren't met.
type HandleRoleMenuReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReq_DataValidationError) ErrorName() string {
	return "HandleRoleMenuReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReq_DataValidationError{}

// Validate checks the field values on HandleRoleResourceReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleResourceReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleResourceReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleResourceReq_DataMultiError, or nil if none found.
func (m *HandleRoleResourceReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleResourceReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HandleRoleResourceReq_DataMultiError(errors)
	}

	return nil
}

// HandleRoleResourceReq_DataMultiError is an error wrapping multiple
// validation errors returned by HandleRoleResourceReq_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleRoleResourceReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleResourceReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleResourceReq_DataMultiError) AllErrors() []error { return m }

// HandleRoleResourceReq_DataValidationError is the validation error returned
// by HandleRoleResourceReq_Data.Validate if the designated constraints aren't met.
type HandleRoleResourceReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleResourceReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleResourceReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleResourceReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleResourceReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleResourceReq_DataValidationError) ErrorName() string {
	return "HandleRoleResourceReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleResourceReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleResourceReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleResourceReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleResourceReq_DataValidationError{}

// Validate checks the field values on UpdateResourceReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateResourceReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResourceReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateResourceReq_DataMultiError, or nil if none found.
func (m *UpdateResourceReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResourceReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateResourceReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
		err := UpdateResourceReq_DataValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateResourceReq_Data_Method_InLookup[m.GetMethod()]; !ok {
		err := UpdateResourceReq_DataValidationError{
			field:  "Method",
			reason: "value must be in list [* GET POST HEAD PUT PATCH DELETE OPTIONS CONNECT TRACE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Group != nil {

		if l := utf8.RuneCountInString(m.GetGroup()); l < 0 || l > 100 {
			err := UpdateResourceReq_DataValidationError{
				field:  "Group",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
			err := UpdateResourceReq_DataValidationError{
				field:  "Description",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Operation != nil {

		if l := utf8.RuneCountInString(m.GetOperation()); l < 0 || l > 100 {
			err := UpdateResourceReq_DataValidationError{
				field:  "Operation",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateResourceReq_DataMultiError(errors)
	}

	return nil
}

// UpdateResourceReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateResourceReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateResourceReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResourceReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResourceReq_DataMultiError) AllErrors() []error { return m }

// UpdateResourceReq_DataValidationError is the validation error returned by
// UpdateResourceReq_Data.Validate if the designated constraints aren't met.
type UpdateResourceReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResourceReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResourceReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResourceReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResourceReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResourceReq_DataValidationError) ErrorName() string {
	return "UpdateResourceReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateResourceReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResourceReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResourceReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResourceReq_DataValidationError{}

var _UpdateResourceReq_Data_Method_InLookup = map[string]struct{}{
	"*":       {},
	"GET":     {},
	"POST":    {},
	"HEAD":    {},
	"PUT":     {},
	"PATCH":   {},
	"DELETE":  {},
	"OPTIONS": {},
	"CONNECT": {},
	"TRACE":   {},
}

// Validate checks the field values on UpdateMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuReq_DataMultiError, or nil if none found.
func (m *UpdateMenuReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _UpdateMenuReq_Data_Type_NotInLookup[m.GetType()]; ok {
		err := UpdateMenuReq_DataValidationError{
			field:  "Type",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.MenuType_name[int32(m.GetType())]; !ok {
		err := UpdateMenuReq_DataValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateMenuReq_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := UpdateMenuReq_DataValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateMenuReq_DataValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateMenuReq_DataValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Path != nil {

		if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Path",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Hidden != nil {

		if _, ok := _UpdateMenuReq_Data_Hidden_NotInLookup[m.GetHidden()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "Hidden",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuHidden_name[int32(m.GetHidden())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "Hidden",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Component != nil {

		if l := utf8.RuneCountInString(m.GetComponent()); l < 1 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Component",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Permission != nil {

		if l := utf8.RuneCountInString(m.GetPermission()); l < 1 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Permission",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Icon != nil {

		if l := utf8.RuneCountInString(m.GetIcon()); l < 0 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Icon",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.KeepAlive != nil {

		if _, ok := _UpdateMenuReq_Data_KeepAlive_NotInLookup[m.GetKeepAlive()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "KeepAlive",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuKeepAlive_name[int32(m.GetKeepAlive())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "KeepAlive",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.BaseMenu != nil {

		if _, ok := _UpdateMenuReq_Data_BaseMenu_NotInLookup[m.GetBaseMenu()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "BaseMenu",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuBaseMenu_name[int32(m.GetBaseMenu())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "BaseMenu",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.CloseTab != nil {

		if _, ok := _UpdateMenuReq_Data_CloseTab_NotInLookup[m.GetCloseTab()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "CloseTab",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuCloseTab_name[int32(m.GetCloseTab())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "CloseTab",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ExtType != nil {

		if _, ok := _UpdateMenuReq_Data_ExtType_NotInLookup[m.GetExtType()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "ExtType",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuExtType_name[int32(m.GetExtType())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "ExtType",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateMenuReq_DataMultiError(errors)
	}

	return nil
}

// UpdateMenuReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReq_DataMultiError) AllErrors() []error { return m }

// UpdateMenuReq_DataValidationError is the validation error returned by
// UpdateMenuReq_Data.Validate if the designated constraints aren't met.
type UpdateMenuReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReq_DataValidationError) ErrorName() string {
	return "UpdateMenuReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMenuReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReq_DataValidationError{}

var _UpdateMenuReq_Data_Type_NotInLookup = map[protobuf.MenuType]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_Hidden_NotInLookup = map[protobuf.MenuHidden]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_KeepAlive_NotInLookup = map[protobuf.MenuKeepAlive]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_BaseMenu_NotInLookup = map[protobuf.MenuBaseMenu]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_CloseTab_NotInLookup = map[protobuf.MenuCloseTab]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_ExtType_NotInLookup = map[protobuf.MenuExtType]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDepartmentReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDepartmentReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDepartmentReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDepartmentReq_DataMultiError, or nil if none found.
func (m *UpdateDepartmentReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDepartmentReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDepartmentReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateDepartmentReq_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdateDepartmentReq_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateDepartmentReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateDepartmentReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.DepartmentState_name[int32(m.GetState())]; !ok {
		err := UpdateDepartmentReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := UpdateDepartmentReq_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDepartmentReq_DataMultiError(errors)
	}

	return nil
}

// UpdateDepartmentReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDepartmentReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDepartmentReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDepartmentReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDepartmentReq_DataMultiError) AllErrors() []error { return m }

// UpdateDepartmentReq_DataValidationError is the validation error returned by
// UpdateDepartmentReq_Data.Validate if the designated constraints aren't met.
type UpdateDepartmentReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDepartmentReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDepartmentReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDepartmentReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDepartmentReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDepartmentReq_DataValidationError) ErrorName() string {
	return "UpdateDepartmentReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDepartmentReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDepartmentReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDepartmentReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDepartmentReq_DataValidationError{}

var _UpdateDepartmentReq_Data_State_NotInLookup = map[protobuf.DepartmentState]struct{}{
	0: {},
}

// Validate checks the field values on UpdatePostReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostReq_DataMultiError, or nil if none found.
func (m *UpdatePostReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdatePostReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdatePostReq_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdatePostReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdatePostReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.PostState_name[int32(m.GetState())]; !ok {
		err := UpdatePostReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
		err := UpdatePostReq_DataValidationError{
			field:  "Remarks",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Code != nil {

		if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 10 {
			err := UpdatePostReq_DataValidationError{
				field:  "Code",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdatePostReq_DataMultiError(errors)
	}

	return nil
}

// UpdatePostReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdatePostReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostReq_DataMultiError) AllErrors() []error { return m }

// UpdatePostReq_DataValidationError is the validation error returned by
// UpdatePostReq_Data.Validate if the designated constraints aren't met.
type UpdatePostReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostReq_DataValidationError) ErrorName() string {
	return "UpdatePostReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostReq_DataValidationError{}

var _UpdatePostReq_Data_State_NotInLookup = map[protobuf.PostState]struct{}{
	0: {},
}

// Validate checks the field values on UpdatePostStateReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateReq_DataMultiError, or nil if none found.
func (m *UpdatePostStateReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if _, ok := _UpdatePostStateReq_Data_State_NotInLookup[m.GetState()]; ok {
			err := UpdatePostStateReq_DataValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.PostState_name[int32(m.GetState())]; !ok {
			err := UpdatePostStateReq_DataValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdatePostStateReq_DataMultiError(errors)
	}

	return nil
}

// UpdatePostStateReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdatePostStateReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostStateReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateReq_DataMultiError) AllErrors() []error { return m }

// UpdatePostStateReq_DataValidationError is the validation error returned by
// UpdatePostStateReq_Data.Validate if the designated constraints aren't met.
type UpdatePostStateReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateReq_DataValidationError) ErrorName() string {
	return "UpdatePostStateReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateReq_DataValidationError{}

var _UpdatePostStateReq_Data_State_NotInLookup = map[protobuf.PostState]struct{}{
	0: {},
}
