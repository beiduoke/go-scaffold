// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: admin/v1/admin.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Result with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Result) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Result with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ResultMultiError, or nil if none found.
func (m *Result) ValidateAll() error {
	return m.validate(true)
}

func (m *Result) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Data

	if len(errors) > 0 {
		return ResultMultiError(errors)
	}

	return nil
}

// ResultMultiError is an error wrapping multiple validation errors returned by
// Result.ValidateAll() if the designated constraints aren't met.
type ResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultMultiError) AllErrors() []error { return m }

// ResultValidationError is the validation error returned by Result.Validate if
// the designated constraints aren't met.
type ResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultValidationError) ErrorName() string { return "ResultValidationError" }

// Error satisfies the builtin error interface
func (e ResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultValidationError{}

// Validate checks the field values on LoginResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResponseMultiError, or
// nil if none found.
func (m *LoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for RefreshToken

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginResponseValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginResponseValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginResponseValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginResponseMultiError(errors)
	}

	return nil
}

// LoginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResponseMultiError) AllErrors() []error { return m }

// LoginResponseValidationError is the validation error returned by
// LoginResponse.Validate if the designated constraints aren't met.
type LoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResponseValidationError) ErrorName() string { return "LoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e LoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResponseValidationError{}

// Validate checks the field values on SmsLoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SmsLoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SmsLoginResponseMultiError, or nil if none found.
func (m *SmsLoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for RefreshToken

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmsLoginResponseValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmsLoginResponseValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmsLoginResponseValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SmsLoginResponseMultiError(errors)
	}

	return nil
}

// SmsLoginResponseMultiError is an error wrapping multiple validation errors
// returned by SmsLoginResponse.ValidateAll() if the designated constraints
// aren't met.
type SmsLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginResponseMultiError) AllErrors() []error { return m }

// SmsLoginResponseValidationError is the validation error returned by
// SmsLoginResponse.Validate if the designated constraints aren't met.
type SmsLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginResponseValidationError) ErrorName() string { return "SmsLoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e SmsLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginResponseValidationError{}

// Validate checks the field values on EmailLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailLoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailLoginResponseMultiError, or nil if none found.
func (m *EmailLoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for RefreshToken

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailLoginResponseValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailLoginResponseValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailLoginResponseValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EmailLoginResponseMultiError(errors)
	}

	return nil
}

// EmailLoginResponseMultiError is an error wrapping multiple validation errors
// returned by EmailLoginResponse.ValidateAll() if the designated constraints
// aren't met.
type EmailLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginResponseMultiError) AllErrors() []error { return m }

// EmailLoginResponseValidationError is the validation error returned by
// EmailLoginResponse.Validate if the designated constraints aren't met.
type EmailLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginResponseValidationError) ErrorName() string {
	return "EmailLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EmailLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginResponseValidationError{}

// Validate checks the field values on RegisterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterResponseMultiError, or nil if none found.
func (m *RegisterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegisterResponseMultiError(errors)
	}

	return nil
}

// RegisterResponseMultiError is an error wrapping multiple validation errors
// returned by RegisterResponse.ValidateAll() if the designated constraints
// aren't met.
type RegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterResponseMultiError) AllErrors() []error { return m }

// RegisterResponseValidationError is the validation error returned by
// RegisterResponse.Validate if the designated constraints aren't met.
type RegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterResponseValidationError) ErrorName() string { return "RegisterResponseValidationError" }

// Error satisfies the builtin error interface
func (e RegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterResponseValidationError{}

// Validate checks the field values on LogoutRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutRequestMultiError, or
// nil if none found.
func (m *LogoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LogoutRequestMultiError(errors)
	}

	return nil
}

// LogoutRequestMultiError is an error wrapping multiple validation errors
// returned by LogoutRequest.ValidateAll() if the designated constraints
// aren't met.
type LogoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutRequestMultiError) AllErrors() []error { return m }

// LogoutRequestValidationError is the validation error returned by
// LogoutRequest.Validate if the designated constraints aren't met.
type LogoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutRequestValidationError) ErrorName() string { return "LogoutRequestValidationError" }

// Error satisfies the builtin error interface
func (e LogoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutRequestValidationError{}

// Validate checks the field values on LogoutResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutResponseMultiError,
// or nil if none found.
func (m *LogoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LogoutResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LogoutResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LogoutResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LogoutResponseMultiError(errors)
	}

	return nil
}

// LogoutResponseMultiError is an error wrapping multiple validation errors
// returned by LogoutResponse.ValidateAll() if the designated constraints
// aren't met.
type LogoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutResponseMultiError) AllErrors() []error { return m }

// LogoutResponseValidationError is the validation error returned by
// LogoutResponse.Validate if the designated constraints aren't met.
type LogoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutResponseValidationError) ErrorName() string { return "LogoutResponseValidationError" }

// Error satisfies the builtin error interface
func (e LogoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutResponseValidationError{}

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := LoginRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := LoginRequestValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on SmsLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SmsLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SmsLoginRequestMultiError, or nil if none found.
func (m *SmsLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := SmsLoginRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmsLoginRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmsLoginRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmsLoginRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := SmsLoginRequestValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SmsLoginRequestMultiError(errors)
	}

	return nil
}

// SmsLoginRequestMultiError is an error wrapping multiple validation errors
// returned by SmsLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type SmsLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginRequestMultiError) AllErrors() []error { return m }

// SmsLoginRequestValidationError is the validation error returned by
// SmsLoginRequest.Validate if the designated constraints aren't met.
type SmsLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginRequestValidationError) ErrorName() string { return "SmsLoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e SmsLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginRequestValidationError{}

// Validate checks the field values on EmailLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailLoginRequestMultiError, or nil if none found.
func (m *EmailLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := EmailLoginRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailLoginRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailLoginRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailLoginRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := EmailLoginRequestValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EmailLoginRequestMultiError(errors)
	}

	return nil
}

// EmailLoginRequestMultiError is an error wrapping multiple validation errors
// returned by EmailLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type EmailLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginRequestMultiError) AllErrors() []error { return m }

// EmailLoginRequestValidationError is the validation error returned by
// EmailLoginRequest.Validate if the designated constraints aren't met.
type EmailLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginRequestValidationError) ErrorName() string {
	return "EmailLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EmailLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginRequestValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := RegisterRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := RegisterRequestValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPosts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  fmt.Sprintf("Posts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  fmt.Sprintf("Posts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  fmt.Sprintf("Posts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NickName != nil {
		// no validation rules for NickName
	}

	if m.RealName != nil {
		// no validation rules for RealName
	}

	if m.Birthday != nil {
		// no validation rules for Birthday
	}

	if m.Gender != nil {
		// no validation rules for Gender
	}

	if m.Phone != nil {
		// no validation rules for Phone
	}

	if m.Email != nil {
		// no validation rules for Email
	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DeptId != nil {
		// no validation rules for DeptId
	}

	if m.Dept != nil {

		if all {
			switch v := interface{}(m.GetDept()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "Dept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "Dept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDept()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  "Dept",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on GetUserInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoRequestMultiError, or nil if none found.
func (m *GetUserInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUserInfoRequestMultiError(errors)
	}

	return nil
}

// GetUserInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoRequestMultiError) AllErrors() []error { return m }

// GetUserInfoRequestValidationError is the validation error returned by
// GetUserInfoRequest.Validate if the designated constraints aren't met.
type GetUserInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoRequestValidationError) ErrorName() string {
	return "GetUserInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoRequestValidationError{}

// Validate checks the field values on GetUserInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoResponseMultiError, or nil if none found.
func (m *GetUserInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserInfoResponseValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserInfoResponseValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserInfoResponseValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Name

	// no validation rules for NickName

	// no validation rules for RealName

	// no validation rules for Birthday

	// no validation rules for Gender

	// no validation rules for Phone

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for State

	if len(errors) > 0 {
		return GetUserInfoResponseMultiError(errors)
	}

	return nil
}

// GetUserInfoResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoResponseMultiError) AllErrors() []error { return m }

// GetUserInfoResponseValidationError is the validation error returned by
// GetUserInfoResponse.Validate if the designated constraints aren't met.
type GetUserInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoResponseValidationError) ErrorName() string {
	return "GetUserInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoResponseValidationError{}

// Validate checks the field values on GetUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileRequestMultiError, or nil if none found.
func (m *GetUserProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUserProfileRequestMultiError(errors)
	}

	return nil
}

// GetUserProfileRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileRequestMultiError) AllErrors() []error { return m }

// GetUserProfileRequestValidationError is the validation error returned by
// GetUserProfileRequest.Validate if the designated constraints aren't met.
type GetUserProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileRequestValidationError) ErrorName() string {
	return "GetUserProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileRequestValidationError{}

// Validate checks the field values on GetUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileResponseMultiError, or nil if none found.
func (m *GetUserProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserProfileResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserProfileResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserProfileResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserProfileResponseValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserProfileResponseValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserProfileResponseValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserProfileResponseMultiError(errors)
	}

	return nil
}

// GetUserProfileResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileResponseMultiError) AllErrors() []error { return m }

// GetUserProfileResponseValidationError is the validation error returned by
// GetUserProfileResponse.Validate if the designated constraints aren't met.
type GetUserProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileResponseValidationError) ErrorName() string {
	return "GetUserProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileResponseValidationError{}

// Validate checks the field values on ListUserRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleRequestMultiError, or nil if none found.
func (m *ListUserRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListUserRoleRequestMultiError(errors)
	}

	return nil
}

// ListUserRoleRequestMultiError is an error wrapping multiple validation
// errors returned by ListUserRoleRequest.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleRequestMultiError) AllErrors() []error { return m }

// ListUserRoleRequestValidationError is the validation error returned by
// ListUserRoleRequest.Validate if the designated constraints aren't met.
type ListUserRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleRequestValidationError) ErrorName() string {
	return "ListUserRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleRequestValidationError{}

// Validate checks the field values on ListUserRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleResponseMultiError, or nil if none found.
func (m *ListUserRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleResponseMultiError(errors)
	}

	return nil
}

// ListUserRoleResponseMultiError is an error wrapping multiple validation
// errors returned by ListUserRoleResponse.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleResponseMultiError) AllErrors() []error { return m }

// ListUserRoleResponseValidationError is the validation error returned by
// ListUserRoleResponse.Validate if the designated constraints aren't met.
type ListUserRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleResponseValidationError) ErrorName() string {
	return "ListUserRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleResponseValidationError{}

// Validate checks the field values on ListUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRequestMultiError, or nil if none found.
func (m *ListUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.DeptId != nil {
		// no validation rules for DeptId
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.NickName != nil {
		// no validation rules for NickName
	}

	if len(errors) > 0 {
		return ListUserRequestMultiError(errors)
	}

	return nil
}

// ListUserRequestMultiError is an error wrapping multiple validation errors
// returned by ListUserRequest.ValidateAll() if the designated constraints
// aren't met.
type ListUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRequestMultiError) AllErrors() []error { return m }

// ListUserRequestValidationError is the validation error returned by
// ListUserRequest.Validate if the designated constraints aren't met.
type ListUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRequestValidationError) ErrorName() string { return "ListUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRequestValidationError{}

// Validate checks the field values on ListUserResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserResponseMultiError, or nil if none found.
func (m *ListUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserResponseMultiError(errors)
	}

	return nil
}

// ListUserResponseMultiError is an error wrapping multiple validation errors
// returned by ListUserResponse.ValidateAll() if the designated constraints
// aren't met.
type ListUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserResponseMultiError) AllErrors() []error { return m }

// ListUserResponseValidationError is the validation error returned by
// ListUserResponse.Validate if the designated constraints aren't met.
type ListUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserResponseValidationError) ErrorName() string { return "ListUserResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserResponseValidationError{}

// Validate checks the field values on ListUserRoleMenuRouterTreeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListUserRoleMenuRouterTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuRouterTreeRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuRouterTreeRequestMultiError, or nil if none found.
func (m *ListUserRoleMenuRouterTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuRouterTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRoleMenuRouterTreeRequestValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.MenuParentId != nil {

		if m.GetMenuParentId() < 0 {
			err := ListUserRoleMenuRouterTreeRequestValidationError{
				field:  "MenuParentId",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuRouterTreeRequestMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuRouterTreeRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListUserRoleMenuRouterTreeRequest.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuRouterTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuRouterTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuRouterTreeRequestMultiError) AllErrors() []error { return m }

// ListUserRoleMenuRouterTreeRequestValidationError is the validation error
// returned by ListUserRoleMenuRouterTreeRequest.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuRouterTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuRouterTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuRouterTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuRouterTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuRouterTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuRouterTreeRequestValidationError) ErrorName() string {
	return "ListUserRoleMenuRouterTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuRouterTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuRouterTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuRouterTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuRouterTreeRequestValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeResponseDeprecated
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListUserRoleMenuTreeResponseDeprecated) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeResponseDeprecated with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListUserRoleMenuTreeResponseDeprecatedMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeResponseDeprecated) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeResponseDeprecated) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeResponseDeprecatedValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeResponseDeprecatedValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeResponseDeprecatedValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeResponseDeprecatedMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeResponseDeprecatedMultiError is an error wrapping
// multiple validation errors returned by
// ListUserRoleMenuTreeResponseDeprecated.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeResponseDeprecatedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeResponseDeprecatedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeResponseDeprecatedMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeResponseDeprecatedValidationError is the validation
// error returned by ListUserRoleMenuTreeResponseDeprecated.Validate if the
// designated constraints aren't met.
type ListUserRoleMenuTreeResponseDeprecatedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeResponseDeprecatedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeResponseDeprecatedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeResponseDeprecatedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeResponseDeprecatedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeResponseDeprecatedValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeResponseDeprecatedValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeResponseDeprecatedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeResponseDeprecated.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeResponseDeprecatedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeResponseDeprecatedValidationError{}

// Validate checks the field values on MenuRouter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuRouter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuRouter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuRouterMultiError, or
// nil if none found.
func (m *MenuRouter) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuRouter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuRouterValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuRouterValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuRouterValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuRouterValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuRouterValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuRouterValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Component != nil {
		// no validation rules for Component
	}

	if m.Redirect != nil {
		// no validation rules for Redirect
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if len(errors) > 0 {
		return MenuRouterMultiError(errors)
	}

	return nil
}

// MenuRouterMultiError is an error wrapping multiple validation errors
// returned by MenuRouter.ValidateAll() if the designated constraints aren't met.
type MenuRouterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuRouterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuRouterMultiError) AllErrors() []error { return m }

// MenuRouterValidationError is the validation error returned by
// MenuRouter.Validate if the designated constraints aren't met.
type MenuRouterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuRouterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuRouterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuRouterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuRouterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuRouterValidationError) ErrorName() string { return "MenuRouterValidationError" }

// Error satisfies the builtin error interface
func (e MenuRouterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuRouter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuRouterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuRouterValidationError{}

// Validate checks the field values on ListUserRoleMenuRouterTreeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListUserRoleMenuRouterTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuRouterTreeResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuRouterTreeResponseMultiError, or nil if none found.
func (m *ListUserRoleMenuRouterTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuRouterTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuRouterTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuRouterTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuRouterTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleMenuRouterTreeResponseMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuRouterTreeResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListUserRoleMenuRouterTreeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuRouterTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuRouterTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuRouterTreeResponseMultiError) AllErrors() []error { return m }

// ListUserRoleMenuRouterTreeResponseValidationError is the validation error
// returned by ListUserRoleMenuRouterTreeResponse.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuRouterTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuRouterTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuRouterTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuRouterTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuRouterTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuRouterTreeResponseValidationError) ErrorName() string {
	return "ListUserRoleMenuRouterTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuRouterTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuRouterTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuRouterTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuRouterTreeResponseValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeRequestMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRoleMenuTreeRequestValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.MenuParentId != nil {

		if m.GetMenuParentId() < 0 {
			err := ListUserRoleMenuTreeRequestValidationError{
				field:  "MenuParentId",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeRequestMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeRequestMultiError is an error wrapping multiple
// validation errors returned by ListUserRoleMenuTreeRequest.ValidateAll() if
// the designated constraints aren't met.
type ListUserRoleMenuTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeRequestMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeRequestValidationError is the validation error returned
// by ListUserRoleMenuTreeRequest.Validate if the designated constraints
// aren't met.
type ListUserRoleMenuTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeRequestValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeRequestValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeResponseMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeResponseMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeResponseMultiError is an error wrapping multiple
// validation errors returned by ListUserRoleMenuTreeResponse.ValidateAll() if
// the designated constraints aren't met.
type ListUserRoleMenuTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeResponseMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeResponseValidationError is the validation error returned
// by ListUserRoleMenuTreeResponse.Validate if the designated constraints
// aren't met.
type ListUserRoleMenuTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeResponseValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeResponseValidationError{}

// Validate checks the field values on ListUserRolePermissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRolePermissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRolePermissionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListUserRolePermissionRequestMultiError, or nil if none found.
func (m *ListUserRolePermissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRolePermissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRolePermissionRequestValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUserRolePermissionRequestMultiError(errors)
	}

	return nil
}

// ListUserRolePermissionRequestMultiError is an error wrapping multiple
// validation errors returned by ListUserRolePermissionRequest.ValidateAll()
// if the designated constraints aren't met.
type ListUserRolePermissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRolePermissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRolePermissionRequestMultiError) AllErrors() []error { return m }

// ListUserRolePermissionRequestValidationError is the validation error
// returned by ListUserRolePermissionRequest.Validate if the designated
// constraints aren't met.
type ListUserRolePermissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRolePermissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRolePermissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRolePermissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRolePermissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRolePermissionRequestValidationError) ErrorName() string {
	return "ListUserRolePermissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRolePermissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRolePermissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRolePermissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRolePermissionRequestValidationError{}

// Validate checks the field values on ListUserRolePermissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRolePermissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRolePermissionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListUserRolePermissionResponseMultiError, or nil if none found.
func (m *ListUserRolePermissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRolePermissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRolePermissionResponseMultiError(errors)
	}

	return nil
}

// ListUserRolePermissionResponseMultiError is an error wrapping multiple
// validation errors returned by ListUserRolePermissionResponse.ValidateAll()
// if the designated constraints aren't met.
type ListUserRolePermissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRolePermissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRolePermissionResponseMultiError) AllErrors() []error { return m }

// ListUserRolePermissionResponseValidationError is the validation error
// returned by ListUserRolePermissionResponse.Validate if the designated
// constraints aren't met.
type ListUserRolePermissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRolePermissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRolePermissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRolePermissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRolePermissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRolePermissionResponseValidationError) ErrorName() string {
	return "ListUserRolePermissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRolePermissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRolePermissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRolePermissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRolePermissionResponseValidationError{}

// Validate checks the field values on CreateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserRequestMultiError, or nil if none found.
func (m *CreateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateUserRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateUserRequest_Phone_Pattern.MatchString(m.GetPhone()) {
		err := CreateUserRequestValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateUserRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDeptId() <= 0 {
		err := CreateUserRequestValidationError{
			field:  "DeptId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateUserRequest_PostIds_Unique := make(map[uint64]struct{}, len(m.GetPostIds()))

	for idx, item := range m.GetPostIds() {
		_, _ = idx, item

		if _, exists := _CreateUserRequest_PostIds_Unique[item]; exists {
			err := CreateUserRequestValidationError{
				field:  fmt.Sprintf("PostIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateUserRequest_PostIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateUserRequestValidationError{
				field:  fmt.Sprintf("PostIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetRoleIds()) < 1 {
		err := CreateUserRequestValidationError{
			field:  "RoleIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateUserRequest_RoleIds_Unique := make(map[uint64]struct{}, len(m.GetRoleIds()))

	for idx, item := range m.GetRoleIds() {
		_, _ = idx, item

		if _, exists := _CreateUserRequest_RoleIds_Unique[item]; exists {
			err := CreateUserRequestValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateUserRequest_RoleIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateUserRequestValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if m.Password != nil {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
			err := CreateUserRequestValidationError{
				field:  "Password",
				reason: "value length must be between 6 and 28 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NickName != nil {

		if l := utf8.RuneCountInString(m.GetNickName()); l < 1 || l > 10 {
			err := CreateUserRequestValidationError{
				field:  "NickName",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RealName != nil {

		if l := utf8.RuneCountInString(m.GetRealName()); l < 2 || l > 10 {
			err := CreateUserRequestValidationError{
				field:  "RealName",
				reason: "value length must be between 2 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Birthday != nil {

		if !_CreateUserRequest_Birthday_Pattern.MatchString(m.GetBirthday()) {
			err := CreateUserRequestValidationError{
				field:  "Birthday",
				reason: "value does not match regex pattern \"^(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Gender != nil {

		if m.GetGender() < 0 {
			err := CreateUserRequestValidationError{
				field:  "Gender",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = CreateUserRequestValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return CreateUserRequestMultiError(errors)
	}

	return nil
}

func (m *CreateUserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserRequestMultiError is an error wrapping multiple validation errors
// returned by CreateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserRequestMultiError) AllErrors() []error { return m }

// CreateUserRequestValidationError is the validation error returned by
// CreateUserRequest.Validate if the designated constraints aren't met.
type CreateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRequestValidationError) ErrorName() string {
	return "CreateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRequestValidationError{}

var _CreateUserRequest_Birthday_Pattern = regexp.MustCompile("^(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)$")

var _CreateUserRequest_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

// Validate checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserResponseMultiError, or nil if none found.
func (m *CreateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateUserResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateUserResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateUserResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateUserResponseMultiError(errors)
	}

	return nil
}

// CreateUserResponseMultiError is an error wrapping multiple validation errors
// returned by CreateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserResponseMultiError) AllErrors() []error { return m }

// CreateUserResponseValidationError is the validation error returned by
// CreateUserResponse.Validate if the designated constraints aren't met.
type CreateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserResponseValidationError) ErrorName() string {
	return "CreateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserResponseValidationError{}

// Validate checks the field values on HandleUserRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserRoleRequestMultiError, or nil if none found.
func (m *HandleUserRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleUserRoleRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleUserRoleRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleUserRoleRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleUserRoleRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleUserRoleRequestMultiError(errors)
	}

	return nil
}

// HandleUserRoleRequestMultiError is an error wrapping multiple validation
// errors returned by HandleUserRoleRequest.ValidateAll() if the designated
// constraints aren't met.
type HandleUserRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserRoleRequestMultiError) AllErrors() []error { return m }

// HandleUserRoleRequestValidationError is the validation error returned by
// HandleUserRoleRequest.Validate if the designated constraints aren't met.
type HandleUserRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserRoleRequestValidationError) ErrorName() string {
	return "HandleUserRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserRoleRequestValidationError{}

// Validate checks the field values on HandleUserRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserRoleResponseMultiError, or nil if none found.
func (m *HandleUserRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleUserRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleUserRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleUserRoleResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleUserRoleResponseMultiError(errors)
	}

	return nil
}

// HandleUserRoleResponseMultiError is an error wrapping multiple validation
// errors returned by HandleUserRoleResponse.ValidateAll() if the designated
// constraints aren't met.
type HandleUserRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserRoleResponseMultiError) AllErrors() []error { return m }

// HandleUserRoleResponseValidationError is the validation error returned by
// HandleUserRoleResponse.Validate if the designated constraints aren't met.
type HandleUserRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserRoleResponseValidationError) ErrorName() string {
	return "HandleUserRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserRoleResponseValidationError{}

// Validate checks the field values on GetUserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserRequestMultiError,
// or nil if none found.
func (m *GetUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetUserRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserRequestMultiError(errors)
	}

	return nil
}

// GetUserRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserRequestMultiError) AllErrors() []error { return m }

// GetUserRequestValidationError is the validation error returned by
// GetUserRequest.Validate if the designated constraints aren't met.
type GetUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserRequestValidationError) ErrorName() string { return "GetUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserRequestValidationError{}

// Validate checks the field values on DeleteUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserRequestMultiError, or nil if none found.
func (m *DeleteUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteUserRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteUserRequestMultiError(errors)
	}

	return nil
}

// DeleteUserRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteUserRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserRequestMultiError) AllErrors() []error { return m }

// DeleteUserRequestValidationError is the validation error returned by
// DeleteUserRequest.Validate if the designated constraints aren't met.
type DeleteUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserRequestValidationError) ErrorName() string {
	return "DeleteUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserRequestValidationError{}

// Validate checks the field values on DeleteUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserResponseMultiError, or nil if none found.
func (m *DeleteUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteUserResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteUserResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteUserResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteUserResponseMultiError(errors)
	}

	return nil
}

// DeleteUserResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteUserResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserResponseMultiError) AllErrors() []error { return m }

// DeleteUserResponseValidationError is the validation error returned by
// DeleteUserResponse.Validate if the designated constraints aren't met.
type DeleteUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserResponseValidationError) ErrorName() string {
	return "DeleteUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserResponseValidationError{}

// Validate checks the field values on UpdateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequestMultiError, or nil if none found.
func (m *UpdateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateUserRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserRequestMultiError(errors)
	}

	return nil
}

// UpdateUserRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequestMultiError) AllErrors() []error { return m }

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.Validate if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

// Validate checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserResponseMultiError, or nil if none found.
func (m *UpdateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateUserResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateUserResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateUserResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateUserResponseMultiError(errors)
	}

	return nil
}

// UpdateUserResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserResponseMultiError) AllErrors() []error { return m }

// UpdateUserResponseValidationError is the validation error returned by
// UpdateUserResponse.Validate if the designated constraints aren't met.
type UpdateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserResponseValidationError) ErrorName() string {
	return "UpdateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserResponseValidationError{}

// Validate checks the field values on UserMenuTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserMenuTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMenuTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserMenuTreeResponseMultiError, or nil if none found.
func (m *UserMenuTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMenuTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserMenuTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserMenuTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserMenuTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return UserMenuTreeResponseMultiError(errors)
	}

	return nil
}

// UserMenuTreeResponseMultiError is an error wrapping multiple validation
// errors returned by UserMenuTreeResponse.ValidateAll() if the designated
// constraints aren't met.
type UserMenuTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMenuTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMenuTreeResponseMultiError) AllErrors() []error { return m }

// UserMenuTreeResponseValidationError is the validation error returned by
// UserMenuTreeResponse.Validate if the designated constraints aren't met.
type UserMenuTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMenuTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMenuTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMenuTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMenuTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMenuTreeResponseValidationError) ErrorName() string {
	return "UserMenuTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserMenuTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMenuTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMenuTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMenuTreeResponseValidationError{}

// Validate checks the field values on ExistUserNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExistUserNameRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistUserNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistUserNameRequestMultiError, or nil if none found.
func (m *ExistUserNameRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistUserNameRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ExistUserNameRequestMultiError(errors)
	}

	return nil
}

// ExistUserNameRequestMultiError is an error wrapping multiple validation
// errors returned by ExistUserNameRequest.ValidateAll() if the designated
// constraints aren't met.
type ExistUserNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistUserNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistUserNameRequestMultiError) AllErrors() []error { return m }

// ExistUserNameRequestValidationError is the validation error returned by
// ExistUserNameRequest.Validate if the designated constraints aren't met.
type ExistUserNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistUserNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistUserNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistUserNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistUserNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistUserNameRequestValidationError) ErrorName() string {
	return "ExistUserNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExistUserNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistUserNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistUserNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistUserNameRequestValidationError{}

// Validate checks the field values on ExistUserNameResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExistUserNameResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistUserNameResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistUserNameResponseMultiError, or nil if none found.
func (m *ExistUserNameResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistUserNameResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExistUserNameResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExistUserNameResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExistUserNameResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExistUserNameResponseMultiError(errors)
	}

	return nil
}

// ExistUserNameResponseMultiError is an error wrapping multiple validation
// errors returned by ExistUserNameResponse.ValidateAll() if the designated
// constraints aren't met.
type ExistUserNameResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistUserNameResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistUserNameResponseMultiError) AllErrors() []error { return m }

// ExistUserNameResponseValidationError is the validation error returned by
// ExistUserNameResponse.Validate if the designated constraints aren't met.
type ExistUserNameResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistUserNameResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistUserNameResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistUserNameResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistUserNameResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistUserNameResponseValidationError) ErrorName() string {
	return "ExistUserNameResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExistUserNameResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistUserNameResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistUserNameResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistUserNameResponseValidationError{}

// Validate checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Domain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DomainMultiError, or nil if none found.
func (m *Domain) ValidateAll() error {
	return m.validate(true)
}

func (m *Domain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Alias != nil {
		// no validation rules for Alias
	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return DomainMultiError(errors)
	}

	return nil
}

// DomainMultiError is an error wrapping multiple validation errors returned by
// Domain.ValidateAll() if the designated constraints aren't met.
type DomainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DomainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DomainMultiError) AllErrors() []error { return m }

// DomainValidationError is the validation error returned by Domain.Validate if
// the designated constraints aren't met.
type DomainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DomainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DomainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DomainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DomainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DomainValidationError) ErrorName() string { return "DomainValidationError" }

// Error satisfies the builtin error interface
func (e DomainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDomain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DomainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DomainValidationError{}

// Validate checks the field values on ListDomainRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainRequestMultiError, or nil if none found.
func (m *ListDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListDomainRequestMultiError(errors)
	}

	return nil
}

// ListDomainRequestMultiError is an error wrapping multiple validation errors
// returned by ListDomainRequest.ValidateAll() if the designated constraints
// aren't met.
type ListDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainRequestMultiError) AllErrors() []error { return m }

// ListDomainRequestValidationError is the validation error returned by
// ListDomainRequest.Validate if the designated constraints aren't met.
type ListDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainRequestValidationError) ErrorName() string {
	return "ListDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainRequestValidationError{}

// Validate checks the field values on ListDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainResponseMultiError, or nil if none found.
func (m *ListDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDomainResponseMultiError(errors)
	}

	return nil
}

// ListDomainResponseMultiError is an error wrapping multiple validation errors
// returned by ListDomainResponse.ValidateAll() if the designated constraints
// aren't met.
type ListDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainResponseMultiError) AllErrors() []error { return m }

// ListDomainResponseValidationError is the validation error returned by
// ListDomainResponse.Validate if the designated constraints aren't met.
type ListDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainResponseValidationError) ErrorName() string {
	return "ListDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainResponseValidationError{}

// Validate checks the field values on ListDomainTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainTreeRequestMultiError, or nil if none found.
func (m *ListDomainTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListDomainTreeRequestMultiError(errors)
	}

	return nil
}

// ListDomainTreeRequestMultiError is an error wrapping multiple validation
// errors returned by ListDomainTreeRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDomainTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainTreeRequestMultiError) AllErrors() []error { return m }

// ListDomainTreeRequestValidationError is the validation error returned by
// ListDomainTreeRequest.Validate if the designated constraints aren't met.
type ListDomainTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainTreeRequestValidationError) ErrorName() string {
	return "ListDomainTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainTreeRequestValidationError{}

// Validate checks the field values on ListDomainTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainTreeResponseMultiError, or nil if none found.
func (m *ListDomainTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDomainTreeResponseMultiError(errors)
	}

	return nil
}

// ListDomainTreeResponseMultiError is an error wrapping multiple validation
// errors returned by ListDomainTreeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDomainTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainTreeResponseMultiError) AllErrors() []error { return m }

// ListDomainTreeResponseValidationError is the validation error returned by
// ListDomainTreeResponse.Validate if the designated constraints aren't met.
type ListDomainTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainTreeResponseValidationError) ErrorName() string {
	return "ListDomainTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainTreeResponseValidationError{}

// Validate checks the field values on CreateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainRequestMultiError, or nil if none found.
func (m *CreateDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDomainRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Alias != nil {

		if l := utf8.RuneCountInString(m.GetAlias()); l < 1 || l > 100 {
			err := CreateDomainRequestValidationError{
				field:  "Alias",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {

		if m.GetState() < 0 {
			err := CreateDomainRequestValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return CreateDomainRequestMultiError(errors)
	}

	return nil
}

// CreateDomainRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDomainRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainRequestMultiError) AllErrors() []error { return m }

// CreateDomainRequestValidationError is the validation error returned by
// CreateDomainRequest.Validate if the designated constraints aren't met.
type CreateDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainRequestValidationError) ErrorName() string {
	return "CreateDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainRequestValidationError{}

// Validate checks the field values on CreateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainResponseMultiError, or nil if none found.
func (m *CreateDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDomainResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDomainResponseMultiError(errors)
	}

	return nil
}

// CreateDomainResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDomainResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainResponseMultiError) AllErrors() []error { return m }

// CreateDomainResponseValidationError is the validation error returned by
// CreateDomainResponse.Validate if the designated constraints aren't met.
type CreateDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainResponseValidationError) ErrorName() string {
	return "CreateDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainResponseValidationError{}

// Validate checks the field values on UpdateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainRequestMultiError, or nil if none found.
func (m *UpdateDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainRequestMultiError) AllErrors() []error { return m }

// UpdateDomainRequestValidationError is the validation error returned by
// UpdateDomainRequest.Validate if the designated constraints aren't met.
type UpdateDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainRequestValidationError) ErrorName() string {
	return "UpdateDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainRequestValidationError{}

// Validate checks the field values on UpdateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainResponseMultiError, or nil if none found.
func (m *UpdateDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainResponseMultiError) AllErrors() []error { return m }

// UpdateDomainResponseValidationError is the validation error returned by
// UpdateDomainResponse.Validate if the designated constraints aren't met.
type UpdateDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainResponseValidationError) ErrorName() string {
	return "UpdateDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainResponseValidationError{}

// Validate checks the field values on UpdateDomainStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateRequestMultiError, or nil if none found.
func (m *UpdateDomainStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateRequestMultiError) AllErrors() []error { return m }

// UpdateDomainStateRequestValidationError is the validation error returned by
// UpdateDomainStateRequest.Validate if the designated constraints aren't met.
type UpdateDomainStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateRequestValidationError) ErrorName() string {
	return "UpdateDomainStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateRequestValidationError{}

// Validate checks the field values on UpdateDomainStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateResponseMultiError, or nil if none found.
func (m *UpdateDomainStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateDomainStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateResponseMultiError) AllErrors() []error { return m }

// UpdateDomainStateResponseValidationError is the validation error returned by
// UpdateDomainStateResponse.Validate if the designated constraints aren't met.
type UpdateDomainStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateResponseValidationError) ErrorName() string {
	return "UpdateDomainStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateResponseValidationError{}

// Validate checks the field values on GetDomainRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainRequestMultiError, or nil if none found.
func (m *GetDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDomainRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainRequestMultiError(errors)
	}

	return nil
}

// GetDomainRequestMultiError is an error wrapping multiple validation errors
// returned by GetDomainRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainRequestMultiError) AllErrors() []error { return m }

// GetDomainRequestValidationError is the validation error returned by
// GetDomainRequest.Validate if the designated constraints aren't met.
type GetDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainRequestValidationError) ErrorName() string { return "GetDomainRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainRequestValidationError{}

// Validate checks the field values on GetDomainCodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDomainCodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainCodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainCodeRequestMultiError, or nil if none found.
func (m *GetDomainCodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainCodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCode()) != 19 {
		err := GetDomainCodeRequestValidationError{
			field:  "Code",
			reason: "value length must be 19 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return GetDomainCodeRequestMultiError(errors)
	}

	return nil
}

// GetDomainCodeRequestMultiError is an error wrapping multiple validation
// errors returned by GetDomainCodeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDomainCodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainCodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainCodeRequestMultiError) AllErrors() []error { return m }

// GetDomainCodeRequestValidationError is the validation error returned by
// GetDomainCodeRequest.Validate if the designated constraints aren't met.
type GetDomainCodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainCodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainCodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainCodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainCodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainCodeRequestValidationError) ErrorName() string {
	return "GetDomainCodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDomainCodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainCodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainCodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainCodeRequestValidationError{}

// Validate checks the field values on GetDomainNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDomainNameRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainNameRequestMultiError, or nil if none found.
func (m *GetDomainNameRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainNameRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 20 {
		err := GetDomainNameRequestValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainNameRequestMultiError(errors)
	}

	return nil
}

// GetDomainNameRequestMultiError is an error wrapping multiple validation
// errors returned by GetDomainNameRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDomainNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainNameRequestMultiError) AllErrors() []error { return m }

// GetDomainNameRequestValidationError is the validation error returned by
// GetDomainNameRequest.Validate if the designated constraints aren't met.
type GetDomainNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainNameRequestValidationError) ErrorName() string {
	return "GetDomainNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDomainNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainNameRequestValidationError{}

// Validate checks the field values on DeleteDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainRequestMultiError, or nil if none found.
func (m *DeleteDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDomainRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDomainRequestMultiError(errors)
	}

	return nil
}

// DeleteDomainRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDomainRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainRequestMultiError) AllErrors() []error { return m }

// DeleteDomainRequestValidationError is the validation error returned by
// DeleteDomainRequest.Validate if the designated constraints aren't met.
type DeleteDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainRequestValidationError) ErrorName() string {
	return "DeleteDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainRequestValidationError{}

// Validate checks the field values on DeleteDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainResponseMultiError, or nil if none found.
func (m *DeleteDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDomainResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDomainResponseMultiError(errors)
	}

	return nil
}

// DeleteDomainResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteDomainResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainResponseMultiError) AllErrors() []error { return m }

// DeleteDomainResponseValidationError is the validation error returned by
// DeleteDomainResponse.Validate if the designated constraints aren't met.
type DeleteDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainResponseValidationError) ErrorName() string {
	return "DeleteDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainResponseValidationError{}

// Validate checks the field values on ListDomainMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuRequestMultiError, or nil if none found.
func (m *ListDomainMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListDomainMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListDomainMenuRequestMultiError(errors)
	}

	return nil
}

// ListDomainMenuRequestMultiError is an error wrapping multiple validation
// errors returned by ListDomainMenuRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDomainMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuRequestMultiError) AllErrors() []error { return m }

// ListDomainMenuRequestValidationError is the validation error returned by
// ListDomainMenuRequest.Validate if the designated constraints aren't met.
type ListDomainMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuRequestValidationError) ErrorName() string {
	return "ListDomainMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuRequestValidationError{}

// Validate checks the field values on ListDomainMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuResponseMultiError, or nil if none found.
func (m *ListDomainMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainMenuResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDomainMenuResponseMultiError(errors)
	}

	return nil
}

// ListDomainMenuResponseMultiError is an error wrapping multiple validation
// errors returned by ListDomainMenuResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDomainMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuResponseMultiError) AllErrors() []error { return m }

// ListDomainMenuResponseValidationError is the validation error returned by
// ListDomainMenuResponse.Validate if the designated constraints aren't met.
type ListDomainMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuResponseValidationError) ErrorName() string {
	return "ListDomainMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuResponseValidationError{}

// Validate checks the field values on HandleDomainMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuRequestMultiError, or nil if none found.
func (m *HandleDomainMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleDomainMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleDomainMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleDomainMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleDomainMenuRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleDomainMenuRequestMultiError(errors)
	}

	return nil
}

// HandleDomainMenuRequestMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuRequest.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuRequestMultiError) AllErrors() []error { return m }

// HandleDomainMenuRequestValidationError is the validation error returned by
// HandleDomainMenuRequest.Validate if the designated constraints aren't met.
type HandleDomainMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuRequestValidationError) ErrorName() string {
	return "HandleDomainMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuRequestValidationError{}

// Validate checks the field values on HandleDomainMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuResponseMultiError, or nil if none found.
func (m *HandleDomainMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleDomainMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleDomainMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleDomainMenuResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuResponseMultiError(errors)
	}

	return nil
}

// HandleDomainMenuResponseMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuResponse.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuResponseMultiError) AllErrors() []error { return m }

// HandleDomainMenuResponseValidationError is the validation error returned by
// HandleDomainMenuResponse.Validate if the designated constraints aren't met.
type HandleDomainMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuResponseValidationError) ErrorName() string {
	return "HandleDomainMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuResponseValidationError{}

// Validate checks the field values on Role with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Role) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Role with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleMultiError, or nil if none found.
func (m *Role) ValidateAll() error {
	return m.validate(true)
}

func (m *Role) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DefaultRouter != nil {
		// no validation rules for DefaultRouter
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.DataScope != nil {
		// no validation rules for DataScope
	}

	if m.MenuCheckStrictly != nil {
		// no validation rules for MenuCheckStrictly
	}

	if m.DeptCheckStrictly != nil {
		// no validation rules for DeptCheckStrictly
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return RoleMultiError(errors)
	}

	return nil
}

// RoleMultiError is an error wrapping multiple validation errors returned by
// Role.ValidateAll() if the designated constraints aren't met.
type RoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMultiError) AllErrors() []error { return m }

// RoleValidationError is the validation error returned by Role.Validate if the
// designated constraints aren't met.
type RoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleValidationError) ErrorName() string { return "RoleValidationError" }

// Error satisfies the builtin error interface
func (e RoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleValidationError{}

// Validate checks the field values on ListRoleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleRequestMultiError, or nil if none found.
func (m *ListRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListRoleRequestMultiError(errors)
	}

	return nil
}

// ListRoleRequestMultiError is an error wrapping multiple validation errors
// returned by ListRoleRequest.ValidateAll() if the designated constraints
// aren't met.
type ListRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleRequestMultiError) AllErrors() []error { return m }

// ListRoleRequestValidationError is the validation error returned by
// ListRoleRequest.Validate if the designated constraints aren't met.
type ListRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleRequestValidationError) ErrorName() string { return "ListRoleRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleRequestValidationError{}

// Validate checks the field values on ListRoleResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleResponseMultiError, or nil if none found.
func (m *ListRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRoleResponseMultiError(errors)
	}

	return nil
}

// ListRoleResponseMultiError is an error wrapping multiple validation errors
// returned by ListRoleResponse.ValidateAll() if the designated constraints
// aren't met.
type ListRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleResponseMultiError) AllErrors() []error { return m }

// ListRoleResponseValidationError is the validation error returned by
// ListRoleResponse.Validate if the designated constraints aren't met.
type ListRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleResponseValidationError) ErrorName() string { return "ListRoleResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleResponseValidationError{}

// Validate checks the field values on CreateRoleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRoleRequestMultiError, or nil if none found.
func (m *CreateRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateRoleRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateRoleRequestValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateRoleRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateRoleRequest_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _CreateRoleRequest_MenuIds_Unique[item]; exists {
			err := CreateRoleRequestValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateRoleRequest_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateRoleRequestValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DefaultRouter != nil {

		if l := utf8.RuneCountInString(m.GetDefaultRouter()); l < 1 || l > 100 {
			err := CreateRoleRequestValidationError{
				field:  "DefaultRouter",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := CreateRoleRequestValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DataScope != nil {

		if m.GetDataScope() < 0 {
			err := CreateRoleRequestValidationError{
				field:  "DataScope",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MenuCheckStrictly != nil {

		if m.GetMenuCheckStrictly() < 0 {
			err := CreateRoleRequestValidationError{
				field:  "MenuCheckStrictly",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DeptCheckStrictly != nil {

		if m.GetDeptCheckStrictly() < 0 {
			err := CreateRoleRequestValidationError{
				field:  "DeptCheckStrictly",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := CreateRoleRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateRoleRequestMultiError(errors)
	}

	return nil
}

// CreateRoleRequestMultiError is an error wrapping multiple validation errors
// returned by CreateRoleRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleRequestMultiError) AllErrors() []error { return m }

// CreateRoleRequestValidationError is the validation error returned by
// CreateRoleRequest.Validate if the designated constraints aren't met.
type CreateRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleRequestValidationError) ErrorName() string {
	return "CreateRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleRequestValidationError{}

// Validate checks the field values on CreateRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRoleResponseMultiError, or nil if none found.
func (m *CreateRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateRoleResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateRoleResponseMultiError(errors)
	}

	return nil
}

// CreateRoleResponseMultiError is an error wrapping multiple validation errors
// returned by CreateRoleResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleResponseMultiError) AllErrors() []error { return m }

// CreateRoleResponseValidationError is the validation error returned by
// CreateRoleResponse.Validate if the designated constraints aren't met.
type CreateRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleResponseValidationError) ErrorName() string {
	return "CreateRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleResponseValidationError{}

// Validate checks the field values on UpdateRoleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleRequestMultiError, or nil if none found.
func (m *UpdateRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleRequestMultiError(errors)
	}

	return nil
}

// UpdateRoleRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleRequestMultiError) AllErrors() []error { return m }

// UpdateRoleRequestValidationError is the validation error returned by
// UpdateRoleRequest.Validate if the designated constraints aren't met.
type UpdateRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleRequestValidationError) ErrorName() string {
	return "UpdateRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleRequestValidationError{}

// Validate checks the field values on UpdateRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleResponseMultiError, or nil if none found.
func (m *UpdateRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateRoleResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateRoleResponseMultiError(errors)
	}

	return nil
}

// UpdateRoleResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleResponseMultiError) AllErrors() []error { return m }

// UpdateRoleResponseValidationError is the validation error returned by
// UpdateRoleResponse.Validate if the designated constraints aren't met.
type UpdateRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleResponseValidationError) ErrorName() string {
	return "UpdateRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleResponseValidationError{}

// Validate checks the field values on UpdateRoleStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateRequestMultiError, or nil if none found.
func (m *UpdateRoleStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleStateRequestMultiError(errors)
	}

	return nil
}

// UpdateRoleStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateRequestMultiError) AllErrors() []error { return m }

// UpdateRoleStateRequestValidationError is the validation error returned by
// UpdateRoleStateRequest.Validate if the designated constraints aren't met.
type UpdateRoleStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateRequestValidationError) ErrorName() string {
	return "UpdateRoleStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateRequestValidationError{}

// Validate checks the field values on UpdateRoleStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateResponseMultiError, or nil if none found.
func (m *UpdateRoleStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateRoleStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateRoleStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateRoleStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateRoleStateResponseMultiError(errors)
	}

	return nil
}

// UpdateRoleStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateResponseMultiError) AllErrors() []error { return m }

// UpdateRoleStateResponseValidationError is the validation error returned by
// UpdateRoleStateResponse.Validate if the designated constraints aren't met.
type UpdateRoleStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateResponseValidationError) ErrorName() string {
	return "UpdateRoleStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateResponseValidationError{}

// Validate checks the field values on GetRoleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRoleRequestMultiError,
// or nil if none found.
func (m *GetRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetRoleRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRoleRequestMultiError(errors)
	}

	return nil
}

// GetRoleRequestMultiError is an error wrapping multiple validation errors
// returned by GetRoleRequest.ValidateAll() if the designated constraints
// aren't met.
type GetRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleRequestMultiError) AllErrors() []error { return m }

// GetRoleRequestValidationError is the validation error returned by
// GetRoleRequest.Validate if the designated constraints aren't met.
type GetRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleRequestValidationError) ErrorName() string { return "GetRoleRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleRequestValidationError{}

// Validate checks the field values on DeleteRoleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRoleRequestMultiError, or nil if none found.
func (m *DeleteRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteRoleRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRoleRequestMultiError(errors)
	}

	return nil
}

// DeleteRoleRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteRoleRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleRequestMultiError) AllErrors() []error { return m }

// DeleteRoleRequestValidationError is the validation error returned by
// DeleteRoleRequest.Validate if the designated constraints aren't met.
type DeleteRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleRequestValidationError) ErrorName() string {
	return "DeleteRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleRequestValidationError{}

// Validate checks the field values on DeleteRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRoleResponseMultiError, or nil if none found.
func (m *DeleteRoleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteRoleResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteRoleResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteRoleResponseMultiError(errors)
	}

	return nil
}

// DeleteRoleResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteRoleResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteRoleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleResponseMultiError) AllErrors() []error { return m }

// DeleteRoleResponseValidationError is the validation error returned by
// DeleteRoleResponse.Validate if the designated constraints aren't met.
type DeleteRoleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleResponseValidationError) ErrorName() string {
	return "DeleteRoleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRoleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleResponseValidationError{}

// Validate checks the field values on ListRoleMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRoleMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleMenuRequestMultiError, or nil if none found.
func (m *ListRoleMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListRoleMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRoleMenuRequestMultiError(errors)
	}

	return nil
}

// ListRoleMenuRequestMultiError is an error wrapping multiple validation
// errors returned by ListRoleMenuRequest.ValidateAll() if the designated
// constraints aren't met.
type ListRoleMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleMenuRequestMultiError) AllErrors() []error { return m }

// ListRoleMenuRequestValidationError is the validation error returned by
// ListRoleMenuRequest.Validate if the designated constraints aren't met.
type ListRoleMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleMenuRequestValidationError) ErrorName() string {
	return "ListRoleMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoleMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleMenuRequestValidationError{}

// Validate checks the field values on ListRoleMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRoleMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleMenuResponseMultiError, or nil if none found.
func (m *ListRoleMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleMenuResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListRoleMenuResponseMultiError(errors)
	}

	return nil
}

// ListRoleMenuResponseMultiError is an error wrapping multiple validation
// errors returned by ListRoleMenuResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRoleMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleMenuResponseMultiError) AllErrors() []error { return m }

// ListRoleMenuResponseValidationError is the validation error returned by
// ListRoleMenuResponse.Validate if the designated constraints aren't met.
type ListRoleMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleMenuResponseValidationError) ErrorName() string {
	return "ListRoleMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoleMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleMenuResponseValidationError{}

// Validate checks the field values on HandleRoleMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuRequestMultiError, or nil if none found.
func (m *HandleRoleMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleMenuRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleMenuRequestMultiError(errors)
	}

	return nil
}

// HandleRoleMenuRequestMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuRequest.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuRequestMultiError) AllErrors() []error { return m }

// HandleRoleMenuRequestValidationError is the validation error returned by
// HandleRoleMenuRequest.Validate if the designated constraints aren't met.
type HandleRoleMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuRequestValidationError) ErrorName() string {
	return "HandleRoleMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuRequestValidationError{}

// Validate checks the field values on HandleRoleMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuResponseMultiError, or nil if none found.
func (m *HandleRoleMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleRoleMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleRoleMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleRoleMenuResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleRoleMenuResponseMultiError(errors)
	}

	return nil
}

// HandleRoleMenuResponseMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuResponse.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuResponseMultiError) AllErrors() []error { return m }

// HandleRoleMenuResponseValidationError is the validation error returned by
// HandleRoleMenuResponse.Validate if the designated constraints aren't met.
type HandleRoleMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuResponseValidationError) ErrorName() string {
	return "HandleRoleMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuResponseValidationError{}

// Validate checks the field values on ListRoleDeptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRoleDeptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleDeptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleDeptRequestMultiError, or nil if none found.
func (m *ListRoleDeptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleDeptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListRoleDeptRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRoleDeptRequestMultiError(errors)
	}

	return nil
}

// ListRoleDeptRequestMultiError is an error wrapping multiple validation
// errors returned by ListRoleDeptRequest.ValidateAll() if the designated
// constraints aren't met.
type ListRoleDeptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleDeptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleDeptRequestMultiError) AllErrors() []error { return m }

// ListRoleDeptRequestValidationError is the validation error returned by
// ListRoleDeptRequest.Validate if the designated constraints aren't met.
type ListRoleDeptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleDeptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleDeptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleDeptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleDeptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleDeptRequestValidationError) ErrorName() string {
	return "ListRoleDeptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoleDeptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleDeptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleDeptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleDeptRequestValidationError{}

// Validate checks the field values on ListRoleDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRoleDeptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleDeptResponseMultiError, or nil if none found.
func (m *ListRoleDeptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleDeptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleDeptResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleDeptResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleDeptResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListRoleDeptResponseMultiError(errors)
	}

	return nil
}

// ListRoleDeptResponseMultiError is an error wrapping multiple validation
// errors returned by ListRoleDeptResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRoleDeptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleDeptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleDeptResponseMultiError) AllErrors() []error { return m }

// ListRoleDeptResponseValidationError is the validation error returned by
// ListRoleDeptResponse.Validate if the designated constraints aren't met.
type ListRoleDeptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleDeptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleDeptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleDeptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleDeptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleDeptResponseValidationError) ErrorName() string {
	return "ListRoleDeptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoleDeptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleDeptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleDeptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleDeptResponseValidationError{}

// Validate checks the field values on GetRoleDataScopeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRoleDataScopeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleDataScopeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRoleDataScopeRequestMultiError, or nil if none found.
func (m *GetRoleDataScopeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleDataScopeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetRoleDataScopeRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRoleDataScopeRequestMultiError(errors)
	}

	return nil
}

// GetRoleDataScopeRequestMultiError is an error wrapping multiple validation
// errors returned by GetRoleDataScopeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetRoleDataScopeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleDataScopeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleDataScopeRequestMultiError) AllErrors() []error { return m }

// GetRoleDataScopeRequestValidationError is the validation error returned by
// GetRoleDataScopeRequest.Validate if the designated constraints aren't met.
type GetRoleDataScopeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleDataScopeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleDataScopeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleDataScopeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleDataScopeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleDataScopeRequestValidationError) ErrorName() string {
	return "GetRoleDataScopeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRoleDataScopeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleDataScopeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleDataScopeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleDataScopeRequestValidationError{}

// Validate checks the field values on GetRoleDataScopeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRoleDataScopeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleDataScopeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRoleDataScopeResponseMultiError, or nil if none found.
func (m *GetRoleDataScopeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleDataScopeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Scope

	if m.DeptCheckStrictly != nil {
		// no validation rules for DeptCheckStrictly
	}

	if len(errors) > 0 {
		return GetRoleDataScopeResponseMultiError(errors)
	}

	return nil
}

// GetRoleDataScopeResponseMultiError is an error wrapping multiple validation
// errors returned by GetRoleDataScopeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetRoleDataScopeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleDataScopeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleDataScopeResponseMultiError) AllErrors() []error { return m }

// GetRoleDataScopeResponseValidationError is the validation error returned by
// GetRoleDataScopeResponse.Validate if the designated constraints aren't met.
type GetRoleDataScopeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleDataScopeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleDataScopeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleDataScopeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleDataScopeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleDataScopeResponseValidationError) ErrorName() string {
	return "GetRoleDataScopeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRoleDataScopeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleDataScopeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleDataScopeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleDataScopeResponseValidationError{}

// Validate checks the field values on HandleRoleDataScopeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleDataScopeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleDataScopeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleDataScopeRequestMultiError, or nil if none found.
func (m *HandleRoleDataScopeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleDataScopeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleDataScopeRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleDataScopeRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleDataScopeRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleDataScopeRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleDataScopeRequestMultiError(errors)
	}

	return nil
}

// HandleRoleDataScopeRequestMultiError is an error wrapping multiple
// validation errors returned by HandleRoleDataScopeRequest.ValidateAll() if
// the designated constraints aren't met.
type HandleRoleDataScopeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleDataScopeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleDataScopeRequestMultiError) AllErrors() []error { return m }

// HandleRoleDataScopeRequestValidationError is the validation error returned
// by HandleRoleDataScopeRequest.Validate if the designated constraints aren't met.
type HandleRoleDataScopeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleDataScopeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleDataScopeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleDataScopeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleDataScopeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleDataScopeRequestValidationError) ErrorName() string {
	return "HandleRoleDataScopeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleDataScopeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleDataScopeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleDataScopeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleDataScopeRequestValidationError{}

// Validate checks the field values on HandleRoleDataScopeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleDataScopeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleDataScopeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleDataScopeResponseMultiError, or nil if none found.
func (m *HandleRoleDataScopeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleDataScopeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleRoleDataScopeResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleRoleDataScopeResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleRoleDataScopeResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleRoleDataScopeResponseMultiError(errors)
	}

	return nil
}

// HandleRoleDataScopeResponseMultiError is an error wrapping multiple
// validation errors returned by HandleRoleDataScopeResponse.ValidateAll() if
// the designated constraints aren't met.
type HandleRoleDataScopeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleDataScopeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleDataScopeResponseMultiError) AllErrors() []error { return m }

// HandleRoleDataScopeResponseValidationError is the validation error returned
// by HandleRoleDataScopeResponse.Validate if the designated constraints
// aren't met.
type HandleRoleDataScopeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleDataScopeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleDataScopeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleDataScopeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleDataScopeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleDataScopeResponseValidationError) ErrorName() string {
	return "HandleRoleDataScopeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleDataScopeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleDataScopeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleDataScopeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleDataScopeResponseValidationError{}

// Validate checks the field values on Menu with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MenuMultiError, or nil if none found.
func (m *Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for Title

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Path != nil {
		// no validation rules for Path
	}

	if m.IsHidden != nil {
		// no validation rules for IsHidden
	}

	if m.Component != nil {
		// no validation rules for Component
	}

	if m.Permission != nil {
		// no validation rules for Permission
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.IsCache != nil {
		// no validation rules for IsCache
	}

	if m.LinkUrl != nil {
		// no validation rules for LinkUrl
	}

	if m.IsAffix != nil {
		// no validation rules for IsAffix
	}

	if m.LinkType != nil {
		// no validation rules for LinkType
	}

	if m.ApiResource != nil {
		// no validation rules for ApiResource
	}

	if len(errors) > 0 {
		return MenuMultiError(errors)
	}

	return nil
}

// MenuMultiError is an error wrapping multiple validation errors returned by
// Menu.ValidateAll() if the designated constraints aren't met.
type MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuMultiError) AllErrors() []error { return m }

// MenuValidationError is the validation error returned by Menu.Validate if the
// designated constraints aren't met.
type MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuValidationError) ErrorName() string { return "MenuValidationError" }

// Error satisfies the builtin error interface
func (e MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuValidationError{}

// Validate checks the field values on ListMenuRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuRequestMultiError, or nil if none found.
func (m *ListMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListMenuRequestMultiError(errors)
	}

	return nil
}

// ListMenuRequestMultiError is an error wrapping multiple validation errors
// returned by ListMenuRequest.ValidateAll() if the designated constraints
// aren't met.
type ListMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuRequestMultiError) AllErrors() []error { return m }

// ListMenuRequestValidationError is the validation error returned by
// ListMenuRequest.Validate if the designated constraints aren't met.
type ListMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuRequestValidationError) ErrorName() string { return "ListMenuRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuRequestValidationError{}

// Validate checks the field values on ListMenuResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuResponseMultiError, or nil if none found.
func (m *ListMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMenuResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMenuResponseMultiError(errors)
	}

	return nil
}

// ListMenuResponseMultiError is an error wrapping multiple validation errors
// returned by ListMenuResponse.ValidateAll() if the designated constraints
// aren't met.
type ListMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuResponseMultiError) AllErrors() []error { return m }

// ListMenuResponseValidationError is the validation error returned by
// ListMenuResponse.Validate if the designated constraints aren't met.
type ListMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuResponseValidationError) ErrorName() string { return "ListMenuResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuResponseValidationError{}

// Validate checks the field values on CreateMenuRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMenuRequestMultiError, or nil if none found.
func (m *CreateMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetType() < 0 {
		err := CreateMenuRequestValidationError{
			field:  "Type",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateMenuRequestValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIsHidden() < 0 {
		err := CreateMenuRequestValidationError{
			field:  "IsHidden",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := CreateMenuRequestValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
			err := CreateMenuRequestValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Path != nil {

		if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
			err := CreateMenuRequestValidationError{
				field:  "Path",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Component != nil {

		if utf8.RuneCountInString(m.GetComponent()) > 100 {
			err := CreateMenuRequestValidationError{
				field:  "Component",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Permission != nil {

		if utf8.RuneCountInString(m.GetPermission()) > 100 {
			err := CreateMenuRequestValidationError{
				field:  "Permission",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() >= 100000 {
			err := CreateMenuRequestValidationError{
				field:  "Sort",
				reason: "value must be less than 100000",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Icon != nil {

		if l := utf8.RuneCountInString(m.GetIcon()); l < 0 || l > 100 {
			err := CreateMenuRequestValidationError{
				field:  "Icon",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsCache != nil {

		if m.GetIsCache() < 0 {
			err := CreateMenuRequestValidationError{
				field:  "IsCache",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkUrl != nil {

		if l := utf8.RuneCountInString(m.GetLinkUrl()); l < 0 || l > 100 {
			err := CreateMenuRequestValidationError{
				field:  "LinkUrl",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsAffix != nil {

		if m.GetIsAffix() < 0 {
			err := CreateMenuRequestValidationError{
				field:  "IsAffix",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkType != nil {

		if m.GetLinkType() < 0 {
			err := CreateMenuRequestValidationError{
				field:  "LinkType",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ApiResource != nil {

		if l := utf8.RuneCountInString(m.GetApiResource()); l < 1 || l > 100 {
			err := CreateMenuRequestValidationError{
				field:  "ApiResource",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateMenuRequestMultiError(errors)
	}

	return nil
}

// CreateMenuRequestMultiError is an error wrapping multiple validation errors
// returned by CreateMenuRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuRequestMultiError) AllErrors() []error { return m }

// CreateMenuRequestValidationError is the validation error returned by
// CreateMenuRequest.Validate if the designated constraints aren't met.
type CreateMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuRequestValidationError) ErrorName() string {
	return "CreateMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuRequestValidationError{}

// Validate checks the field values on CreateMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMenuResponseMultiError, or nil if none found.
func (m *CreateMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateMenuResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateMenuResponseMultiError(errors)
	}

	return nil
}

// CreateMenuResponseMultiError is an error wrapping multiple validation errors
// returned by CreateMenuResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuResponseMultiError) AllErrors() []error { return m }

// CreateMenuResponseValidationError is the validation error returned by
// CreateMenuResponse.Validate if the designated constraints aren't met.
type CreateMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuResponseValidationError) ErrorName() string {
	return "CreateMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuResponseValidationError{}

// Validate checks the field values on UpdateMenuRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuRequestMultiError, or nil if none found.
func (m *UpdateMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMenuRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMenuRequestMultiError(errors)
	}

	return nil
}

// UpdateMenuRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuRequestMultiError) AllErrors() []error { return m }

// UpdateMenuRequestValidationError is the validation error returned by
// UpdateMenuRequest.Validate if the designated constraints aren't met.
type UpdateMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuRequestValidationError) ErrorName() string {
	return "UpdateMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuRequestValidationError{}

// Validate checks the field values on UpdateMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuResponseMultiError, or nil if none found.
func (m *UpdateMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateMenuResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateMenuResponseMultiError(errors)
	}

	return nil
}

// UpdateMenuResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuResponseMultiError) AllErrors() []error { return m }

// UpdateMenuResponseValidationError is the validation error returned by
// UpdateMenuResponse.Validate if the designated constraints aren't met.
type UpdateMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuResponseValidationError) ErrorName() string {
	return "UpdateMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuResponseValidationError{}

// Validate checks the field values on GetMenuRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMenuRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMenuRequestMultiError,
// or nil if none found.
func (m *GetMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMenuRequestMultiError(errors)
	}

	return nil
}

// GetMenuRequestMultiError is an error wrapping multiple validation errors
// returned by GetMenuRequest.ValidateAll() if the designated constraints
// aren't met.
type GetMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMenuRequestMultiError) AllErrors() []error { return m }

// GetMenuRequestValidationError is the validation error returned by
// GetMenuRequest.Validate if the designated constraints aren't met.
type GetMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMenuRequestValidationError) ErrorName() string { return "GetMenuRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMenuRequestValidationError{}

// Validate checks the field values on DeleteMenuRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMenuRequestMultiError, or nil if none found.
func (m *DeleteMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteMenuRequestMultiError(errors)
	}

	return nil
}

// DeleteMenuRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteMenuRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMenuRequestMultiError) AllErrors() []error { return m }

// DeleteMenuRequestValidationError is the validation error returned by
// DeleteMenuRequest.Validate if the designated constraints aren't met.
type DeleteMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMenuRequestValidationError) ErrorName() string {
	return "DeleteMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMenuRequestValidationError{}

// Validate checks the field values on DeleteMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMenuResponseMultiError, or nil if none found.
func (m *DeleteMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteMenuResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteMenuResponseMultiError(errors)
	}

	return nil
}

// DeleteMenuResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteMenuResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMenuResponseMultiError) AllErrors() []error { return m }

// DeleteMenuResponseValidationError is the validation error returned by
// DeleteMenuResponse.Validate if the designated constraints aren't met.
type DeleteMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMenuResponseValidationError) ErrorName() string {
	return "DeleteMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMenuResponseValidationError{}

// Validate checks the field values on MenuTree with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuTree) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuTree with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuTreeMultiError, or nil
// if none found.
func (m *MenuTree) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuTree) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Title

	// no validation rules for ParentId

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuTreeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuTreeMultiError(errors)
	}

	return nil
}

// MenuTreeMultiError is an error wrapping multiple validation errors returned
// by MenuTree.ValidateAll() if the designated constraints aren't met.
type MenuTreeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuTreeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuTreeMultiError) AllErrors() []error { return m }

// MenuTreeValidationError is the validation error returned by
// MenuTree.Validate if the designated constraints aren't met.
type MenuTreeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuTreeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuTreeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuTreeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuTreeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuTreeValidationError) ErrorName() string { return "MenuTreeValidationError" }

// Error satisfies the builtin error interface
func (e MenuTreeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuTree.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuTreeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuTreeValidationError{}

// Validate checks the field values on ListMenuTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMenuTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuTreeRequestMultiError, or nil if none found.
func (m *ListMenuTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListMenuTreeRequestMultiError(errors)
	}

	return nil
}

// ListMenuTreeRequestMultiError is an error wrapping multiple validation
// errors returned by ListMenuTreeRequest.ValidateAll() if the designated
// constraints aren't met.
type ListMenuTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuTreeRequestMultiError) AllErrors() []error { return m }

// ListMenuTreeRequestValidationError is the validation error returned by
// ListMenuTreeRequest.Validate if the designated constraints aren't met.
type ListMenuTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuTreeRequestValidationError) ErrorName() string {
	return "ListMenuTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMenuTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuTreeRequestValidationError{}

// Validate checks the field values on ListMenuTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMenuTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuTreeResponseMultiError, or nil if none found.
func (m *ListMenuTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMenuTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMenuTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMenuTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListMenuTreeResponseMultiError(errors)
	}

	return nil
}

// ListMenuTreeResponseMultiError is an error wrapping multiple validation
// errors returned by ListMenuTreeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListMenuTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuTreeResponseMultiError) AllErrors() []error { return m }

// ListMenuTreeResponseValidationError is the validation error returned by
// ListMenuTreeResponse.Validate if the designated constraints aren't met.
type ListMenuTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuTreeResponseValidationError) ErrorName() string {
	return "ListMenuTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMenuTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuTreeResponseValidationError{}

// Validate checks the field values on Dept with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Dept) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dept with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DeptMultiError, or nil if none found.
func (m *Dept) ValidateAll() error {
	return m.validate(true)
}

func (m *Dept) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeptValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeptValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeptValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return DeptMultiError(errors)
	}

	return nil
}

// DeptMultiError is an error wrapping multiple validation errors returned by
// Dept.ValidateAll() if the designated constraints aren't met.
type DeptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeptMultiError) AllErrors() []error { return m }

// DeptValidationError is the validation error returned by Dept.Validate if the
// designated constraints aren't met.
type DeptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeptValidationError) ErrorName() string { return "DeptValidationError" }

// Error satisfies the builtin error interface
func (e DeptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDept.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeptValidationError{}

// Validate checks the field values on ListDeptRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDeptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeptRequestMultiError, or nil if none found.
func (m *ListDeptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListDeptRequestMultiError(errors)
	}

	return nil
}

// ListDeptRequestMultiError is an error wrapping multiple validation errors
// returned by ListDeptRequest.ValidateAll() if the designated constraints
// aren't met.
type ListDeptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeptRequestMultiError) AllErrors() []error { return m }

// ListDeptRequestValidationError is the validation error returned by
// ListDeptRequest.Validate if the designated constraints aren't met.
type ListDeptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeptRequestValidationError) ErrorName() string { return "ListDeptRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListDeptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeptRequestValidationError{}

// Validate checks the field values on ListDeptResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDeptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeptResponseMultiError, or nil if none found.
func (m *ListDeptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDeptResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDeptResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDeptResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDeptResponseMultiError(errors)
	}

	return nil
}

// ListDeptResponseMultiError is an error wrapping multiple validation errors
// returned by ListDeptResponse.ValidateAll() if the designated constraints
// aren't met.
type ListDeptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeptResponseMultiError) AllErrors() []error { return m }

// ListDeptResponseValidationError is the validation error returned by
// ListDeptResponse.Validate if the designated constraints aren't met.
type ListDeptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeptResponseValidationError) ErrorName() string { return "ListDeptResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListDeptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeptResponseValidationError{}

// Validate checks the field values on CreateDeptRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDeptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeptRequestMultiError, or nil if none found.
func (m *CreateDeptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDeptRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateDeptRequestValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreateDeptRequestValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateDeptRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := CreateDeptRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDeptRequestMultiError(errors)
	}

	return nil
}

// CreateDeptRequestMultiError is an error wrapping multiple validation errors
// returned by CreateDeptRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateDeptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeptRequestMultiError) AllErrors() []error { return m }

// CreateDeptRequestValidationError is the validation error returned by
// CreateDeptRequest.Validate if the designated constraints aren't met.
type CreateDeptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeptRequestValidationError) ErrorName() string {
	return "CreateDeptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDeptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeptRequestValidationError{}

// Validate checks the field values on CreateDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDeptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeptResponseMultiError, or nil if none found.
func (m *CreateDeptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDeptResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDeptResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDeptResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDeptResponseMultiError(errors)
	}

	return nil
}

// CreateDeptResponseMultiError is an error wrapping multiple validation errors
// returned by CreateDeptResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateDeptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeptResponseMultiError) AllErrors() []error { return m }

// CreateDeptResponseValidationError is the validation error returned by
// CreateDeptResponse.Validate if the designated constraints aren't met.
type CreateDeptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeptResponseValidationError) ErrorName() string {
	return "CreateDeptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDeptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeptResponseValidationError{}

// Validate checks the field values on UpdateDeptRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptRequestMultiError, or nil if none found.
func (m *UpdateDeptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDeptRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeptRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeptRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeptRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDeptRequestMultiError(errors)
	}

	return nil
}

// UpdateDeptRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateDeptRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateDeptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptRequestMultiError) AllErrors() []error { return m }

// UpdateDeptRequestValidationError is the validation error returned by
// UpdateDeptRequest.Validate if the designated constraints aren't met.
type UpdateDeptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptRequestValidationError) ErrorName() string {
	return "UpdateDeptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptRequestValidationError{}

// Validate checks the field values on UpdateDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptResponseMultiError, or nil if none found.
func (m *UpdateDeptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDeptResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDeptResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDeptResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDeptResponseMultiError(errors)
	}

	return nil
}

// UpdateDeptResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateDeptResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateDeptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptResponseMultiError) AllErrors() []error { return m }

// UpdateDeptResponseValidationError is the validation error returned by
// UpdateDeptResponse.Validate if the designated constraints aren't met.
type UpdateDeptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptResponseValidationError) ErrorName() string {
	return "UpdateDeptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptResponseValidationError{}

// Validate checks the field values on UpdateDeptStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptStateRequestMultiError, or nil if none found.
func (m *UpdateDeptStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDeptStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeptStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeptStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeptStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDeptStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDeptStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDeptStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDeptStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptStateRequestMultiError) AllErrors() []error { return m }

// UpdateDeptStateRequestValidationError is the validation error returned by
// UpdateDeptStateRequest.Validate if the designated constraints aren't met.
type UpdateDeptStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptStateRequestValidationError) ErrorName() string {
	return "UpdateDeptStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptStateRequestValidationError{}

// Validate checks the field values on UpdateDeptStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptStateResponseMultiError, or nil if none found.
func (m *UpdateDeptStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDeptStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDeptStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDeptStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDeptStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDeptStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDeptStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDeptStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptStateResponseMultiError) AllErrors() []error { return m }

// UpdateDeptStateResponseValidationError is the validation error returned by
// UpdateDeptStateResponse.Validate if the designated constraints aren't met.
type UpdateDeptStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptStateResponseValidationError) ErrorName() string {
	return "UpdateDeptStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptStateResponseValidationError{}

// Validate checks the field values on GetDeptRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetDeptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDeptRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetDeptRequestMultiError,
// or nil if none found.
func (m *GetDeptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDeptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDeptRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDeptRequestMultiError(errors)
	}

	return nil
}

// GetDeptRequestMultiError is an error wrapping multiple validation errors
// returned by GetDeptRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDeptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDeptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDeptRequestMultiError) AllErrors() []error { return m }

// GetDeptRequestValidationError is the validation error returned by
// GetDeptRequest.Validate if the designated constraints aren't met.
type GetDeptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDeptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDeptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDeptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDeptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDeptRequestValidationError) ErrorName() string { return "GetDeptRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetDeptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDeptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDeptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDeptRequestValidationError{}

// Validate checks the field values on DeleteDeptRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDeptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDeptRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDeptRequestMultiError, or nil if none found.
func (m *DeleteDeptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDeptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDeptRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDeptRequestMultiError(errors)
	}

	return nil
}

// DeleteDeptRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteDeptRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteDeptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDeptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDeptRequestMultiError) AllErrors() []error { return m }

// DeleteDeptRequestValidationError is the validation error returned by
// DeleteDeptRequest.Validate if the designated constraints aren't met.
type DeleteDeptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDeptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDeptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDeptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDeptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDeptRequestValidationError) ErrorName() string {
	return "DeleteDeptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDeptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDeptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDeptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDeptRequestValidationError{}

// Validate checks the field values on DeleteDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDeptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDeptResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDeptResponseMultiError, or nil if none found.
func (m *DeleteDeptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDeptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDeptResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDeptResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDeptResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDeptResponseMultiError(errors)
	}

	return nil
}

// DeleteDeptResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteDeptResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteDeptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDeptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDeptResponseMultiError) AllErrors() []error { return m }

// DeleteDeptResponseValidationError is the validation error returned by
// DeleteDeptResponse.Validate if the designated constraints aren't met.
type DeleteDeptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDeptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDeptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDeptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDeptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDeptResponseValidationError) ErrorName() string {
	return "DeleteDeptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDeptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDeptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDeptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDeptResponseValidationError{}

// Validate checks the field values on ListDeptTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDeptTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeptTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeptTreeRequestMultiError, or nil if none found.
func (m *ListDeptTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeptTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListDeptTreeRequestMultiError(errors)
	}

	return nil
}

// ListDeptTreeRequestMultiError is an error wrapping multiple validation
// errors returned by ListDeptTreeRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDeptTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeptTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeptTreeRequestMultiError) AllErrors() []error { return m }

// ListDeptTreeRequestValidationError is the validation error returned by
// ListDeptTreeRequest.Validate if the designated constraints aren't met.
type ListDeptTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeptTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeptTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeptTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeptTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeptTreeRequestValidationError) ErrorName() string {
	return "ListDeptTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeptTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeptTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeptTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeptTreeRequestValidationError{}

// Validate checks the field values on ListDeptTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDeptTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeptTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeptTreeResponseMultiError, or nil if none found.
func (m *ListDeptTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeptTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDeptTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDeptTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDeptTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDeptTreeResponseMultiError(errors)
	}

	return nil
}

// ListDeptTreeResponseMultiError is an error wrapping multiple validation
// errors returned by ListDeptTreeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDeptTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeptTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeptTreeResponseMultiError) AllErrors() []error { return m }

// ListDeptTreeResponseValidationError is the validation error returned by
// ListDeptTreeResponse.Validate if the designated constraints aren't met.
type ListDeptTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeptTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeptTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeptTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeptTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeptTreeResponseValidationError) ErrorName() string {
	return "ListDeptTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeptTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeptTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeptTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeptTreeResponseValidationError{}

// Validate checks the field values on Post with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Post) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Post with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PostMultiError, or nil if none found.
func (m *Post) ValidateAll() error {
	return m.validate(true)
}

func (m *Post) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return PostMultiError(errors)
	}

	return nil
}

// PostMultiError is an error wrapping multiple validation errors returned by
// Post.ValidateAll() if the designated constraints aren't met.
type PostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostMultiError) AllErrors() []error { return m }

// PostValidationError is the validation error returned by Post.Validate if the
// designated constraints aren't met.
type PostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostValidationError) ErrorName() string { return "PostValidationError" }

// Error satisfies the builtin error interface
func (e PostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostValidationError{}

// Validate checks the field values on ListPostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPostRequestMultiError, or nil if none found.
func (m *ListPostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if len(errors) > 0 {
		return ListPostRequestMultiError(errors)
	}

	return nil
}

// ListPostRequestMultiError is an error wrapping multiple validation errors
// returned by ListPostRequest.ValidateAll() if the designated constraints
// aren't met.
type ListPostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPostRequestMultiError) AllErrors() []error { return m }

// ListPostRequestValidationError is the validation error returned by
// ListPostRequest.Validate if the designated constraints aren't met.
type ListPostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPostRequestValidationError) ErrorName() string { return "ListPostRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListPostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPostRequestValidationError{}

// Validate checks the field values on ListPostResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPostResponseMultiError, or nil if none found.
func (m *ListPostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPostResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPostResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPostResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPostResponseMultiError(errors)
	}

	return nil
}

// ListPostResponseMultiError is an error wrapping multiple validation errors
// returned by ListPostResponse.ValidateAll() if the designated constraints
// aren't met.
type ListPostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPostResponseMultiError) AllErrors() []error { return m }

// ListPostResponseValidationError is the validation error returned by
// ListPostResponse.Validate if the designated constraints aren't met.
type ListPostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPostResponseValidationError) ErrorName() string { return "ListPostResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListPostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPostResponseValidationError{}

// Validate checks the field values on CreatePostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePostRequestMultiError, or nil if none found.
func (m *CreatePostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreatePostRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreatePostRequestValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreatePostRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Code != nil {

		if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 10 {
			err := CreatePostRequestValidationError{
				field:  "Code",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreatePostRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreatePostRequestMultiError(errors)
	}

	return nil
}

// CreatePostRequestMultiError is an error wrapping multiple validation errors
// returned by CreatePostRequest.ValidateAll() if the designated constraints
// aren't met.
type CreatePostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePostRequestMultiError) AllErrors() []error { return m }

// CreatePostRequestValidationError is the validation error returned by
// CreatePostRequest.Validate if the designated constraints aren't met.
type CreatePostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePostRequestValidationError) ErrorName() string {
	return "CreatePostRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePostRequestValidationError{}

// Validate checks the field values on CreatePostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePostResponseMultiError, or nil if none found.
func (m *CreatePostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreatePostResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreatePostResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreatePostResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreatePostResponseMultiError(errors)
	}

	return nil
}

// CreatePostResponseMultiError is an error wrapping multiple validation errors
// returned by CreatePostResponse.ValidateAll() if the designated constraints
// aren't met.
type CreatePostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePostResponseMultiError) AllErrors() []error { return m }

// CreatePostResponseValidationError is the validation error returned by
// CreatePostResponse.Validate if the designated constraints aren't met.
type CreatePostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePostResponseValidationError) ErrorName() string {
	return "CreatePostResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePostResponseValidationError{}

// Validate checks the field values on UpdatePostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostRequestMultiError, or nil if none found.
func (m *UpdatePostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdatePostRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostRequestMultiError(errors)
	}

	return nil
}

// UpdatePostRequestMultiError is an error wrapping multiple validation errors
// returned by UpdatePostRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostRequestMultiError) AllErrors() []error { return m }

// UpdatePostRequestValidationError is the validation error returned by
// UpdatePostRequest.Validate if the designated constraints aren't met.
type UpdatePostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostRequestValidationError) ErrorName() string {
	return "UpdatePostRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostRequestValidationError{}

// Validate checks the field values on UpdatePostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostResponseMultiError, or nil if none found.
func (m *UpdatePostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdatePostResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdatePostResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdatePostResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdatePostResponseMultiError(errors)
	}

	return nil
}

// UpdatePostResponseMultiError is an error wrapping multiple validation errors
// returned by UpdatePostResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostResponseMultiError) AllErrors() []error { return m }

// UpdatePostResponseValidationError is the validation error returned by
// UpdatePostResponse.Validate if the designated constraints aren't met.
type UpdatePostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostResponseValidationError) ErrorName() string {
	return "UpdatePostResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostResponseValidationError{}

// Validate checks the field values on GetPostRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPostRequestMultiError,
// or nil if none found.
func (m *GetPostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetPostRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPostRequestMultiError(errors)
	}

	return nil
}

// GetPostRequestMultiError is an error wrapping multiple validation errors
// returned by GetPostRequest.ValidateAll() if the designated constraints
// aren't met.
type GetPostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPostRequestMultiError) AllErrors() []error { return m }

// GetPostRequestValidationError is the validation error returned by
// GetPostRequest.Validate if the designated constraints aren't met.
type GetPostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPostRequestValidationError) ErrorName() string { return "GetPostRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetPostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPostRequestValidationError{}

// Validate checks the field values on DeletePostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeletePostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePostRequestMultiError, or nil if none found.
func (m *DeletePostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeletePostRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePostRequestMultiError(errors)
	}

	return nil
}

// DeletePostRequestMultiError is an error wrapping multiple validation errors
// returned by DeletePostRequest.ValidateAll() if the designated constraints
// aren't met.
type DeletePostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePostRequestMultiError) AllErrors() []error { return m }

// DeletePostRequestValidationError is the validation error returned by
// DeletePostRequest.Validate if the designated constraints aren't met.
type DeletePostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePostRequestValidationError) ErrorName() string {
	return "DeletePostRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePostRequestValidationError{}

// Validate checks the field values on DeletePostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePostResponseMultiError, or nil if none found.
func (m *DeletePostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeletePostResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeletePostResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeletePostResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeletePostResponseMultiError(errors)
	}

	return nil
}

// DeletePostResponseMultiError is an error wrapping multiple validation errors
// returned by DeletePostResponse.ValidateAll() if the designated constraints
// aren't met.
type DeletePostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePostResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePostResponseMultiError) AllErrors() []error { return m }

// DeletePostResponseValidationError is the validation error returned by
// DeletePostResponse.Validate if the designated constraints aren't met.
type DeletePostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePostResponseValidationError) ErrorName() string {
	return "DeletePostResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePostResponseValidationError{}

// Validate checks the field values on UpdatePostStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateRequestMultiError, or nil if none found.
func (m *UpdatePostStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdatePostStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostStateRequestMultiError(errors)
	}

	return nil
}

// UpdatePostStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePostStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateRequestMultiError) AllErrors() []error { return m }

// UpdatePostStateRequestValidationError is the validation error returned by
// UpdatePostStateRequest.Validate if the designated constraints aren't met.
type UpdatePostStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateRequestValidationError) ErrorName() string {
	return "UpdatePostStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateRequestValidationError{}

// Validate checks the field values on UpdatePostStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateResponseMultiError, or nil if none found.
func (m *UpdatePostStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdatePostStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdatePostStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdatePostStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdatePostStateResponseMultiError(errors)
	}

	return nil
}

// UpdatePostStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePostStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateResponseMultiError) AllErrors() []error { return m }

// UpdatePostStateResponseValidationError is the validation error returned by
// UpdatePostStateResponse.Validate if the designated constraints aren't met.
type UpdatePostStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateResponseValidationError) ErrorName() string {
	return "UpdatePostStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateResponseValidationError{}

// Validate checks the field values on Dict with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Dict) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dict with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DictMultiError, or nil if none found.
func (m *Dict) ValidateAll() error {
	return m.validate(true)
}

func (m *Dict) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DictValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DictValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DictValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DictValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DictValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DictValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return DictMultiError(errors)
	}

	return nil
}

// DictMultiError is an error wrapping multiple validation errors returned by
// Dict.ValidateAll() if the designated constraints aren't met.
type DictMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DictMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DictMultiError) AllErrors() []error { return m }

// DictValidationError is the validation error returned by Dict.Validate if the
// designated constraints aren't met.
type DictValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DictValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DictValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DictValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DictValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DictValidationError) ErrorName() string { return "DictValidationError" }

// Error satisfies the builtin error interface
func (e DictValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDict.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DictValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DictValidationError{}

// Validate checks the field values on ListDictRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDictRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDictRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDictRequestMultiError, or nil if none found.
func (m *ListDictRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDictRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListDictRequestMultiError(errors)
	}

	return nil
}

// ListDictRequestMultiError is an error wrapping multiple validation errors
// returned by ListDictRequest.ValidateAll() if the designated constraints
// aren't met.
type ListDictRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDictRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDictRequestMultiError) AllErrors() []error { return m }

// ListDictRequestValidationError is the validation error returned by
// ListDictRequest.Validate if the designated constraints aren't met.
type ListDictRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDictRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDictRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDictRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDictRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDictRequestValidationError) ErrorName() string { return "ListDictRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListDictRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDictRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDictRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDictRequestValidationError{}

// Validate checks the field values on ListDictResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDictResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDictResponseMultiError, or nil if none found.
func (m *ListDictResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDictResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDictResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDictResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDictResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDictResponseMultiError(errors)
	}

	return nil
}

// ListDictResponseMultiError is an error wrapping multiple validation errors
// returned by ListDictResponse.ValidateAll() if the designated constraints
// aren't met.
type ListDictResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDictResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDictResponseMultiError) AllErrors() []error { return m }

// ListDictResponseValidationError is the validation error returned by
// ListDictResponse.Validate if the designated constraints aren't met.
type ListDictResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDictResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDictResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDictResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDictResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDictResponseValidationError) ErrorName() string { return "ListDictResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListDictResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDictResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDictResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDictResponseValidationError{}

// Validate checks the field values on CreateDictRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDictRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDictRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDictRequestMultiError, or nil if none found.
func (m *CreateDictRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDictRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDictRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetType()); l < 1 || l > 50 {
		err := CreateDictRequestValidationError{
			field:  "Type",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreateDictRequestValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateDictRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreateDictRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDictRequestMultiError(errors)
	}

	return nil
}

// CreateDictRequestMultiError is an error wrapping multiple validation errors
// returned by CreateDictRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateDictRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDictRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDictRequestMultiError) AllErrors() []error { return m }

// CreateDictRequestValidationError is the validation error returned by
// CreateDictRequest.Validate if the designated constraints aren't met.
type CreateDictRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDictRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDictRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDictRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDictRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDictRequestValidationError) ErrorName() string {
	return "CreateDictRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDictRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDictRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDictRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDictRequestValidationError{}

// Validate checks the field values on CreateDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDictResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDictResponseMultiError, or nil if none found.
func (m *CreateDictResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDictResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDictResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDictResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDictResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDictResponseMultiError(errors)
	}

	return nil
}

// CreateDictResponseMultiError is an error wrapping multiple validation errors
// returned by CreateDictResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateDictResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDictResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDictResponseMultiError) AllErrors() []error { return m }

// CreateDictResponseValidationError is the validation error returned by
// CreateDictResponse.Validate if the designated constraints aren't met.
type CreateDictResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDictResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDictResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDictResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDictResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDictResponseValidationError) ErrorName() string {
	return "CreateDictResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDictResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDictResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDictResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDictResponseValidationError{}

// Validate checks the field values on UpdateDictRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictRequestMultiError, or nil if none found.
func (m *UpdateDictRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDictRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDictRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDictRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDictRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDictRequestMultiError(errors)
	}

	return nil
}

// UpdateDictRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateDictRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateDictRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictRequestMultiError) AllErrors() []error { return m }

// UpdateDictRequestValidationError is the validation error returned by
// UpdateDictRequest.Validate if the designated constraints aren't met.
type UpdateDictRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictRequestValidationError) ErrorName() string {
	return "UpdateDictRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictRequestValidationError{}

// Validate checks the field values on UpdateDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictResponseMultiError, or nil if none found.
func (m *UpdateDictResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDictResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDictResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDictResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDictResponseMultiError(errors)
	}

	return nil
}

// UpdateDictResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateDictResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateDictResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictResponseMultiError) AllErrors() []error { return m }

// UpdateDictResponseValidationError is the validation error returned by
// UpdateDictResponse.Validate if the designated constraints aren't met.
type UpdateDictResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictResponseValidationError) ErrorName() string {
	return "UpdateDictResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictResponseValidationError{}

// Validate checks the field values on GetDictRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetDictRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDictRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetDictRequestMultiError,
// or nil if none found.
func (m *GetDictRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDictRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDictRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDictRequestMultiError(errors)
	}

	return nil
}

// GetDictRequestMultiError is an error wrapping multiple validation errors
// returned by GetDictRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDictRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDictRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDictRequestMultiError) AllErrors() []error { return m }

// GetDictRequestValidationError is the validation error returned by
// GetDictRequest.Validate if the designated constraints aren't met.
type GetDictRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDictRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDictRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDictRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDictRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDictRequestValidationError) ErrorName() string { return "GetDictRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetDictRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDictRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDictRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDictRequestValidationError{}

// Validate checks the field values on DeleteDictRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDictRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDictRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDictRequestMultiError, or nil if none found.
func (m *DeleteDictRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDictRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDictRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDictRequestMultiError(errors)
	}

	return nil
}

// DeleteDictRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteDictRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteDictRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDictRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDictRequestMultiError) AllErrors() []error { return m }

// DeleteDictRequestValidationError is the validation error returned by
// DeleteDictRequest.Validate if the designated constraints aren't met.
type DeleteDictRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDictRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDictRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDictRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDictRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDictRequestValidationError) ErrorName() string {
	return "DeleteDictRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDictRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDictRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDictRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDictRequestValidationError{}

// Validate checks the field values on DeleteDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDictResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDictResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDictResponseMultiError, or nil if none found.
func (m *DeleteDictResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDictResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDictResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDictResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDictResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDictResponseMultiError(errors)
	}

	return nil
}

// DeleteDictResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteDictResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteDictResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDictResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDictResponseMultiError) AllErrors() []error { return m }

// DeleteDictResponseValidationError is the validation error returned by
// DeleteDictResponse.Validate if the designated constraints aren't met.
type DeleteDictResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDictResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDictResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDictResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDictResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDictResponseValidationError) ErrorName() string {
	return "DeleteDictResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDictResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDictResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDictResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDictResponseValidationError{}

// Validate checks the field values on UpdateDictStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictStateRequestMultiError, or nil if none found.
func (m *UpdateDictStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDictStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDictStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDictStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDictStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDictStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDictStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDictStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDictStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictStateRequestMultiError) AllErrors() []error { return m }

// UpdateDictStateRequestValidationError is the validation error returned by
// UpdateDictStateRequest.Validate if the designated constraints aren't met.
type UpdateDictStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictStateRequestValidationError) ErrorName() string {
	return "UpdateDictStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictStateRequestValidationError{}

// Validate checks the field values on UpdateDictStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictStateResponseMultiError, or nil if none found.
func (m *UpdateDictStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDictStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDictStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDictStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDictStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDictStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDictStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDictStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictStateResponseMultiError) AllErrors() []error { return m }

// UpdateDictStateResponseValidationError is the validation error returned by
// UpdateDictStateResponse.Validate if the designated constraints aren't met.
type UpdateDictStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictStateResponseValidationError) ErrorName() string {
	return "UpdateDictStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictStateResponseValidationError{}

// Validate checks the field values on DictData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DictData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DictData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DictDataMultiError, or nil
// if none found.
func (m *DictData) ValidateAll() error {
	return m.validate(true)
}

func (m *DictData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Label

	// no validation rules for Value

	// no validation rules for DictType

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DictDataValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DictDataValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DictDataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DictDataValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DictDataValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DictDataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ColorType != nil {
		// no validation rules for ColorType
	}

	if m.CssClass != nil {
		// no validation rules for CssClass
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return DictDataMultiError(errors)
	}

	return nil
}

// DictDataMultiError is an error wrapping multiple validation errors returned
// by DictData.ValidateAll() if the designated constraints aren't met.
type DictDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DictDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DictDataMultiError) AllErrors() []error { return m }

// DictDataValidationError is the validation error returned by
// DictData.Validate if the designated constraints aren't met.
type DictDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DictDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DictDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DictDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DictDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DictDataValidationError) ErrorName() string { return "DictDataValidationError" }

// Error satisfies the builtin error interface
func (e DictDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDictData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DictDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DictDataValidationError{}

// Validate checks the field values on ListDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDictDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDictDataRequestMultiError, or nil if none found.
func (m *ListDictDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDictDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.DictType != nil {
		// no validation rules for DictType
	}

	if len(errors) > 0 {
		return ListDictDataRequestMultiError(errors)
	}

	return nil
}

// ListDictDataRequestMultiError is an error wrapping multiple validation
// errors returned by ListDictDataRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDictDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDictDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDictDataRequestMultiError) AllErrors() []error { return m }

// ListDictDataRequestValidationError is the validation error returned by
// ListDictDataRequest.Validate if the designated constraints aren't met.
type ListDictDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDictDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDictDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDictDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDictDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDictDataRequestValidationError) ErrorName() string {
	return "ListDictDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDictDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDictDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDictDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDictDataRequestValidationError{}

// Validate checks the field values on ListDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDictDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDictDataResponseMultiError, or nil if none found.
func (m *ListDictDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDictDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDictDataResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDictDataResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDictDataResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDictDataResponseMultiError(errors)
	}

	return nil
}

// ListDictDataResponseMultiError is an error wrapping multiple validation
// errors returned by ListDictDataResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDictDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDictDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDictDataResponseMultiError) AllErrors() []error { return m }

// ListDictDataResponseValidationError is the validation error returned by
// ListDictDataResponse.Validate if the designated constraints aren't met.
type ListDictDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDictDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDictDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDictDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDictDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDictDataResponseValidationError) ErrorName() string {
	return "ListDictDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDictDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDictDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDictDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDictDataResponseValidationError{}

// Validate checks the field values on CreateDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDictDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDictDataRequestMultiError, or nil if none found.
func (m *CreateDictDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDictDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLabel()); l < 1 || l > 10 {
		err := CreateDictDataRequestValidationError{
			field:  "Label",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 10 {
		err := CreateDictDataRequestValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDictType()); l < 1 || l > 50 {
		err := CreateDictDataRequestValidationError{
			field:  "DictType",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreateDictDataRequestValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateDictDataRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreateDictDataRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ColorType != nil {

		if l := utf8.RuneCountInString(m.GetColorType()); l < 0 || l > 100 {
			err := CreateDictDataRequestValidationError{
				field:  "ColorType",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.CssClass != nil {

		if l := utf8.RuneCountInString(m.GetCssClass()); l < 0 || l > 100 {
			err := CreateDictDataRequestValidationError{
				field:  "CssClass",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDictDataRequestMultiError(errors)
	}

	return nil
}

// CreateDictDataRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDictDataRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDictDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDictDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDictDataRequestMultiError) AllErrors() []error { return m }

// CreateDictDataRequestValidationError is the validation error returned by
// CreateDictDataRequest.Validate if the designated constraints aren't met.
type CreateDictDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDictDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDictDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDictDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDictDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDictDataRequestValidationError) ErrorName() string {
	return "CreateDictDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDictDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDictDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDictDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDictDataRequestValidationError{}

// Validate checks the field values on CreateDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDictDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDictDataResponseMultiError, or nil if none found.
func (m *CreateDictDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDictDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDictDataResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDictDataResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDictDataResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDictDataResponseMultiError(errors)
	}

	return nil
}

// CreateDictDataResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDictDataResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDictDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDictDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDictDataResponseMultiError) AllErrors() []error { return m }

// CreateDictDataResponseValidationError is the validation error returned by
// CreateDictDataResponse.Validate if the designated constraints aren't met.
type CreateDictDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDictDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDictDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDictDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDictDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDictDataResponseValidationError) ErrorName() string {
	return "CreateDictDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDictDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDictDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDictDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDictDataResponseValidationError{}

// Validate checks the field values on UpdateDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictDataRequestMultiError, or nil if none found.
func (m *UpdateDictDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDictDataRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDictDataRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDictDataRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDictDataRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDictDataRequestMultiError(errors)
	}

	return nil
}

// UpdateDictDataRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDictDataRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDictDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictDataRequestMultiError) AllErrors() []error { return m }

// UpdateDictDataRequestValidationError is the validation error returned by
// UpdateDictDataRequest.Validate if the designated constraints aren't met.
type UpdateDictDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictDataRequestValidationError) ErrorName() string {
	return "UpdateDictDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictDataRequestValidationError{}

// Validate checks the field values on UpdateDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictDataResponseMultiError, or nil if none found.
func (m *UpdateDictDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDictDataResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDictDataResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDictDataResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDictDataResponseMultiError(errors)
	}

	return nil
}

// UpdateDictDataResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDictDataResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDictDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictDataResponseMultiError) AllErrors() []error { return m }

// UpdateDictDataResponseValidationError is the validation error returned by
// UpdateDictDataResponse.Validate if the designated constraints aren't met.
type UpdateDictDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictDataResponseValidationError) ErrorName() string {
	return "UpdateDictDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictDataResponseValidationError{}

// Validate checks the field values on GetDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDictDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDictDataRequestMultiError, or nil if none found.
func (m *GetDictDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDictDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDictDataRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDictDataRequestMultiError(errors)
	}

	return nil
}

// GetDictDataRequestMultiError is an error wrapping multiple validation errors
// returned by GetDictDataRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDictDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDictDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDictDataRequestMultiError) AllErrors() []error { return m }

// GetDictDataRequestValidationError is the validation error returned by
// GetDictDataRequest.Validate if the designated constraints aren't met.
type GetDictDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDictDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDictDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDictDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDictDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDictDataRequestValidationError) ErrorName() string {
	return "GetDictDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDictDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDictDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDictDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDictDataRequestValidationError{}

// Validate checks the field values on DeleteDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDictDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDictDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDictDataRequestMultiError, or nil if none found.
func (m *DeleteDictDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDictDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDictDataRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDictDataRequestMultiError(errors)
	}

	return nil
}

// DeleteDictDataRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDictDataRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDictDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDictDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDictDataRequestMultiError) AllErrors() []error { return m }

// DeleteDictDataRequestValidationError is the validation error returned by
// DeleteDictDataRequest.Validate if the designated constraints aren't met.
type DeleteDictDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDictDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDictDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDictDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDictDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDictDataRequestValidationError) ErrorName() string {
	return "DeleteDictDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDictDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDictDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDictDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDictDataRequestValidationError{}

// Validate checks the field values on DeleteDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDictDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDictDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDictDataResponseMultiError, or nil if none found.
func (m *DeleteDictDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDictDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDictDataResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDictDataResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDictDataResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDictDataResponseMultiError(errors)
	}

	return nil
}

// DeleteDictDataResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteDictDataResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteDictDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDictDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDictDataResponseMultiError) AllErrors() []error { return m }

// DeleteDictDataResponseValidationError is the validation error returned by
// DeleteDictDataResponse.Validate if the designated constraints aren't met.
type DeleteDictDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDictDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDictDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDictDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDictDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDictDataResponseValidationError) ErrorName() string {
	return "DeleteDictDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDictDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDictDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDictDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDictDataResponseValidationError{}

// Validate checks the field values on UpdateDictDataStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictDataStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictDataStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictDataStateRequestMultiError, or nil if none found.
func (m *UpdateDictDataStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictDataStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDictDataStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDictDataStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDictDataStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDictDataStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDictDataStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDictDataStateRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDictDataStateRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDictDataStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictDataStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictDataStateRequestMultiError) AllErrors() []error { return m }

// UpdateDictDataStateRequestValidationError is the validation error returned
// by UpdateDictDataStateRequest.Validate if the designated constraints aren't met.
type UpdateDictDataStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictDataStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictDataStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictDataStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictDataStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictDataStateRequestValidationError) ErrorName() string {
	return "UpdateDictDataStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictDataStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictDataStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictDataStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictDataStateRequestValidationError{}

// Validate checks the field values on UpdateDictDataStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictDataStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictDataStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictDataStateResponseMultiError, or nil if none found.
func (m *UpdateDictDataStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictDataStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDictDataStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDictDataStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDictDataStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDictDataStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDictDataStateResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDictDataStateResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateDictDataStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictDataStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictDataStateResponseMultiError) AllErrors() []error { return m }

// UpdateDictDataStateResponseValidationError is the validation error returned
// by UpdateDictDataStateResponse.Validate if the designated constraints
// aren't met.
type UpdateDictDataStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictDataStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictDataStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictDataStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictDataStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictDataStateResponseValidationError) ErrorName() string {
	return "UpdateDictDataStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictDataStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictDataStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictDataStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictDataStateResponseValidationError{}

// Validate checks the field values on DomainPackage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DomainPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DomainPackage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DomainPackageMultiError, or
// nil if none found.
func (m *DomainPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *DomainPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainPackageValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainPackageValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return DomainPackageMultiError(errors)
	}

	return nil
}

// DomainPackageMultiError is an error wrapping multiple validation errors
// returned by DomainPackage.ValidateAll() if the designated constraints
// aren't met.
type DomainPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DomainPackageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DomainPackageMultiError) AllErrors() []error { return m }

// DomainPackageValidationError is the validation error returned by
// DomainPackage.Validate if the designated constraints aren't met.
type DomainPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DomainPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DomainPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DomainPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DomainPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DomainPackageValidationError) ErrorName() string { return "DomainPackageValidationError" }

// Error satisfies the builtin error interface
func (e DomainPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDomainPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DomainPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DomainPackageValidationError{}

// Validate checks the field values on ListDomainPackageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainPackageRequestMultiError, or nil if none found.
func (m *ListDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if len(errors) > 0 {
		return ListDomainPackageRequestMultiError(errors)
	}

	return nil
}

// ListDomainPackageRequestMultiError is an error wrapping multiple validation
// errors returned by ListDomainPackageRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainPackageRequestMultiError) AllErrors() []error { return m }

// ListDomainPackageRequestValidationError is the validation error returned by
// ListDomainPackageRequest.Validate if the designated constraints aren't met.
type ListDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainPackageRequestValidationError) ErrorName() string {
	return "ListDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainPackageRequestValidationError{}

// Validate checks the field values on ListDomainPackageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainPackageResponseMultiError, or nil if none found.
func (m *ListDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainPackageResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainPackageResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainPackageResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDomainPackageResponseMultiError(errors)
	}

	return nil
}

// ListDomainPackageResponseMultiError is an error wrapping multiple validation
// errors returned by ListDomainPackageResponse.ValidateAll() if the
// designated constraints aren't met.
type ListDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainPackageResponseMultiError) AllErrors() []error { return m }

// ListDomainPackageResponseValidationError is the validation error returned by
// ListDomainPackageResponse.Validate if the designated constraints aren't met.
type ListDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainPackageResponseValidationError) ErrorName() string {
	return "ListDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainPackageResponseValidationError{}

// Validate checks the field values on CreateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainPackageRequestMultiError, or nil if none found.
func (m *CreateDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDomainPackageRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateDomainPackageRequest_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _CreateDomainPackageRequest_MenuIds_Unique[item]; exists {
			err := CreateDomainPackageRequestValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateDomainPackageRequest_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateDomainPackageRequestValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetSort() < 0 {
		err := CreateDomainPackageRequestValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateDomainPackageRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreateDomainPackageRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDomainPackageRequestMultiError(errors)
	}

	return nil
}

// CreateDomainPackageRequestMultiError is an error wrapping multiple
// validation errors returned by CreateDomainPackageRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainPackageRequestMultiError) AllErrors() []error { return m }

// CreateDomainPackageRequestValidationError is the validation error returned
// by CreateDomainPackageRequest.Validate if the designated constraints aren't met.
type CreateDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainPackageRequestValidationError) ErrorName() string {
	return "CreateDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainPackageRequestValidationError{}

// Validate checks the field values on CreateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainPackageResponseMultiError, or nil if none found.
func (m *CreateDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDomainPackageResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDomainPackageResponseMultiError(errors)
	}

	return nil
}

// CreateDomainPackageResponseMultiError is an error wrapping multiple
// validation errors returned by CreateDomainPackageResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainPackageResponseMultiError) AllErrors() []error { return m }

// CreateDomainPackageResponseValidationError is the validation error returned
// by CreateDomainPackageResponse.Validate if the designated constraints
// aren't met.
type CreateDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainPackageResponseValidationError) ErrorName() string {
	return "CreateDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainPackageResponseValidationError{}

// Validate checks the field values on UpdateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageRequestMultiError, or nil if none found.
func (m *UpdateDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainPackageRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainPackageRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainPackageRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainPackageRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainPackageRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageRequestMultiError) AllErrors() []error { return m }

// UpdateDomainPackageRequestValidationError is the validation error returned
// by UpdateDomainPackageRequest.Validate if the designated constraints aren't met.
type UpdateDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageRequestValidationError) ErrorName() string {
	return "UpdateDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageRequestValidationError{}

// Validate checks the field values on UpdateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageResponseMultiError, or nil if none found.
func (m *UpdateDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainPackageResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainPackageResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageResponseMultiError) AllErrors() []error { return m }

// UpdateDomainPackageResponseValidationError is the validation error returned
// by UpdateDomainPackageResponse.Validate if the designated constraints
// aren't met.
type UpdateDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageResponseValidationError) ErrorName() string {
	return "UpdateDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageResponseValidationError{}

// Validate checks the field values on GetDomainPackageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainPackageRequestMultiError, or nil if none found.
func (m *GetDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDomainPackageRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainPackageRequestMultiError(errors)
	}

	return nil
}

// GetDomainPackageRequestMultiError is an error wrapping multiple validation
// errors returned by GetDomainPackageRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainPackageRequestMultiError) AllErrors() []error { return m }

// GetDomainPackageRequestValidationError is the validation error returned by
// GetDomainPackageRequest.Validate if the designated constraints aren't met.
type GetDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainPackageRequestValidationError) ErrorName() string {
	return "GetDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainPackageRequestValidationError{}

// Validate checks the field values on DeleteDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainPackageRequestMultiError, or nil if none found.
func (m *DeleteDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDomainPackageRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDomainPackageRequestMultiError(errors)
	}

	return nil
}

// DeleteDomainPackageRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteDomainPackageRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainPackageRequestMultiError) AllErrors() []error { return m }

// DeleteDomainPackageRequestValidationError is the validation error returned
// by DeleteDomainPackageRequest.Validate if the designated constraints aren't met.
type DeleteDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainPackageRequestValidationError) ErrorName() string {
	return "DeleteDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainPackageRequestValidationError{}

// Validate checks the field values on DeleteDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainPackageResponseMultiError, or nil if none found.
func (m *DeleteDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDomainPackageResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDomainPackageResponseMultiError(errors)
	}

	return nil
}

// DeleteDomainPackageResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteDomainPackageResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainPackageResponseMultiError) AllErrors() []error { return m }

// DeleteDomainPackageResponseValidationError is the validation error returned
// by DeleteDomainPackageResponse.Validate if the designated constraints
// aren't met.
type DeleteDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainPackageResponseValidationError) ErrorName() string {
	return "DeleteDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainPackageResponseValidationError{}

// Validate checks the field values on UpdateDomainPackageStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageStateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageStateRequestMultiError, or nil if none found.
func (m *UpdateDomainPackageStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainPackageStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainPackageStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainPackageStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainPackageStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainPackageStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageStateRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageStateRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateDomainPackageStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageStateRequestMultiError) AllErrors() []error { return m }

// UpdateDomainPackageStateRequestValidationError is the validation error
// returned by UpdateDomainPackageStateRequest.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageStateRequestValidationError) ErrorName() string {
	return "UpdateDomainPackageStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageStateRequestValidationError{}

// Validate checks the field values on UpdateDomainPackageStateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateDomainPackageStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageStateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageStateResponseMultiError, or nil if none found.
func (m *UpdateDomainPackageStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainPackageStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainPackageStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainPackageStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainPackageStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageStateResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDomainPackageStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainPackageStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageStateResponseMultiError) AllErrors() []error { return m }

// UpdateDomainPackageStateResponseValidationError is the validation error
// returned by UpdateDomainPackageStateResponse.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageStateResponseValidationError) ErrorName() string {
	return "UpdateDomainPackageStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageStateResponseValidationError{}

// Validate checks the field values on LoginRequest_Auth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginRequest_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginRequest_AuthMultiError, or nil if none found.
func (m *LoginRequest_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccount()); l < 1 || l > 10 {
		err := LoginRequest_AuthValidationError{
			field:  "Account",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
		err := LoginRequest_AuthValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 28 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginRequest_AuthMultiError(errors)
	}

	return nil
}

// LoginRequest_AuthMultiError is an error wrapping multiple validation errors
// returned by LoginRequest_Auth.ValidateAll() if the designated constraints
// aren't met.
type LoginRequest_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequest_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequest_AuthMultiError) AllErrors() []error { return m }

// LoginRequest_AuthValidationError is the validation error returned by
// LoginRequest_Auth.Validate if the designated constraints aren't met.
type LoginRequest_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequest_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequest_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequest_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequest_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequest_AuthValidationError) ErrorName() string {
	return "LoginRequest_AuthValidationError"
}

// Error satisfies the builtin error interface
func (e LoginRequest_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequest_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequest_AuthValidationError{}

// Validate checks the field values on SmsLoginRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SmsLoginRequest_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SmsLoginRequest_AuthMultiError, or nil if none found.
func (m *SmsLoginRequest_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginRequest_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SmsLoginRequest_Auth_Phone_Pattern.MatchString(m.GetPhone()) {
		err := SmsLoginRequest_AuthValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SmsLoginRequest_Auth_Code_Pattern.MatchString(m.GetCode()) {
		err := SmsLoginRequest_AuthValidationError{
			field:  "Code",
			reason: "value does not match regex pattern \"^[0-9]{6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SmsLoginRequest_AuthMultiError(errors)
	}

	return nil
}

// SmsLoginRequest_AuthMultiError is an error wrapping multiple validation
// errors returned by SmsLoginRequest_Auth.ValidateAll() if the designated
// constraints aren't met.
type SmsLoginRequest_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginRequest_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginRequest_AuthMultiError) AllErrors() []error { return m }

// SmsLoginRequest_AuthValidationError is the validation error returned by
// SmsLoginRequest_Auth.Validate if the designated constraints aren't met.
type SmsLoginRequest_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginRequest_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginRequest_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginRequest_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginRequest_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginRequest_AuthValidationError) ErrorName() string {
	return "SmsLoginRequest_AuthValidationError"
}

// Error satisfies the builtin error interface
func (e SmsLoginRequest_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginRequest_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginRequest_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginRequest_AuthValidationError{}

var _SmsLoginRequest_Auth_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _SmsLoginRequest_Auth_Code_Pattern = regexp.MustCompile("^[0-9]{6}$")

// Validate checks the field values on EmailLoginRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailLoginRequest_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailLoginRequest_AuthMultiError, or nil if none found.
func (m *EmailLoginRequest_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginRequest_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = EmailLoginRequest_AuthValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EmailLoginRequest_Auth_Code_Pattern.MatchString(m.GetCode()) {
		err := EmailLoginRequest_AuthValidationError{
			field:  "Code",
			reason: "value does not match regex pattern \"^[0-9]{4,6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EmailLoginRequest_AuthMultiError(errors)
	}

	return nil
}

func (m *EmailLoginRequest_Auth) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *EmailLoginRequest_Auth) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// EmailLoginRequest_AuthMultiError is an error wrapping multiple validation
// errors returned by EmailLoginRequest_Auth.ValidateAll() if the designated
// constraints aren't met.
type EmailLoginRequest_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginRequest_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginRequest_AuthMultiError) AllErrors() []error { return m }

// EmailLoginRequest_AuthValidationError is the validation error returned by
// EmailLoginRequest_Auth.Validate if the designated constraints aren't met.
type EmailLoginRequest_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginRequest_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginRequest_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginRequest_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginRequest_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginRequest_AuthValidationError) ErrorName() string {
	return "EmailLoginRequest_AuthValidationError"
}

// Error satisfies the builtin error interface
func (e EmailLoginRequest_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginRequest_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginRequest_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginRequest_AuthValidationError{}

var _EmailLoginRequest_Auth_Code_Pattern = regexp.MustCompile("^[0-9]{4,6}$")

// Validate checks the field values on RegisterRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequest_AuthMultiError, or nil if none found.
func (m *RegisterRequest_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := RegisterRequest_AuthValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 25 {
		err := RegisterRequest_AuthValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 25 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterRequest_Auth_Phone_Pattern.MatchString(m.GetPhone()) {
		err := RegisterRequest_AuthValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterRequest_AuthMultiError(errors)
	}

	return nil
}

// RegisterRequest_AuthMultiError is an error wrapping multiple validation
// errors returned by RegisterRequest_Auth.ValidateAll() if the designated
// constraints aren't met.
type RegisterRequest_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequest_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequest_AuthMultiError) AllErrors() []error { return m }

// RegisterRequest_AuthValidationError is the validation error returned by
// RegisterRequest_Auth.Validate if the designated constraints aren't met.
type RegisterRequest_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequest_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequest_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequest_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequest_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequest_AuthValidationError) ErrorName() string {
	return "RegisterRequest_AuthValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterRequest_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequest_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequest_AuthValidationError{}

var _RegisterRequest_Auth_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

// Validate checks the field values on
// ListUserRoleMenuTreeResponseDeprecated_MenuMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeResponseDeprecated_MenuMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeResponseDeprecated_MenuMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ListUserRoleMenuTreeResponseDeprecated_MenuMetaMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeResponseDeprecated_MenuMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeResponseDeprecated_MenuMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for DynamicLevel

	// no validation rules for RealPath

	// no validation rules for IgnoreKeepAlive

	// no validation rules for Affix

	// no validation rules for Icon

	// no validation rules for FrameSrc

	// no validation rules for TransitionName

	// no validation rules for HideBreadcrumb

	// no validation rules for CarryParam

	// no validation rules for HideChildrenInMenu

	// no validation rules for CurrentActiveMenu

	// no validation rules for HideTab

	// no validation rules for HideMenu

	// no validation rules for OrderNo

	// no validation rules for IgnoreRoute

	// no validation rules for HidePathforChildren

	if len(errors) > 0 {
		return ListUserRoleMenuTreeResponseDeprecated_MenuMetaMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeResponseDeprecated_MenuMetaMultiError is an error
// wrapping multiple validation errors returned by
// ListUserRoleMenuTreeResponseDeprecated_MenuMeta.ValidateAll() if the
// designated constraints aren't met.
type ListUserRoleMenuTreeResponseDeprecated_MenuMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeResponseDeprecated_MenuMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeResponseDeprecated_MenuMetaMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError is the
// validation error returned by
// ListUserRoleMenuTreeResponseDeprecated_MenuMeta.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeResponseDeprecated_MenuMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeResponseDeprecated_MenuMetaValidationError{}

// Validate checks the field values on
// ListUserRoleMenuTreeResponseDeprecated_Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeResponseDeprecated_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeResponseDeprecated_Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListUserRoleMenuTreeResponseDeprecated_MenuMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeResponseDeprecated_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeResponseDeprecated_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Component

	// no validation rules for Redirect

	// no validation rules for FullPath

	// no validation rules for Alias

	// no validation rules for CaseSensitive

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeResponseDeprecated_MenuMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeResponseDeprecated_MenuMultiError is an error wrapping
// multiple validation errors returned by
// ListUserRoleMenuTreeResponseDeprecated_Menu.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeResponseDeprecated_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeResponseDeprecated_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeResponseDeprecated_MenuMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeResponseDeprecated_MenuValidationError is the validation
// error returned by ListUserRoleMenuTreeResponseDeprecated_Menu.Validate if
// the designated constraints aren't met.
type ListUserRoleMenuTreeResponseDeprecated_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeResponseDeprecated_MenuValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeResponseDeprecated_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeResponseDeprecated_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeResponseDeprecated_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeResponseDeprecated_MenuValidationError{}

// Validate checks the field values on MenuRouter_Meta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MenuRouter_Meta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuRouter_Meta with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MenuRouter_MetaMultiError, or nil if none found.
func (m *MenuRouter_Meta) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuRouter_Meta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	if m.IgnoreKeepAlive != nil {
		// no validation rules for IgnoreKeepAlive
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.FrameSrc != nil {
		// no validation rules for FrameSrc
	}

	if m.HideBreadcrumb != nil {
		// no validation rules for HideBreadcrumb
	}

	if m.HideMenu != nil {
		// no validation rules for HideMenu
	}

	if m.OrderNo != nil {
		// no validation rules for OrderNo
	}

	if m.CurrentActiveMenu != nil {
		// no validation rules for CurrentActiveMenu
	}

	if m.Affix != nil {
		// no validation rules for Affix
	}

	if len(errors) > 0 {
		return MenuRouter_MetaMultiError(errors)
	}

	return nil
}

// MenuRouter_MetaMultiError is an error wrapping multiple validation errors
// returned by MenuRouter_Meta.ValidateAll() if the designated constraints
// aren't met.
type MenuRouter_MetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuRouter_MetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuRouter_MetaMultiError) AllErrors() []error { return m }

// MenuRouter_MetaValidationError is the validation error returned by
// MenuRouter_Meta.Validate if the designated constraints aren't met.
type MenuRouter_MetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuRouter_MetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuRouter_MetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuRouter_MetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuRouter_MetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuRouter_MetaValidationError) ErrorName() string { return "MenuRouter_MetaValidationError" }

// Error satisfies the builtin error interface
func (e MenuRouter_MetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuRouter_Meta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuRouter_MetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuRouter_MetaValidationError{}

// Validate checks the field values on HandleUserRoleRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserRoleRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserRoleRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserRoleRequest_DataMultiError, or nil if none found.
func (m *HandleUserRoleRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserRoleRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDomainId() <= 0 {
		err := HandleUserRoleRequest_DataValidationError{
			field:  "DomainId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRoleIds()) < 1 {
		err := HandleUserRoleRequest_DataValidationError{
			field:  "RoleIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleUserRoleRequest_Data_RoleIds_Unique := make(map[uint64]struct{}, len(m.GetRoleIds()))

	for idx, item := range m.GetRoleIds() {
		_, _ = idx, item

		if _, exists := _HandleUserRoleRequest_Data_RoleIds_Unique[item]; exists {
			err := HandleUserRoleRequest_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleUserRoleRequest_Data_RoleIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleUserRoleRequest_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleUserRoleRequest_DataMultiError(errors)
	}

	return nil
}

// HandleUserRoleRequest_DataMultiError is an error wrapping multiple
// validation errors returned by HandleUserRoleRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleUserRoleRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserRoleRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserRoleRequest_DataMultiError) AllErrors() []error { return m }

// HandleUserRoleRequest_DataValidationError is the validation error returned
// by HandleUserRoleRequest_Data.Validate if the designated constraints aren't met.
type HandleUserRoleRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserRoleRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserRoleRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserRoleRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserRoleRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserRoleRequest_DataValidationError) ErrorName() string {
	return "HandleUserRoleRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserRoleRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserRoleRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserRoleRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserRoleRequest_DataValidationError{}

// Validate checks the field values on UpdateUserRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequest_DataMultiError, or nil if none found.
func (m *UpdateUserRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateUserRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateUserRequest_Data_Phone_Pattern.MatchString(m.GetPhone()) {
		err := UpdateUserRequest_DataValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateUserRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateUserRequest_Data_RoleIds_Unique := make(map[uint64]struct{}, len(m.GetRoleIds()))

	for idx, item := range m.GetRoleIds() {
		_, _ = idx, item

		if _, exists := _UpdateUserRequest_Data_RoleIds_Unique[item]; exists {
			err := UpdateUserRequest_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateUserRequest_Data_RoleIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateUserRequest_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_UpdateUserRequest_Data_PostIds_Unique := make(map[uint64]struct{}, len(m.GetPostIds()))

	for idx, item := range m.GetPostIds() {
		_, _ = idx, item

		if _, exists := _UpdateUserRequest_Data_PostIds_Unique[item]; exists {
			err := UpdateUserRequest_DataValidationError{
				field:  fmt.Sprintf("PostIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateUserRequest_Data_PostIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateUserRequest_DataValidationError{
				field:  fmt.Sprintf("PostIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetDeptId() <= 0 {
		err := UpdateUserRequest_DataValidationError{
			field:  "DeptId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Password != nil {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
			err := UpdateUserRequest_DataValidationError{
				field:  "Password",
				reason: "value length must be between 6 and 28 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NickName != nil {

		if l := utf8.RuneCountInString(m.GetNickName()); l < 1 || l > 10 {
			err := UpdateUserRequest_DataValidationError{
				field:  "NickName",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RealName != nil {

		if l := utf8.RuneCountInString(m.GetRealName()); l < 2 || l > 10 {
			err := UpdateUserRequest_DataValidationError{
				field:  "RealName",
				reason: "value length must be between 2 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Birthday != nil {

		if !_UpdateUserRequest_Data_Birthday_Pattern.MatchString(m.GetBirthday()) {
			err := UpdateUserRequest_DataValidationError{
				field:  "Birthday",
				reason: "value does not match regex pattern \"^(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Gender != nil {

		if m.GetGender() < 0 {
			err := UpdateUserRequest_DataValidationError{
				field:  "Gender",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = UpdateUserRequest_DataValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if len(errors) > 0 {
		return UpdateUserRequest_DataMultiError(errors)
	}

	return nil
}

func (m *UpdateUserRequest_Data) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UpdateUserRequest_Data) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UpdateUserRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateUserRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequest_DataMultiError) AllErrors() []error { return m }

// UpdateUserRequest_DataValidationError is the validation error returned by
// UpdateUserRequest_Data.Validate if the designated constraints aren't met.
type UpdateUserRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequest_DataValidationError) ErrorName() string {
	return "UpdateUserRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequest_DataValidationError{}

var _UpdateUserRequest_Data_Birthday_Pattern = regexp.MustCompile("^(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)$")

var _UpdateUserRequest_Data_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

// Validate checks the field values on UpdateDomainRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDomainRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Alias != nil {

		if l := utf8.RuneCountInString(m.GetAlias()); l < 1 || l > 100 {
			err := UpdateDomainRequest_DataValidationError{
				field:  "Alias",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDomainRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return UpdateDomainRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainRequest_DataValidationError is the validation error returned by
// UpdateDomainRequest_Data.Validate if the designated constraints aren't met.
type UpdateDomainRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainRequest_DataValidationError{}

// Validate checks the field values on UpdateDomainStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateRequest_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDomainStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainStateRequest_Data.ValidateAll()
// if the designated constraints aren't met.
type UpdateDomainStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainStateRequest_DataValidationError is the validation error
// returned by UpdateDomainStateRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDomainStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateRequest_DataValidationError{}

// Validate checks the field values on HandleDomainMenuRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuRequest_DataMultiError, or nil if none found.
func (m *HandleDomainMenuRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	_HandleDomainMenuRequest_Data_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _HandleDomainMenuRequest_Data_MenuIds_Unique[item]; exists {
			err := HandleDomainMenuRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleDomainMenuRequest_Data_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleDomainMenuRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuRequest_DataMultiError(errors)
	}

	return nil
}

// HandleDomainMenuRequest_DataMultiError is an error wrapping multiple
// validation errors returned by HandleDomainMenuRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleDomainMenuRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuRequest_DataMultiError) AllErrors() []error { return m }

// HandleDomainMenuRequest_DataValidationError is the validation error returned
// by HandleDomainMenuRequest_Data.Validate if the designated constraints
// aren't met.
type HandleDomainMenuRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuRequest_DataValidationError) ErrorName() string {
	return "HandleDomainMenuRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuRequest_DataValidationError{}

// Validate checks the field values on UpdateRoleRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleRequest_DataMultiError, or nil if none found.
func (m *UpdateRoleRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateRoleRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateRoleRequest_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateRoleRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateRoleRequest_Data_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _UpdateRoleRequest_Data_MenuIds_Unique[item]; exists {
			err := UpdateRoleRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateRoleRequest_Data_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateRoleRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DefaultRouter != nil {

		if l := utf8.RuneCountInString(m.GetDefaultRouter()); l < 1 || l > 100 {
			err := UpdateRoleRequest_DataValidationError{
				field:  "DefaultRouter",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateRoleRequest_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DataScope != nil {

		if m.GetDataScope() < 0 {
			err := UpdateRoleRequest_DataValidationError{
				field:  "DataScope",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MenuCheckStrictly != nil {

		if m.GetMenuCheckStrictly() < 0 {
			err := UpdateRoleRequest_DataValidationError{
				field:  "MenuCheckStrictly",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DeptCheckStrictly != nil {

		if m.GetDeptCheckStrictly() < 0 {
			err := UpdateRoleRequest_DataValidationError{
				field:  "DeptCheckStrictly",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := UpdateRoleRequest_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateRoleRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateRoleRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleRequest_DataMultiError) AllErrors() []error { return m }

// UpdateRoleRequest_DataValidationError is the validation error returned by
// UpdateRoleRequest_Data.Validate if the designated constraints aren't met.
type UpdateRoleRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleRequest_DataValidationError) ErrorName() string {
	return "UpdateRoleRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleRequest_DataValidationError{}

// Validate checks the field values on UpdateRoleStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateRequest_DataMultiError, or nil if none found.
func (m *UpdateRoleStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetState() < 0 {
		err := UpdateRoleStateRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateRoleStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateRoleStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateRoleStateRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type UpdateRoleStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateRoleStateRequest_DataValidationError is the validation error returned
// by UpdateRoleStateRequest_Data.Validate if the designated constraints
// aren't met.
type UpdateRoleStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateRequest_DataValidationError) ErrorName() string {
	return "UpdateRoleStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateRequest_DataValidationError{}

// Validate checks the field values on HandleRoleMenuRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuRequest_DataMultiError, or nil if none found.
func (m *HandleRoleMenuRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	_HandleRoleMenuRequest_Data_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _HandleRoleMenuRequest_Data_MenuIds_Unique[item]; exists {
			err := HandleRoleMenuRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleRoleMenuRequest_Data_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleRoleMenuRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleRoleMenuRequest_DataMultiError(errors)
	}

	return nil
}

// HandleRoleMenuRequest_DataMultiError is an error wrapping multiple
// validation errors returned by HandleRoleMenuRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleRoleMenuRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuRequest_DataMultiError) AllErrors() []error { return m }

// HandleRoleMenuRequest_DataValidationError is the validation error returned
// by HandleRoleMenuRequest_Data.Validate if the designated constraints aren't met.
type HandleRoleMenuRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuRequest_DataValidationError) ErrorName() string {
	return "HandleRoleMenuRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuRequest_DataValidationError{}

// Validate checks the field values on HandleRoleDataScopeRequest_DataScope
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *HandleRoleDataScopeRequest_DataScope) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleDataScopeRequest_DataScope
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// HandleRoleDataScopeRequest_DataScopeMultiError, or nil if none found.
func (m *HandleRoleDataScopeRequest_DataScope) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleDataScopeRequest_DataScope) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetScope() < 0 {
		err := HandleRoleDataScopeRequest_DataScopeValidationError{
			field:  "Scope",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleRoleDataScopeRequest_DataScope_DeptCustoms_Unique := make(map[uint64]struct{}, len(m.GetDeptCustoms()))

	for idx, item := range m.GetDeptCustoms() {
		_, _ = idx, item

		if _, exists := _HandleRoleDataScopeRequest_DataScope_DeptCustoms_Unique[item]; exists {
			err := HandleRoleDataScopeRequest_DataScopeValidationError{
				field:  fmt.Sprintf("DeptCustoms[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleRoleDataScopeRequest_DataScope_DeptCustoms_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleRoleDataScopeRequest_DataScopeValidationError{
				field:  fmt.Sprintf("DeptCustoms[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.DeptCheckStrictly != nil {

		if m.GetDeptCheckStrictly() < 0 {
			err := HandleRoleDataScopeRequest_DataScopeValidationError{
				field:  "DeptCheckStrictly",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleRoleDataScopeRequest_DataScopeMultiError(errors)
	}

	return nil
}

// HandleRoleDataScopeRequest_DataScopeMultiError is an error wrapping multiple
// validation errors returned by
// HandleRoleDataScopeRequest_DataScope.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleDataScopeRequest_DataScopeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleDataScopeRequest_DataScopeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleDataScopeRequest_DataScopeMultiError) AllErrors() []error { return m }

// HandleRoleDataScopeRequest_DataScopeValidationError is the validation error
// returned by HandleRoleDataScopeRequest_DataScope.Validate if the designated
// constraints aren't met.
type HandleRoleDataScopeRequest_DataScopeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleDataScopeRequest_DataScopeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleDataScopeRequest_DataScopeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleDataScopeRequest_DataScopeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleDataScopeRequest_DataScopeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleDataScopeRequest_DataScopeValidationError) ErrorName() string {
	return "HandleRoleDataScopeRequest_DataScopeValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleDataScopeRequest_DataScopeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleDataScopeRequest_DataScope.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleDataScopeRequest_DataScopeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleDataScopeRequest_DataScopeValidationError{}

// Validate checks the field values on UpdateMenuRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuRequest_DataMultiError, or nil if none found.
func (m *UpdateMenuRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetType() < 0 {
		err := UpdateMenuRequest_DataValidationError{
			field:  "Type",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateMenuRequest_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := UpdateMenuRequest_DataValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Path != nil {

		if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "Path",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsHidden != nil {

		if m.GetIsHidden() < 0 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "IsHidden",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Component != nil {

		if utf8.RuneCountInString(m.GetComponent()) > 100 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "Component",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Permission != nil {

		if utf8.RuneCountInString(m.GetPermission()) > 100 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "Permission",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Icon != nil {

		if l := utf8.RuneCountInString(m.GetIcon()); l < 0 || l > 100 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "Icon",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsCache != nil {

		if m.GetIsCache() < 0 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "IsCache",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkUrl != nil {

		if l := utf8.RuneCountInString(m.GetLinkUrl()); l < 0 || l > 100 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "LinkUrl",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsAffix != nil {

		if m.GetIsAffix() < 0 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "IsAffix",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkType != nil {

		if m.GetLinkType() < 0 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "LinkType",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ApiResource != nil {

		if l := utf8.RuneCountInString(m.GetApiResource()); l < 1 || l > 100 {
			err := UpdateMenuRequest_DataValidationError{
				field:  "ApiResource",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateMenuRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateMenuRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateMenuRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateMenuRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuRequest_DataMultiError) AllErrors() []error { return m }

// UpdateMenuRequest_DataValidationError is the validation error returned by
// UpdateMenuRequest_Data.Validate if the designated constraints aren't met.
type UpdateMenuRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuRequest_DataValidationError) ErrorName() string {
	return "UpdateMenuRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMenuRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuRequest_DataValidationError{}

// Validate checks the field values on UpdateDeptRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptRequest_DataMultiError, or nil if none found.
func (m *UpdateDeptRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDeptRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateDeptRequest_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdateDeptRequest_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateDeptRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := UpdateDeptRequest_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDeptRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDeptRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDeptRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDeptRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDeptRequest_DataValidationError is the validation error returned by
// UpdateDeptRequest_Data.Validate if the designated constraints aren't met.
type UpdateDeptRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptRequest_DataValidationError) ErrorName() string {
	return "UpdateDeptRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptRequest_DataValidationError{}

// Validate checks the field values on UpdateDeptStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDeptStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDeptStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDeptStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDeptStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDeptStateRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type UpdateDeptStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDeptStateRequest_DataValidationError is the validation error returned
// by UpdateDeptStateRequest_Data.Validate if the designated constraints
// aren't met.
type UpdateDeptStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDeptStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptStateRequest_DataValidationError{}

// Validate checks the field values on UpdatePostRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostRequest_DataMultiError, or nil if none found.
func (m *UpdatePostRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdatePostRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdatePostRequest_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdatePostRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
		err := UpdatePostRequest_DataValidationError{
			field:  "Remarks",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Code != nil {

		if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 10 {
			err := UpdatePostRequest_DataValidationError{
				field:  "Code",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdatePostRequest_DataMultiError(errors)
	}

	return nil
}

// UpdatePostRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdatePostRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostRequest_DataMultiError) AllErrors() []error { return m }

// UpdatePostRequest_DataValidationError is the validation error returned by
// UpdatePostRequest_Data.Validate if the designated constraints aren't met.
type UpdatePostRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostRequest_DataValidationError) ErrorName() string {
	return "UpdatePostRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostRequest_DataValidationError{}

// Validate checks the field values on UpdatePostStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateRequest_DataMultiError, or nil if none found.
func (m *UpdatePostStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdatePostStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdatePostStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdatePostStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdatePostStateRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type UpdatePostStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdatePostStateRequest_DataValidationError is the validation error returned
// by UpdatePostStateRequest_Data.Validate if the designated constraints
// aren't met.
type UpdatePostStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateRequest_DataValidationError) ErrorName() string {
	return "UpdatePostStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateRequest_DataValidationError{}

// Validate checks the field values on UpdateDictRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictRequest_DataMultiError, or nil if none found.
func (m *UpdateDictRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDictRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdateDictRequest_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateDictRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
		err := UpdateDictRequest_DataValidationError{
			field:  "Remarks",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateDictRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDictRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDictRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDictRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDictRequest_DataValidationError is the validation error returned by
// UpdateDictRequest_Data.Validate if the designated constraints aren't met.
type UpdateDictRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictRequest_DataValidationError) ErrorName() string {
	return "UpdateDictRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictRequest_DataValidationError{}

// Validate checks the field values on UpdateDictStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDictStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDictStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDictStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDictStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDictStateRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type UpdateDictStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDictStateRequest_DataValidationError is the validation error returned
// by UpdateDictStateRequest_Data.Validate if the designated constraints
// aren't met.
type UpdateDictStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDictStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictStateRequest_DataValidationError{}

// Validate checks the field values on UpdateDictDataRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictDataRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictDataRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDictDataRequest_DataMultiError, or nil if none found.
func (m *UpdateDictDataRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictDataRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLabel()); l < 1 || l > 10 {
		err := UpdateDictDataRequest_DataValidationError{
			field:  "Label",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 10 {
		err := UpdateDictDataRequest_DataValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdateDictDataRequest_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateDictDataRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := UpdateDictDataRequest_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ColorType != nil {

		if l := utf8.RuneCountInString(m.GetColorType()); l < 0 || l > 100 {
			err := UpdateDictDataRequest_DataValidationError{
				field:  "ColorType",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.CssClass != nil {

		if l := utf8.RuneCountInString(m.GetCssClass()); l < 0 || l > 100 {
			err := UpdateDictDataRequest_DataValidationError{
				field:  "CssClass",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDictDataRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDictDataRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDictDataRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type UpdateDictDataRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictDataRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictDataRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDictDataRequest_DataValidationError is the validation error returned
// by UpdateDictDataRequest_Data.Validate if the designated constraints aren't met.
type UpdateDictDataRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictDataRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictDataRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictDataRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictDataRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictDataRequest_DataValidationError) ErrorName() string {
	return "UpdateDictDataRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictDataRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictDataRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictDataRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictDataRequest_DataValidationError{}

// Validate checks the field values on UpdateDictDataStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDictDataStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDictDataStateRequest_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDictDataStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDictDataStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDictDataStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDictDataStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDictDataStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDictDataStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDictDataStateRequest_Data.ValidateAll()
// if the designated constraints aren't met.
type UpdateDictDataStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDictDataStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDictDataStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDictDataStateRequest_DataValidationError is the validation error
// returned by UpdateDictDataStateRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDictDataStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDictDataStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDictDataStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDictDataStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDictDataStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDictDataStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDictDataStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDictDataStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDictDataStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDictDataStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDictDataStateRequest_DataValidationError{}

// Validate checks the field values on UpdateDomainPackageRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageRequest_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainPackageRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateDomainPackageRequest_Data_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _UpdateDomainPackageRequest_Data_MenuIds_Unique[item]; exists {
			err := UpdateDomainPackageRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateDomainPackageRequest_Data_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateDomainPackageRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetSort() < 0 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "Remarks",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateDomainPackageRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageRequest_Data.ValidateAll()
// if the designated constraints aren't met.
type UpdateDomainPackageRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainPackageRequest_DataValidationError is the validation error
// returned by UpdateDomainPackageRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainPackageRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageRequest_DataValidationError{}

// Validate checks the field values on UpdateDomainPackageStateRequest_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateDomainPackageStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageStateRequest_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainPackageStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDomainPackageStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainPackageStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDomainPackageStateRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainPackageStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainPackageStateRequest_DataValidationError is the validation error
// returned by UpdateDomainPackageStateRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainPackageStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageStateRequest_DataValidationError{}
