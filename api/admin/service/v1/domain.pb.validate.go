// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: admin/service/v1/domain.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Domain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DomainMultiError, or nil if none found.
func (m *Domain) ValidateAll() error {
	return m.validate(true)
}

func (m *Domain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PackageId

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Alias != nil {
		// no validation rules for Alias
	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.Package != nil {

		if all {
			switch v := interface{}(m.GetPackage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "Package",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  "Package",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPackage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  "Package",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DomainMultiError(errors)
	}

	return nil
}

// DomainMultiError is an error wrapping multiple validation errors returned by
// Domain.ValidateAll() if the designated constraints aren't met.
type DomainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DomainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DomainMultiError) AllErrors() []error { return m }

// DomainValidationError is the validation error returned by Domain.Validate if
// the designated constraints aren't met.
type DomainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DomainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DomainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DomainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DomainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DomainValidationError) ErrorName() string { return "DomainValidationError" }

// Error satisfies the builtin error interface
func (e DomainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDomain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DomainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DomainValidationError{}

// Validate checks the field values on ListDomainRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainRequestMultiError, or nil if none found.
func (m *ListDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListDomainRequestMultiError(errors)
	}

	return nil
}

// ListDomainRequestMultiError is an error wrapping multiple validation errors
// returned by ListDomainRequest.ValidateAll() if the designated constraints
// aren't met.
type ListDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainRequestMultiError) AllErrors() []error { return m }

// ListDomainRequestValidationError is the validation error returned by
// ListDomainRequest.Validate if the designated constraints aren't met.
type ListDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainRequestValidationError) ErrorName() string {
	return "ListDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainRequestValidationError{}

// Validate checks the field values on ListDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainResponseMultiError, or nil if none found.
func (m *ListDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDomainResponseMultiError(errors)
	}

	return nil
}

// ListDomainResponseMultiError is an error wrapping multiple validation errors
// returned by ListDomainResponse.ValidateAll() if the designated constraints
// aren't met.
type ListDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainResponseMultiError) AllErrors() []error { return m }

// ListDomainResponseValidationError is the validation error returned by
// ListDomainResponse.Validate if the designated constraints aren't met.
type ListDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainResponseValidationError) ErrorName() string {
	return "ListDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainResponseValidationError{}

// Validate checks the field values on ListDomainTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainTreeRequestMultiError, or nil if none found.
func (m *ListDomainTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListDomainTreeRequestMultiError(errors)
	}

	return nil
}

// ListDomainTreeRequestMultiError is an error wrapping multiple validation
// errors returned by ListDomainTreeRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDomainTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainTreeRequestMultiError) AllErrors() []error { return m }

// ListDomainTreeRequestValidationError is the validation error returned by
// ListDomainTreeRequest.Validate if the designated constraints aren't met.
type ListDomainTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainTreeRequestValidationError) ErrorName() string {
	return "ListDomainTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainTreeRequestValidationError{}

// Validate checks the field values on ListDomainTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainTreeResponseMultiError, or nil if none found.
func (m *ListDomainTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainTreeResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainTreeResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDomainTreeResponseMultiError(errors)
	}

	return nil
}

// ListDomainTreeResponseMultiError is an error wrapping multiple validation
// errors returned by ListDomainTreeResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDomainTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainTreeResponseMultiError) AllErrors() []error { return m }

// ListDomainTreeResponseValidationError is the validation error returned by
// ListDomainTreeResponse.Validate if the designated constraints aren't met.
type ListDomainTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainTreeResponseValidationError) ErrorName() string {
	return "ListDomainTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainTreeResponseValidationError{}

// Validate checks the field values on CreateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainRequestMultiError, or nil if none found.
func (m *CreateDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDomainRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PackageId

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Alias != nil {

		if l := utf8.RuneCountInString(m.GetAlias()); l < 1 || l > 100 {
			err := CreateDomainRequestValidationError{
				field:  "Alias",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {

		if m.GetState() < 0 {
			err := CreateDomainRequestValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return CreateDomainRequestMultiError(errors)
	}

	return nil
}

// CreateDomainRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDomainRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainRequestMultiError) AllErrors() []error { return m }

// CreateDomainRequestValidationError is the validation error returned by
// CreateDomainRequest.Validate if the designated constraints aren't met.
type CreateDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainRequestValidationError) ErrorName() string {
	return "CreateDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainRequestValidationError{}

// Validate checks the field values on CreateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainResponseMultiError, or nil if none found.
func (m *CreateDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDomainResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDomainResponseMultiError(errors)
	}

	return nil
}

// CreateDomainResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDomainResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainResponseMultiError) AllErrors() []error { return m }

// CreateDomainResponseValidationError is the validation error returned by
// CreateDomainResponse.Validate if the designated constraints aren't met.
type CreateDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainResponseValidationError) ErrorName() string {
	return "CreateDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainResponseValidationError{}

// Validate checks the field values on UpdateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainRequestMultiError, or nil if none found.
func (m *UpdateDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainRequestMultiError) AllErrors() []error { return m }

// UpdateDomainRequestValidationError is the validation error returned by
// UpdateDomainRequest.Validate if the designated constraints aren't met.
type UpdateDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainRequestValidationError) ErrorName() string {
	return "UpdateDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainRequestValidationError{}

// Validate checks the field values on UpdateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainResponseMultiError, or nil if none found.
func (m *UpdateDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainResponseMultiError) AllErrors() []error { return m }

// UpdateDomainResponseValidationError is the validation error returned by
// UpdateDomainResponse.Validate if the designated constraints aren't met.
type UpdateDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainResponseValidationError) ErrorName() string {
	return "UpdateDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainResponseValidationError{}

// Validate checks the field values on UpdateDomainStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateRequestMultiError, or nil if none found.
func (m *UpdateDomainStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateRequestMultiError) AllErrors() []error { return m }

// UpdateDomainStateRequestValidationError is the validation error returned by
// UpdateDomainStateRequest.Validate if the designated constraints aren't met.
type UpdateDomainStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateRequestValidationError) ErrorName() string {
	return "UpdateDomainStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateRequestValidationError{}

// Validate checks the field values on UpdateDomainStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateResponseMultiError, or nil if none found.
func (m *UpdateDomainStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainStateResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateDomainStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateResponseMultiError) AllErrors() []error { return m }

// UpdateDomainStateResponseValidationError is the validation error returned by
// UpdateDomainStateResponse.Validate if the designated constraints aren't met.
type UpdateDomainStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateResponseValidationError) ErrorName() string {
	return "UpdateDomainStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateResponseValidationError{}

// Validate checks the field values on GetDomainRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainRequestMultiError, or nil if none found.
func (m *GetDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDomainRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainRequestMultiError(errors)
	}

	return nil
}

// GetDomainRequestMultiError is an error wrapping multiple validation errors
// returned by GetDomainRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainRequestMultiError) AllErrors() []error { return m }

// GetDomainRequestValidationError is the validation error returned by
// GetDomainRequest.Validate if the designated constraints aren't met.
type GetDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainRequestValidationError) ErrorName() string { return "GetDomainRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainRequestValidationError{}

// Validate checks the field values on GetDomainCodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDomainCodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainCodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainCodeRequestMultiError, or nil if none found.
func (m *GetDomainCodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainCodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCode()) != 19 {
		err := GetDomainCodeRequestValidationError{
			field:  "Code",
			reason: "value length must be 19 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return GetDomainCodeRequestMultiError(errors)
	}

	return nil
}

// GetDomainCodeRequestMultiError is an error wrapping multiple validation
// errors returned by GetDomainCodeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDomainCodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainCodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainCodeRequestMultiError) AllErrors() []error { return m }

// GetDomainCodeRequestValidationError is the validation error returned by
// GetDomainCodeRequest.Validate if the designated constraints aren't met.
type GetDomainCodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainCodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainCodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainCodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainCodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainCodeRequestValidationError) ErrorName() string {
	return "GetDomainCodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDomainCodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainCodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainCodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainCodeRequestValidationError{}

// Validate checks the field values on GetDomainNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDomainNameRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainNameRequestMultiError, or nil if none found.
func (m *GetDomainNameRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainNameRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 20 {
		err := GetDomainNameRequestValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainNameRequestMultiError(errors)
	}

	return nil
}

// GetDomainNameRequestMultiError is an error wrapping multiple validation
// errors returned by GetDomainNameRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDomainNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainNameRequestMultiError) AllErrors() []error { return m }

// GetDomainNameRequestValidationError is the validation error returned by
// GetDomainNameRequest.Validate if the designated constraints aren't met.
type GetDomainNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainNameRequestValidationError) ErrorName() string {
	return "GetDomainNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDomainNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainNameRequestValidationError{}

// Validate checks the field values on DeleteDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainRequestMultiError, or nil if none found.
func (m *DeleteDomainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDomainRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDomainRequestMultiError(errors)
	}

	return nil
}

// DeleteDomainRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDomainRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDomainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainRequestMultiError) AllErrors() []error { return m }

// DeleteDomainRequestValidationError is the validation error returned by
// DeleteDomainRequest.Validate if the designated constraints aren't met.
type DeleteDomainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainRequestValidationError) ErrorName() string {
	return "DeleteDomainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainRequestValidationError{}

// Validate checks the field values on DeleteDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainResponseMultiError, or nil if none found.
func (m *DeleteDomainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDomainResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDomainResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDomainResponseMultiError(errors)
	}

	return nil
}

// DeleteDomainResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteDomainResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteDomainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainResponseMultiError) AllErrors() []error { return m }

// DeleteDomainResponseValidationError is the validation error returned by
// DeleteDomainResponse.Validate if the designated constraints aren't met.
type DeleteDomainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainResponseValidationError) ErrorName() string {
	return "DeleteDomainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainResponseValidationError{}

// Validate checks the field values on ListDomainMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuRequestMultiError, or nil if none found.
func (m *ListDomainMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListDomainMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListDomainMenuRequestMultiError(errors)
	}

	return nil
}

// ListDomainMenuRequestMultiError is an error wrapping multiple validation
// errors returned by ListDomainMenuRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDomainMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuRequestMultiError) AllErrors() []error { return m }

// ListDomainMenuRequestValidationError is the validation error returned by
// ListDomainMenuRequest.Validate if the designated constraints aren't met.
type ListDomainMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuRequestValidationError) ErrorName() string {
	return "ListDomainMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuRequestValidationError{}

// Validate checks the field values on ListDomainMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuResponseMultiError, or nil if none found.
func (m *ListDomainMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainMenuResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainMenuResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDomainMenuResponseMultiError(errors)
	}

	return nil
}

// ListDomainMenuResponseMultiError is an error wrapping multiple validation
// errors returned by ListDomainMenuResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDomainMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuResponseMultiError) AllErrors() []error { return m }

// ListDomainMenuResponseValidationError is the validation error returned by
// ListDomainMenuResponse.Validate if the designated constraints aren't met.
type ListDomainMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuResponseValidationError) ErrorName() string {
	return "ListDomainMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuResponseValidationError{}

// Validate checks the field values on HandleDomainMenuRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuRequestMultiError, or nil if none found.
func (m *HandleDomainMenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleDomainMenuRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleDomainMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleDomainMenuRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleDomainMenuRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleDomainMenuRequestMultiError(errors)
	}

	return nil
}

// HandleDomainMenuRequestMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuRequest.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuRequestMultiError) AllErrors() []error { return m }

// HandleDomainMenuRequestValidationError is the validation error returned by
// HandleDomainMenuRequest.Validate if the designated constraints aren't met.
type HandleDomainMenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuRequestValidationError) ErrorName() string {
	return "HandleDomainMenuRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuRequestValidationError{}

// Validate checks the field values on HandleDomainMenuResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuResponseMultiError, or nil if none found.
func (m *HandleDomainMenuResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleDomainMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleDomainMenuResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleDomainMenuResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuResponseMultiError(errors)
	}

	return nil
}

// HandleDomainMenuResponseMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuResponse.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuResponseMultiError) AllErrors() []error { return m }

// HandleDomainMenuResponseValidationError is the validation error returned by
// HandleDomainMenuResponse.Validate if the designated constraints aren't met.
type HandleDomainMenuResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuResponseValidationError) ErrorName() string {
	return "HandleDomainMenuResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuResponseValidationError{}

// Validate checks the field values on DomainPackage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DomainPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DomainPackage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DomainPackageMultiError, or
// nil if none found.
func (m *DomainPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *DomainPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainPackageValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainPackageValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainPackageValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return DomainPackageMultiError(errors)
	}

	return nil
}

// DomainPackageMultiError is an error wrapping multiple validation errors
// returned by DomainPackage.ValidateAll() if the designated constraints
// aren't met.
type DomainPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DomainPackageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DomainPackageMultiError) AllErrors() []error { return m }

// DomainPackageValidationError is the validation error returned by
// DomainPackage.Validate if the designated constraints aren't met.
type DomainPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DomainPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DomainPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DomainPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DomainPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DomainPackageValidationError) ErrorName() string { return "DomainPackageValidationError" }

// Error satisfies the builtin error interface
func (e DomainPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDomainPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DomainPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DomainPackageValidationError{}

// Validate checks the field values on ListDomainPackageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainPackageRequestMultiError, or nil if none found.
func (m *ListDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Nopaging != nil {
		// no validation rules for Nopaging
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return ListDomainPackageRequestMultiError(errors)
	}

	return nil
}

// ListDomainPackageRequestMultiError is an error wrapping multiple validation
// errors returned by ListDomainPackageRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainPackageRequestMultiError) AllErrors() []error { return m }

// ListDomainPackageRequestValidationError is the validation error returned by
// ListDomainPackageRequest.Validate if the designated constraints aren't met.
type ListDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainPackageRequestValidationError) ErrorName() string {
	return "ListDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainPackageRequestValidationError{}

// Validate checks the field values on ListDomainPackageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainPackageResponseMultiError, or nil if none found.
func (m *ListDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainPackageResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainPackageResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainPackageResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDomainPackageResponseMultiError(errors)
	}

	return nil
}

// ListDomainPackageResponseMultiError is an error wrapping multiple validation
// errors returned by ListDomainPackageResponse.ValidateAll() if the
// designated constraints aren't met.
type ListDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainPackageResponseMultiError) AllErrors() []error { return m }

// ListDomainPackageResponseValidationError is the validation error returned by
// ListDomainPackageResponse.Validate if the designated constraints aren't met.
type ListDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainPackageResponseValidationError) ErrorName() string {
	return "ListDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainPackageResponseValidationError{}

// Validate checks the field values on CreateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainPackageRequestMultiError, or nil if none found.
func (m *CreateDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDomainPackageRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateDomainPackageRequest_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _CreateDomainPackageRequest_MenuIds_Unique[item]; exists {
			err := CreateDomainPackageRequestValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateDomainPackageRequest_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateDomainPackageRequestValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetSort() < 0 {
		err := CreateDomainPackageRequestValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := CreateDomainPackageRequestValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreateDomainPackageRequestValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDomainPackageRequestMultiError(errors)
	}

	return nil
}

// CreateDomainPackageRequestMultiError is an error wrapping multiple
// validation errors returned by CreateDomainPackageRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainPackageRequestMultiError) AllErrors() []error { return m }

// CreateDomainPackageRequestValidationError is the validation error returned
// by CreateDomainPackageRequest.Validate if the designated constraints aren't met.
type CreateDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainPackageRequestValidationError) ErrorName() string {
	return "CreateDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainPackageRequestValidationError{}

// Validate checks the field values on CreateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainPackageResponseMultiError, or nil if none found.
func (m *CreateDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDomainPackageResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDomainPackageResponseMultiError(errors)
	}

	return nil
}

// CreateDomainPackageResponseMultiError is an error wrapping multiple
// validation errors returned by CreateDomainPackageResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainPackageResponseMultiError) AllErrors() []error { return m }

// CreateDomainPackageResponseValidationError is the validation error returned
// by CreateDomainPackageResponse.Validate if the designated constraints
// aren't met.
type CreateDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainPackageResponseValidationError) ErrorName() string {
	return "CreateDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainPackageResponseValidationError{}

// Validate checks the field values on UpdateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageRequestMultiError, or nil if none found.
func (m *UpdateDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainPackageRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainPackageRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainPackageRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainPackageRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainPackageRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageRequestMultiError) AllErrors() []error { return m }

// UpdateDomainPackageRequestValidationError is the validation error returned
// by UpdateDomainPackageRequest.Validate if the designated constraints aren't met.
type UpdateDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageRequestValidationError) ErrorName() string {
	return "UpdateDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageRequestValidationError{}

// Validate checks the field values on UpdateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageResponseMultiError, or nil if none found.
func (m *UpdateDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainPackageResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainPackageResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageResponseMultiError) AllErrors() []error { return m }

// UpdateDomainPackageResponseValidationError is the validation error returned
// by UpdateDomainPackageResponse.Validate if the designated constraints
// aren't met.
type UpdateDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageResponseValidationError) ErrorName() string {
	return "UpdateDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageResponseValidationError{}

// Validate checks the field values on GetDomainPackageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainPackageRequestMultiError, or nil if none found.
func (m *GetDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDomainPackageRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainPackageRequestMultiError(errors)
	}

	return nil
}

// GetDomainPackageRequestMultiError is an error wrapping multiple validation
// errors returned by GetDomainPackageRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainPackageRequestMultiError) AllErrors() []error { return m }

// GetDomainPackageRequestValidationError is the validation error returned by
// GetDomainPackageRequest.Validate if the designated constraints aren't met.
type GetDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainPackageRequestValidationError) ErrorName() string {
	return "GetDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainPackageRequestValidationError{}

// Validate checks the field values on DeleteDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainPackageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainPackageRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainPackageRequestMultiError, or nil if none found.
func (m *DeleteDomainPackageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainPackageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDomainPackageRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDomainPackageRequestMultiError(errors)
	}

	return nil
}

// DeleteDomainPackageRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteDomainPackageRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteDomainPackageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainPackageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainPackageRequestMultiError) AllErrors() []error { return m }

// DeleteDomainPackageRequestValidationError is the validation error returned
// by DeleteDomainPackageRequest.Validate if the designated constraints aren't met.
type DeleteDomainPackageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainPackageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainPackageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainPackageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainPackageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainPackageRequestValidationError) ErrorName() string {
	return "DeleteDomainPackageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainPackageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainPackageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainPackageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainPackageRequestValidationError{}

// Validate checks the field values on DeleteDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainPackageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainPackageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainPackageResponseMultiError, or nil if none found.
func (m *DeleteDomainPackageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainPackageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDomainPackageResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDomainPackageResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDomainPackageResponseMultiError(errors)
	}

	return nil
}

// DeleteDomainPackageResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteDomainPackageResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteDomainPackageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainPackageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainPackageResponseMultiError) AllErrors() []error { return m }

// DeleteDomainPackageResponseValidationError is the validation error returned
// by DeleteDomainPackageResponse.Validate if the designated constraints
// aren't met.
type DeleteDomainPackageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainPackageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainPackageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainPackageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainPackageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainPackageResponseValidationError) ErrorName() string {
	return "DeleteDomainPackageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainPackageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainPackageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainPackageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainPackageResponseValidationError{}

// Validate checks the field values on UpdateDomainPackageStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageStateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageStateRequestMultiError, or nil if none found.
func (m *UpdateDomainPackageStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainPackageStateRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainPackageStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainPackageStateRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainPackageStateRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainPackageStateRequestMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageStateRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageStateRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateDomainPackageStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageStateRequestMultiError) AllErrors() []error { return m }

// UpdateDomainPackageStateRequestValidationError is the validation error
// returned by UpdateDomainPackageStateRequest.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageStateRequestValidationError) ErrorName() string {
	return "UpdateDomainPackageStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageStateRequestValidationError{}

// Validate checks the field values on UpdateDomainPackageStateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateDomainPackageStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageStateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageStateResponseMultiError, or nil if none found.
func (m *UpdateDomainPackageStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Type

	if m.Result != nil {

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDomainPackageStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDomainPackageStateResponseValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDomainPackageStateResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDomainPackageStateResponseMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageStateResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDomainPackageStateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainPackageStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageStateResponseMultiError) AllErrors() []error { return m }

// UpdateDomainPackageStateResponseValidationError is the validation error
// returned by UpdateDomainPackageStateResponse.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageStateResponseValidationError) ErrorName() string {
	return "UpdateDomainPackageStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageStateResponseValidationError{}

// Validate checks the field values on UpdateDomainRequest_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDomainRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PackageId

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Alias != nil {

		if l := utf8.RuneCountInString(m.GetAlias()); l < 1 || l > 100 {
			err := UpdateDomainRequest_DataValidationError{
				field:  "Alias",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDomainRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return UpdateDomainRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainRequest_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainRequest_DataValidationError is the validation error returned by
// UpdateDomainRequest_Data.Validate if the designated constraints aren't met.
type UpdateDomainRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainRequest_DataValidationError{}

// Validate checks the field values on UpdateDomainStateRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateRequest_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDomainStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainStateRequest_Data.ValidateAll()
// if the designated constraints aren't met.
type UpdateDomainStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainStateRequest_DataValidationError is the validation error
// returned by UpdateDomainStateRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDomainStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateRequest_DataValidationError{}

// Validate checks the field values on HandleDomainMenuRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuRequest_DataMultiError, or nil if none found.
func (m *HandleDomainMenuRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	_HandleDomainMenuRequest_Data_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _HandleDomainMenuRequest_Data_MenuIds_Unique[item]; exists {
			err := HandleDomainMenuRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleDomainMenuRequest_Data_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleDomainMenuRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuRequest_DataMultiError(errors)
	}

	return nil
}

// HandleDomainMenuRequest_DataMultiError is an error wrapping multiple
// validation errors returned by HandleDomainMenuRequest_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleDomainMenuRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuRequest_DataMultiError) AllErrors() []error { return m }

// HandleDomainMenuRequest_DataValidationError is the validation error returned
// by HandleDomainMenuRequest_Data.Validate if the designated constraints
// aren't met.
type HandleDomainMenuRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuRequest_DataValidationError) ErrorName() string {
	return "HandleDomainMenuRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuRequest_DataValidationError{}

// Validate checks the field values on UpdateDomainPackageRequest_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainPackageRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageRequest_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainPackageRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateDomainPackageRequest_Data_MenuIds_Unique := make(map[uint64]struct{}, len(m.GetMenuIds()))

	for idx, item := range m.GetMenuIds() {
		_, _ = idx, item

		if _, exists := _UpdateDomainPackageRequest_Data_MenuIds_Unique[item]; exists {
			err := UpdateDomainPackageRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateDomainPackageRequest_Data_MenuIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateDomainPackageRequest_DataValidationError{
				field:  fmt.Sprintf("MenuIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetSort() < 0 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetState() < 0 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "State",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
		err := UpdateDomainPackageRequest_DataValidationError{
			field:  "Remarks",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateDomainPackageRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageRequest_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateDomainPackageRequest_Data.ValidateAll()
// if the designated constraints aren't met.
type UpdateDomainPackageRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainPackageRequest_DataValidationError is the validation error
// returned by UpdateDomainPackageRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainPackageRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageRequest_DataValidationError{}

// Validate checks the field values on UpdateDomainPackageStateRequest_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateDomainPackageStateRequest_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainPackageStateRequest_Data
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateDomainPackageStateRequest_DataMultiError, or nil if none found.
func (m *UpdateDomainPackageStateRequest_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainPackageStateRequest_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if m.GetState() < 0 {
			err := UpdateDomainPackageStateRequest_DataValidationError{
				field:  "State",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainPackageStateRequest_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainPackageStateRequest_DataMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDomainPackageStateRequest_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainPackageStateRequest_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainPackageStateRequest_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainPackageStateRequest_DataMultiError) AllErrors() []error { return m }

// UpdateDomainPackageStateRequest_DataValidationError is the validation error
// returned by UpdateDomainPackageStateRequest_Data.Validate if the designated
// constraints aren't met.
type UpdateDomainPackageStateRequest_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainPackageStateRequest_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainPackageStateRequest_DataValidationError) ErrorName() string {
	return "UpdateDomainPackageStateRequest_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainPackageStateRequest_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainPackageStateRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainPackageStateRequest_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainPackageStateRequest_DataValidationError{}
