// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: server/v1/api.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	protobuf "github.com/beiduoke/go-scaffold/api/protobuf"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = protobuf.PostState(0)
)

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on RegisterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReplyMultiError, or
// nil if none found.
func (m *RegisterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return RegisterReplyMultiError(errors)
	}

	return nil
}

// RegisterReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReplyMultiError) AllErrors() []error { return m }

// RegisterReplyValidationError is the validation error returned by
// RegisterReply.Validate if the designated constraints aren't met.
type RegisterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReplyValidationError) ErrorName() string { return "RegisterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReplyValidationError{}

// Validate checks the field values on LogoutReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutReplyMultiError, or
// nil if none found.
func (m *LogoutReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogoutReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogoutReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogoutReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return LogoutReplyMultiError(errors)
	}

	return nil
}

// LogoutReplyMultiError is an error wrapping multiple validation errors
// returned by LogoutReply.ValidateAll() if the designated constraints aren't met.
type LogoutReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutReplyMultiError) AllErrors() []error { return m }

// LogoutReplyValidationError is the validation error returned by
// LogoutReply.Validate if the designated constraints aren't met.
type LogoutReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutReplyValidationError) ErrorName() string { return "LogoutReplyValidationError" }

// Error satisfies the builtin error interface
func (e LogoutReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutReplyValidationError{}

// Validate checks the field values on LoginReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReqMultiError, or nil
// if none found.
func (m *LoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := LoginReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := LoginReqValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginReqMultiError(errors)
	}

	return nil
}

// LoginReqMultiError is an error wrapping multiple validation errors returned
// by LoginReq.ValidateAll() if the designated constraints aren't met.
type LoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReqMultiError) AllErrors() []error { return m }

// LoginReqValidationError is the validation error returned by
// LoginReq.Validate if the designated constraints aren't met.
type LoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReqValidationError) ErrorName() string { return "LoginReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReqValidationError{}

// Validate checks the field values on SmsLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SmsLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SmsLoginReqMultiError, or
// nil if none found.
func (m *SmsLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := SmsLoginReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmsLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmsLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmsLoginReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := SmsLoginReqValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SmsLoginReqMultiError(errors)
	}

	return nil
}

// SmsLoginReqMultiError is an error wrapping multiple validation errors
// returned by SmsLoginReq.ValidateAll() if the designated constraints aren't met.
type SmsLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginReqMultiError) AllErrors() []error { return m }

// SmsLoginReqValidationError is the validation error returned by
// SmsLoginReq.Validate if the designated constraints aren't met.
type SmsLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginReqValidationError) ErrorName() string { return "SmsLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e SmsLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginReqValidationError{}

// Validate checks the field values on EmailLoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailLoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailLoginReqMultiError, or
// nil if none found.
func (m *EmailLoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := EmailLoginReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailLoginReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailLoginReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := EmailLoginReqValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EmailLoginReqMultiError(errors)
	}

	return nil
}

// EmailLoginReqMultiError is an error wrapping multiple validation errors
// returned by EmailLoginReq.ValidateAll() if the designated constraints
// aren't met.
type EmailLoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginReqMultiError) AllErrors() []error { return m }

// EmailLoginReqValidationError is the validation error returned by
// EmailLoginReq.Validate if the designated constraints aren't met.
type EmailLoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginReqValidationError) ErrorName() string { return "EmailLoginReqValidationError" }

// Error satisfies the builtin error interface
func (e EmailLoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginReqValidationError{}

// Validate checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReqMultiError, or
// nil if none found.
func (m *RegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuth() == nil {
		err := RegisterReqValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterReqValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterReqValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDomain()); l < 1 || l > 20 {
		err := RegisterReqValidationError{
			field:  "Domain",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterReqMultiError(errors)
	}

	return nil
}

// RegisterReqMultiError is an error wrapping multiple validation errors
// returned by RegisterReq.ValidateAll() if the designated constraints aren't met.
type RegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReqMultiError) AllErrors() []error { return m }

// RegisterReqValidationError is the validation error returned by
// RegisterReq.Validate if the designated constraints aren't met.
type RegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReqValidationError) ErrorName() string { return "RegisterReqValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReqValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for NickName

	// no validation rules for RealName

	// no validation rules for Birthday

	// no validation rules for Gender

	// no validation rules for Phone

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on GetUserInfoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoReplyMultiError, or nil if none found.
func (m *GetUserInfoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserInfoReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserInfoReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserInfoReplyValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Name

	// no validation rules for NickName

	// no validation rules for RealName

	// no validation rules for Birthday

	// no validation rules for Gender

	// no validation rules for Phone

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for State

	if len(errors) > 0 {
		return GetUserInfoReplyMultiError(errors)
	}

	return nil
}

// GetUserInfoReplyMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoReply.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoReplyMultiError) AllErrors() []error { return m }

// GetUserInfoReplyValidationError is the validation error returned by
// GetUserInfoReply.Validate if the designated constraints aren't met.
type GetUserInfoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoReplyValidationError) ErrorName() string { return "GetUserInfoReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetUserInfoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoReplyValidationError{}

// Validate checks the field values on GetUserProfileReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileReplyMultiError, or nil if none found.
func (m *GetUserProfileReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserProfileReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserProfileReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserProfileReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserProfileReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserProfileReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserProfileReplyValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserProfileReplyMultiError(errors)
	}

	return nil
}

// GetUserProfileReplyMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileReply.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileReplyMultiError) AllErrors() []error { return m }

// GetUserProfileReplyValidationError is the validation error returned by
// GetUserProfileReply.Validate if the designated constraints aren't met.
type GetUserProfileReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileReplyValidationError) ErrorName() string {
	return "GetUserProfileReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileReplyValidationError{}

// Validate checks the field values on ListUserRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleReplyMultiError, or nil if none found.
func (m *ListUserRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleReplyMultiError(errors)
	}

	return nil
}

// ListUserRoleReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserRoleReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleReplyMultiError) AllErrors() []error { return m }

// ListUserRoleReplyValidationError is the validation error returned by
// ListUserRoleReply.Validate if the designated constraints aren't met.
type ListUserRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleReplyValidationError) ErrorName() string {
	return "ListUserRoleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleReplyValidationError{}

// Validate checks the field values on ListUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListUserReplyMultiError, or
// nil if none found.
func (m *ListUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserReplyMultiError(errors)
	}

	return nil
}

// ListUserReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserReplyMultiError) AllErrors() []error { return m }

// ListUserReplyValidationError is the validation error returned by
// ListUserReply.Validate if the designated constraints aren't met.
type ListUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserReplyValidationError) ErrorName() string { return "ListUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserReplyValidationError{}

// Validate checks the field values on ListUserRoleMenuRouterTreeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuRouterTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuRouterTreeReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuRouterTreeReqMultiError, or nil if none found.
func (m *ListUserRoleMenuRouterTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuRouterTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleId

	if len(errors) > 0 {
		return ListUserRoleMenuRouterTreeReqMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuRouterTreeReqMultiError is an error wrapping multiple
// validation errors returned by ListUserRoleMenuRouterTreeReq.ValidateAll()
// if the designated constraints aren't met.
type ListUserRoleMenuRouterTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuRouterTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuRouterTreeReqMultiError) AllErrors() []error { return m }

// ListUserRoleMenuRouterTreeReqValidationError is the validation error
// returned by ListUserRoleMenuRouterTreeReq.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuRouterTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuRouterTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuRouterTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuRouterTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuRouterTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuRouterTreeReqValidationError) ErrorName() string {
	return "ListUserRoleMenuRouterTreeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuRouterTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuRouterTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuRouterTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuRouterTreeReqValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReply_Deprecated
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListUserRoleMenuTreeReply_Deprecated) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReply_Deprecated
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_DeprecatedMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Deprecated) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Deprecated) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_DeprecatedValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_DeprecatedValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReply_DeprecatedValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_DeprecatedMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_DeprecatedMultiError is an error wrapping multiple
// validation errors returned by
// ListUserRoleMenuTreeReply_Deprecated.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_DeprecatedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_DeprecatedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_DeprecatedMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_DeprecatedValidationError is the validation error
// returned by ListUserRoleMenuTreeReply_Deprecated.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_DeprecatedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_DeprecatedValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_DeprecatedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Deprecated.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_DeprecatedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_DeprecatedValidationError{}

// Validate checks the field values on MenuRouter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuRouter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuRouter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuRouterMultiError, or
// nil if none found.
func (m *MenuRouter) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuRouter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Component

	// no validation rules for Redirect

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuRouterValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuRouterValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuRouterValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuRouterValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuRouterValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuRouterValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if len(errors) > 0 {
		return MenuRouterMultiError(errors)
	}

	return nil
}

// MenuRouterMultiError is an error wrapping multiple validation errors
// returned by MenuRouter.ValidateAll() if the designated constraints aren't met.
type MenuRouterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuRouterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuRouterMultiError) AllErrors() []error { return m }

// MenuRouterValidationError is the validation error returned by
// MenuRouter.Validate if the designated constraints aren't met.
type MenuRouterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuRouterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuRouterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuRouterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuRouterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuRouterValidationError) ErrorName() string { return "MenuRouterValidationError" }

// Error satisfies the builtin error interface
func (e MenuRouterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuRouter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuRouterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuRouterValidationError{}

// Validate checks the field values on ListUserRoleMenuRouterTreeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuRouterTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuRouterTreeReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuRouterTreeReplyMultiError, or nil if none found.
func (m *ListUserRoleMenuRouterTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuRouterTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuRouterTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuRouterTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuRouterTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleMenuRouterTreeReplyMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuRouterTreeReplyMultiError is an error wrapping multiple
// validation errors returned by ListUserRoleMenuRouterTreeReply.ValidateAll()
// if the designated constraints aren't met.
type ListUserRoleMenuRouterTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuRouterTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuRouterTreeReplyMultiError) AllErrors() []error { return m }

// ListUserRoleMenuRouterTreeReplyValidationError is the validation error
// returned by ListUserRoleMenuRouterTreeReply.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuRouterTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuRouterTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuRouterTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuRouterTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuRouterTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuRouterTreeReplyValidationError) ErrorName() string {
	return "ListUserRoleMenuRouterTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuRouterTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuRouterTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuRouterTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuRouterTreeReplyValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReqMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRoleMenuTreeReqValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReqMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReqMultiError is an error wrapping multiple validation
// errors returned by ListUserRoleMenuTreeReq.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReqMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReqValidationError is the validation error returned by
// ListUserRoleMenuTreeReq.Validate if the designated constraints aren't met.
type ListUserRoleMenuTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReqValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReqValidationError{}

// Validate checks the field values on ListUserRoleMenuTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRoleMenuTreeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRoleMenuTreeReplyMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReplyMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReplyMultiError is an error wrapping multiple validation
// errors returned by ListUserRoleMenuTreeReply.ValidateAll() if the
// designated constraints aren't met.
type ListUserRoleMenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReplyMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReplyValidationError is the validation error returned by
// ListUserRoleMenuTreeReply.Validate if the designated constraints aren't met.
type ListUserRoleMenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReplyValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReplyValidationError{}

// Validate checks the field values on ListUserRolePermissionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRolePermissionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRolePermissionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRolePermissionReqMultiError, or nil if none found.
func (m *ListUserRolePermissionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRolePermissionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() < 0 {
		err := ListUserRolePermissionReqValidationError{
			field:  "RoleId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUserRolePermissionReqMultiError(errors)
	}

	return nil
}

// ListUserRolePermissionReqMultiError is an error wrapping multiple validation
// errors returned by ListUserRolePermissionReq.ValidateAll() if the
// designated constraints aren't met.
type ListUserRolePermissionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRolePermissionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRolePermissionReqMultiError) AllErrors() []error { return m }

// ListUserRolePermissionReqValidationError is the validation error returned by
// ListUserRolePermissionReq.Validate if the designated constraints aren't met.
type ListUserRolePermissionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRolePermissionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRolePermissionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRolePermissionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRolePermissionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRolePermissionReqValidationError) ErrorName() string {
	return "ListUserRolePermissionReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRolePermissionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRolePermissionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRolePermissionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRolePermissionReqValidationError{}

// Validate checks the field values on ListUserRolePermissionReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserRolePermissionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserRolePermissionReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserRolePermissionReplyMultiError, or nil if none found.
func (m *ListUserRolePermissionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRolePermissionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListUserRolePermissionReplyMultiError(errors)
	}

	return nil
}

// ListUserRolePermissionReplyMultiError is an error wrapping multiple
// validation errors returned by ListUserRolePermissionReply.ValidateAll() if
// the designated constraints aren't met.
type ListUserRolePermissionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRolePermissionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRolePermissionReplyMultiError) AllErrors() []error { return m }

// ListUserRolePermissionReplyValidationError is the validation error returned
// by ListUserRolePermissionReply.Validate if the designated constraints
// aren't met.
type ListUserRolePermissionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRolePermissionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRolePermissionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRolePermissionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRolePermissionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRolePermissionReplyValidationError) ErrorName() string {
	return "ListUserRolePermissionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRolePermissionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRolePermissionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRolePermissionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRolePermissionReplyValidationError{}

// Validate checks the field values on CreateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateUserReqMultiError, or
// nil if none found.
func (m *CreateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateUserReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateUserReq_Phone_Pattern.MatchString(m.GetPhone()) {
		err := CreateUserReqValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateUserReq_State_NotInLookup[m.GetState()]; ok {
		err := CreateUserReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.UserState_name[int32(m.GetState())]; !ok {
		err := CreateUserReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if m.Password != nil {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
			err := CreateUserReqValidationError{
				field:  "Password",
				reason: "value length must be between 6 and 28 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NickName != nil {

		if l := utf8.RuneCountInString(m.GetNickName()); l < 1 || l > 10 {
			err := CreateUserReqValidationError{
				field:  "NickName",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RealName != nil {

		if l := utf8.RuneCountInString(m.GetRealName()); l < 2 || l > 10 {
			err := CreateUserReqValidationError{
				field:  "RealName",
				reason: "value length must be between 2 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Birthday != nil {

		if !_CreateUserReq_Birthday_Pattern.MatchString(m.GetBirthday()) {
			err := CreateUserReqValidationError{
				field:  "Birthday",
				reason: "value does not match regex pattern \"^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Gender != nil {

		if _, ok := _CreateUserReq_Gender_NotInLookup[m.GetGender()]; ok {
			err := CreateUserReqValidationError{
				field:  "Gender",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.UserGender_name[int32(m.GetGender())]; !ok {
			err := CreateUserReqValidationError{
				field:  "Gender",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = CreateUserReqValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateUserReqMultiError(errors)
	}

	return nil
}

func (m *CreateUserReq) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserReq) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserReqMultiError is an error wrapping multiple validation errors
// returned by CreateUserReq.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReqMultiError) AllErrors() []error { return m }

// CreateUserReqValidationError is the validation error returned by
// CreateUserReq.Validate if the designated constraints aren't met.
type CreateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReqValidationError) ErrorName() string { return "CreateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReqValidationError{}

var _CreateUserReq_Birthday_Pattern = regexp.MustCompile("^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$")

var _CreateUserReq_Gender_NotInLookup = map[protobuf.UserGender]struct{}{
	0: {},
}

var _CreateUserReq_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _CreateUserReq_State_NotInLookup = map[protobuf.UserState]struct{}{
	0: {},
}

// Validate checks the field values on CreateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserReplyMultiError, or nil if none found.
func (m *CreateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreateUserReplyMultiError(errors)
	}

	return nil
}

// CreateUserReplyMultiError is an error wrapping multiple validation errors
// returned by CreateUserReply.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReplyMultiError) AllErrors() []error { return m }

// CreateUserReplyValidationError is the validation error returned by
// CreateUserReply.Validate if the designated constraints aren't met.
type CreateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReplyValidationError) ErrorName() string { return "CreateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReplyValidationError{}

// Validate checks the field values on HandleUserRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HandleUserRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserRoleReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserRoleReqMultiError, or nil if none found.
func (m *HandleUserRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleUserRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleUserRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleUserRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleUserRoleReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleUserRoleReqMultiError(errors)
	}

	return nil
}

// HandleUserRoleReqMultiError is an error wrapping multiple validation errors
// returned by HandleUserRoleReq.ValidateAll() if the designated constraints
// aren't met.
type HandleUserRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserRoleReqMultiError) AllErrors() []error { return m }

// HandleUserRoleReqValidationError is the validation error returned by
// HandleUserRoleReq.Validate if the designated constraints aren't met.
type HandleUserRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserRoleReqValidationError) ErrorName() string {
	return "HandleUserRoleReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserRoleReqValidationError{}

// Validate checks the field values on HandleUserRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserRoleReplyMultiError, or nil if none found.
func (m *HandleUserRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleUserRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleUserRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleUserRoleReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return HandleUserRoleReplyMultiError(errors)
	}

	return nil
}

// HandleUserRoleReplyMultiError is an error wrapping multiple validation
// errors returned by HandleUserRoleReply.ValidateAll() if the designated
// constraints aren't met.
type HandleUserRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserRoleReplyMultiError) AllErrors() []error { return m }

// HandleUserRoleReplyValidationError is the validation error returned by
// HandleUserRoleReply.Validate if the designated constraints aren't met.
type HandleUserRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserRoleReplyValidationError) ErrorName() string {
	return "HandleUserRoleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserRoleReplyValidationError{}

// Validate checks the field values on GetUserReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserReqMultiError, or
// nil if none found.
func (m *GetUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetUserReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserReqMultiError(errors)
	}

	return nil
}

// GetUserReqMultiError is an error wrapping multiple validation errors
// returned by GetUserReq.ValidateAll() if the designated constraints aren't met.
type GetUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserReqMultiError) AllErrors() []error { return m }

// GetUserReqValidationError is the validation error returned by
// GetUserReq.Validate if the designated constraints aren't met.
type GetUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserReqValidationError) ErrorName() string { return "GetUserReqValidationError" }

// Error satisfies the builtin error interface
func (e GetUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserReqValidationError{}

// Validate checks the field values on DeleteUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteUserReqMultiError, or
// nil if none found.
func (m *DeleteUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteUserReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteUserReqMultiError(errors)
	}

	return nil
}

// DeleteUserReqMultiError is an error wrapping multiple validation errors
// returned by DeleteUserReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserReqMultiError) AllErrors() []error { return m }

// DeleteUserReqValidationError is the validation error returned by
// DeleteUserReq.Validate if the designated constraints aren't met.
type DeleteUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserReqValidationError) ErrorName() string { return "DeleteUserReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserReqValidationError{}

// Validate checks the field values on DeleteUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserReplyMultiError, or nil if none found.
func (m *DeleteUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteUserReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteUserReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteUserReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteUserReplyMultiError(errors)
	}

	return nil
}

// DeleteUserReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteUserReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserReplyMultiError) AllErrors() []error { return m }

// DeleteUserReplyValidationError is the validation error returned by
// DeleteUserReply.Validate if the designated constraints aren't met.
type DeleteUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserReplyValidationError) ErrorName() string { return "DeleteUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserReplyValidationError{}

// Validate checks the field values on UpdateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateUserReqMultiError, or
// nil if none found.
func (m *UpdateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateUserReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserReqMultiError(errors)
	}

	return nil
}

// UpdateUserReqMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReqMultiError) AllErrors() []error { return m }

// UpdateUserReqValidationError is the validation error returned by
// UpdateUserReq.Validate if the designated constraints aren't met.
type UpdateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReqValidationError) ErrorName() string { return "UpdateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReqValidationError{}

// Validate checks the field values on UpdateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserReplyMultiError, or nil if none found.
func (m *UpdateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateUserReplyMultiError(errors)
	}

	return nil
}

// UpdateUserReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReplyMultiError) AllErrors() []error { return m }

// UpdateUserReplyValidationError is the validation error returned by
// UpdateUserReply.Validate if the designated constraints aren't met.
type UpdateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReplyValidationError) ErrorName() string { return "UpdateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReplyValidationError{}

// Validate checks the field values on UserMenuTreeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserMenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMenuTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserMenuTreeReplyMultiError, or nil if none found.
func (m *UserMenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserMenuTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return UserMenuTreeReplyMultiError(errors)
	}

	return nil
}

// UserMenuTreeReplyMultiError is an error wrapping multiple validation errors
// returned by UserMenuTreeReply.ValidateAll() if the designated constraints
// aren't met.
type UserMenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMenuTreeReplyMultiError) AllErrors() []error { return m }

// UserMenuTreeReplyValidationError is the validation error returned by
// UserMenuTreeReply.Validate if the designated constraints aren't met.
type UserMenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMenuTreeReplyValidationError) ErrorName() string {
	return "UserMenuTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UserMenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMenuTreeReplyValidationError{}

// Validate checks the field values on ExistUserNameReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExistUserNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistUserNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistUserNameReqMultiError, or nil if none found.
func (m *ExistUserNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistUserNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ExistUserNameReqMultiError(errors)
	}

	return nil
}

// ExistUserNameReqMultiError is an error wrapping multiple validation errors
// returned by ExistUserNameReq.ValidateAll() if the designated constraints
// aren't met.
type ExistUserNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistUserNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistUserNameReqMultiError) AllErrors() []error { return m }

// ExistUserNameReqValidationError is the validation error returned by
// ExistUserNameReq.Validate if the designated constraints aren't met.
type ExistUserNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistUserNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistUserNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistUserNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistUserNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistUserNameReqValidationError) ErrorName() string { return "ExistUserNameReqValidationError" }

// Error satisfies the builtin error interface
func (e ExistUserNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistUserNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistUserNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistUserNameReqValidationError{}

// Validate checks the field values on ExistUserNameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExistUserNameReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExistUserNameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExistUserNameReplyMultiError, or nil if none found.
func (m *ExistUserNameReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ExistUserNameReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExistUserNameReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExistUserNameReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExistUserNameReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return ExistUserNameReplyMultiError(errors)
	}

	return nil
}

// ExistUserNameReplyMultiError is an error wrapping multiple validation errors
// returned by ExistUserNameReply.ValidateAll() if the designated constraints
// aren't met.
type ExistUserNameReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistUserNameReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistUserNameReplyMultiError) AllErrors() []error { return m }

// ExistUserNameReplyValidationError is the validation error returned by
// ExistUserNameReply.Validate if the designated constraints aren't met.
type ExistUserNameReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistUserNameReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistUserNameReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistUserNameReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistUserNameReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistUserNameReplyValidationError) ErrorName() string {
	return "ExistUserNameReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ExistUserNameReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistUserNameReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistUserNameReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistUserNameReplyValidationError{}

// Validate checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Domain) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Domain with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DomainMultiError, or nil if none found.
func (m *Domain) ValidateAll() error {
	return m.validate(true)
}

func (m *Domain) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DomainValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DomainValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DomainValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for Code

	// no validation rules for Sort

	// no validation rules for Title

	// no validation rules for Logo

	// no validation rules for Pic

	// no validation rules for Keywords

	// no validation rules for Description

	// no validation rules for State

	// no validation rules for Remarks

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DomainValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DomainValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DomainMultiError(errors)
	}

	return nil
}

// DomainMultiError is an error wrapping multiple validation errors returned by
// Domain.ValidateAll() if the designated constraints aren't met.
type DomainMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DomainMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DomainMultiError) AllErrors() []error { return m }

// DomainValidationError is the validation error returned by Domain.Validate if
// the designated constraints aren't met.
type DomainValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DomainValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DomainValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DomainValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DomainValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DomainValidationError) ErrorName() string { return "DomainValidationError" }

// Error satisfies the builtin error interface
func (e DomainValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDomain.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DomainValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DomainValidationError{}

// Validate checks the field values on ListDomainTreeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDomainTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainTreeReqMultiError, or nil if none found.
func (m *ListDomainTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListDomainTreeReqMultiError(errors)
	}

	return nil
}

// ListDomainTreeReqMultiError is an error wrapping multiple validation errors
// returned by ListDomainTreeReq.ValidateAll() if the designated constraints
// aren't met.
type ListDomainTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainTreeReqMultiError) AllErrors() []error { return m }

// ListDomainTreeReqValidationError is the validation error returned by
// ListDomainTreeReq.Validate if the designated constraints aren't met.
type ListDomainTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainTreeReqValidationError) ErrorName() string {
	return "ListDomainTreeReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainTreeReqValidationError{}

// Validate checks the field values on ListDomainTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainTreeReplyMultiError, or nil if none found.
func (m *ListDomainTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDomainTreeReplyMultiError(errors)
	}

	return nil
}

// ListDomainTreeReplyMultiError is an error wrapping multiple validation
// errors returned by ListDomainTreeReply.ValidateAll() if the designated
// constraints aren't met.
type ListDomainTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainTreeReplyMultiError) AllErrors() []error { return m }

// ListDomainTreeReplyValidationError is the validation error returned by
// ListDomainTreeReply.Validate if the designated constraints aren't met.
type ListDomainTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainTreeReplyValidationError) ErrorName() string {
	return "ListDomainTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainTreeReplyValidationError{}

// Validate checks the field values on CreateDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainReqMultiError, or nil if none found.
func (m *CreateDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDomainReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Title != nil {

		if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
			err := CreateDomainReqValidationError{
				field:  "Title",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {

		if _, ok := _CreateDomainReq_State_NotInLookup[m.GetState()]; ok {
			err := CreateDomainReqValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.DomainState_name[int32(m.GetState())]; !ok {
			err := CreateDomainReqValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return CreateDomainReqMultiError(errors)
	}

	return nil
}

// CreateDomainReqMultiError is an error wrapping multiple validation errors
// returned by CreateDomainReq.ValidateAll() if the designated constraints
// aren't met.
type CreateDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainReqMultiError) AllErrors() []error { return m }

// CreateDomainReqValidationError is the validation error returned by
// CreateDomainReq.Validate if the designated constraints aren't met.
type CreateDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainReqValidationError) ErrorName() string { return "CreateDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainReqValidationError{}

var _CreateDomainReq_State_NotInLookup = map[protobuf.DomainState]struct{}{
	0: {},
}

// Validate checks the field values on CreateDomainReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDomainReplyMultiError, or nil if none found.
func (m *CreateDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDomainReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDomainReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDomainReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreateDomainReplyMultiError(errors)
	}

	return nil
}

// CreateDomainReplyMultiError is an error wrapping multiple validation errors
// returned by CreateDomainReply.ValidateAll() if the designated constraints
// aren't met.
type CreateDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDomainReplyMultiError) AllErrors() []error { return m }

// CreateDomainReplyValidationError is the validation error returned by
// CreateDomainReply.Validate if the designated constraints aren't met.
type CreateDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDomainReplyValidationError) ErrorName() string {
	return "CreateDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDomainReplyValidationError{}

// Validate checks the field values on UpdateDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainReqMultiError, or nil if none found.
func (m *UpdateDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainReqMultiError(errors)
	}

	return nil
}

// UpdateDomainReqMultiError is an error wrapping multiple validation errors
// returned by UpdateDomainReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainReqMultiError) AllErrors() []error { return m }

// UpdateDomainReqValidationError is the validation error returned by
// UpdateDomainReq.Validate if the designated constraints aren't met.
type UpdateDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainReqValidationError) ErrorName() string { return "UpdateDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainReqValidationError{}

// Validate checks the field values on UpdateDomainReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainReplyMultiError, or nil if none found.
func (m *UpdateDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateDomainReplyMultiError(errors)
	}

	return nil
}

// UpdateDomainReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateDomainReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainReplyMultiError) AllErrors() []error { return m }

// UpdateDomainReplyValidationError is the validation error returned by
// UpdateDomainReply.Validate if the designated constraints aren't met.
type UpdateDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainReplyValidationError) ErrorName() string {
	return "UpdateDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainReplyValidationError{}

// Validate checks the field values on UpdateDomainStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateReqMultiError, or nil if none found.
func (m *UpdateDomainStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDomainStateReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainStateReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDomainStateReqMultiError(errors)
	}

	return nil
}

// UpdateDomainStateReqMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateReqMultiError) AllErrors() []error { return m }

// UpdateDomainStateReqValidationError is the validation error returned by
// UpdateDomainStateReq.Validate if the designated constraints aren't met.
type UpdateDomainStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateReqValidationError) ErrorName() string {
	return "UpdateDomainStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateReqValidationError{}

// Validate checks the field values on UpdateDomainStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateReplyMultiError, or nil if none found.
func (m *UpdateDomainStateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDomainStateReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDomainStateReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDomainStateReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateDomainStateReplyMultiError(errors)
	}

	return nil
}

// UpdateDomainStateReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainStateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateReplyMultiError) AllErrors() []error { return m }

// UpdateDomainStateReplyValidationError is the validation error returned by
// UpdateDomainStateReply.Validate if the designated constraints aren't met.
type UpdateDomainStateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateReplyValidationError) ErrorName() string {
	return "UpdateDomainStateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateReplyValidationError{}

// Validate checks the field values on GetDomainReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetDomainReqMultiError, or
// nil if none found.
func (m *GetDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainReqMultiError(errors)
	}

	return nil
}

// GetDomainReqMultiError is an error wrapping multiple validation errors
// returned by GetDomainReq.ValidateAll() if the designated constraints aren't met.
type GetDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainReqMultiError) AllErrors() []error { return m }

// GetDomainReqValidationError is the validation error returned by
// GetDomainReq.Validate if the designated constraints aren't met.
type GetDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainReqValidationError) ErrorName() string { return "GetDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainReqValidationError{}

// Validate checks the field values on GetDomainCodeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDomainCodeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainCodeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainCodeReqMultiError, or nil if none found.
func (m *GetDomainCodeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainCodeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetCode()) != 19 {
		err := GetDomainCodeReqValidationError{
			field:  "Code",
			reason: "value length must be 19 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return GetDomainCodeReqMultiError(errors)
	}

	return nil
}

// GetDomainCodeReqMultiError is an error wrapping multiple validation errors
// returned by GetDomainCodeReq.ValidateAll() if the designated constraints
// aren't met.
type GetDomainCodeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainCodeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainCodeReqMultiError) AllErrors() []error { return m }

// GetDomainCodeReqValidationError is the validation error returned by
// GetDomainCodeReq.Validate if the designated constraints aren't met.
type GetDomainCodeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainCodeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainCodeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainCodeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainCodeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainCodeReqValidationError) ErrorName() string { return "GetDomainCodeReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDomainCodeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainCodeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainCodeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainCodeReqValidationError{}

// Validate checks the field values on GetDomainNameReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDomainNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDomainNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDomainNameReqMultiError, or nil if none found.
func (m *GetDomainNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDomainNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 20 {
		err := GetDomainNameReqValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDomainNameReqMultiError(errors)
	}

	return nil
}

// GetDomainNameReqMultiError is an error wrapping multiple validation errors
// returned by GetDomainNameReq.ValidateAll() if the designated constraints
// aren't met.
type GetDomainNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDomainNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDomainNameReqMultiError) AllErrors() []error { return m }

// GetDomainNameReqValidationError is the validation error returned by
// GetDomainNameReq.Validate if the designated constraints aren't met.
type GetDomainNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDomainNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDomainNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDomainNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDomainNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDomainNameReqValidationError) ErrorName() string { return "GetDomainNameReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDomainNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDomainNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDomainNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDomainNameReqValidationError{}

// Validate checks the field values on DeleteDomainReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainReqMultiError, or nil if none found.
func (m *DeleteDomainReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDomainReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDomainReqMultiError(errors)
	}

	return nil
}

// DeleteDomainReqMultiError is an error wrapping multiple validation errors
// returned by DeleteDomainReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteDomainReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainReqMultiError) AllErrors() []error { return m }

// DeleteDomainReqValidationError is the validation error returned by
// DeleteDomainReq.Validate if the designated constraints aren't met.
type DeleteDomainReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainReqValidationError) ErrorName() string { return "DeleteDomainReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteDomainReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainReqValidationError{}

// Validate checks the field values on DeleteDomainReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDomainReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDomainReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDomainReplyMultiError, or nil if none found.
func (m *DeleteDomainReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDomainReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDomainReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDomainReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDomainReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteDomainReplyMultiError(errors)
	}

	return nil
}

// DeleteDomainReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteDomainReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteDomainReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDomainReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDomainReplyMultiError) AllErrors() []error { return m }

// DeleteDomainReplyValidationError is the validation error returned by
// DeleteDomainReply.Validate if the designated constraints aren't met.
type DeleteDomainReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDomainReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDomainReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDomainReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDomainReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDomainReplyValidationError) ErrorName() string {
	return "DeleteDomainReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDomainReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDomainReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDomainReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDomainReplyValidationError{}

// Validate checks the field values on ListDomainMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuReqMultiError, or nil if none found.
func (m *ListDomainMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListDomainMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListDomainMenuReqMultiError(errors)
	}

	return nil
}

// ListDomainMenuReqMultiError is an error wrapping multiple validation errors
// returned by ListDomainMenuReq.ValidateAll() if the designated constraints
// aren't met.
type ListDomainMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuReqMultiError) AllErrors() []error { return m }

// ListDomainMenuReqValidationError is the validation error returned by
// ListDomainMenuReq.Validate if the designated constraints aren't met.
type ListDomainMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuReqValidationError) ErrorName() string {
	return "ListDomainMenuReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuReqValidationError{}

// Validate checks the field values on ListDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDomainMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDomainMenuReplyMultiError, or nil if none found.
func (m *ListDomainMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDomainMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDomainMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDomainMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDomainMenuReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDomainMenuReplyMultiError(errors)
	}

	return nil
}

// ListDomainMenuReplyMultiError is an error wrapping multiple validation
// errors returned by ListDomainMenuReply.ValidateAll() if the designated
// constraints aren't met.
type ListDomainMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDomainMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDomainMenuReplyMultiError) AllErrors() []error { return m }

// ListDomainMenuReplyValidationError is the validation error returned by
// ListDomainMenuReply.Validate if the designated constraints aren't met.
type ListDomainMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDomainMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDomainMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDomainMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDomainMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDomainMenuReplyValidationError) ErrorName() string {
	return "ListDomainMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListDomainMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDomainMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDomainMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDomainMenuReplyValidationError{}

// Validate checks the field values on HandleDomainMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReqMultiError, or nil if none found.
func (m *HandleDomainMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleDomainMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleDomainMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleDomainMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleDomainMenuReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleDomainMenuReqMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReqMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReq.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReqMultiError) AllErrors() []error { return m }

// HandleDomainMenuReqValidationError is the validation error returned by
// HandleDomainMenuReq.Validate if the designated constraints aren't met.
type HandleDomainMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReqValidationError) ErrorName() string {
	return "HandleDomainMenuReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReqValidationError{}

// Validate checks the field values on HandleDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReplyMultiError, or nil if none found.
func (m *HandleDomainMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleDomainMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleDomainMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleDomainMenuReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return HandleDomainMenuReplyMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReplyMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReply.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReplyMultiError) AllErrors() []error { return m }

// HandleDomainMenuReplyValidationError is the validation error returned by
// HandleDomainMenuReply.Validate if the designated constraints aren't met.
type HandleDomainMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReplyValidationError) ErrorName() string {
	return "HandleDomainMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReplyValidationError{}

// Validate checks the field values on Role with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Role) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Role with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleMultiError, or nil if none found.
func (m *Role) ValidateAll() error {
	return m.validate(true)
}

func (m *Role) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for DefaultRouter

	// no validation rules for Sort

	// no validation rules for State

	// no validation rules for Remarks

	if len(errors) > 0 {
		return RoleMultiError(errors)
	}

	return nil
}

// RoleMultiError is an error wrapping multiple validation errors returned by
// Role.ValidateAll() if the designated constraints aren't met.
type RoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMultiError) AllErrors() []error { return m }

// RoleValidationError is the validation error returned by Role.Validate if the
// designated constraints aren't met.
type RoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleValidationError) ErrorName() string { return "RoleValidationError" }

// Error satisfies the builtin error interface
func (e RoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleValidationError{}

// Validate checks the field values on CreateRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateRoleReqMultiError, or
// nil if none found.
func (m *CreateRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateRoleReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateRoleReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateRoleReq_State_NotInLookup[m.GetState()]; ok {
		err := CreateRoleReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.RoleState_name[int32(m.GetState())]; !ok {
		err := CreateRoleReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.DefaultRouter != nil {

		if l := utf8.RuneCountInString(m.GetDefaultRouter()); l < 1 || l > 100 {
			err := CreateRoleReqValidationError{
				field:  "DefaultRouter",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := CreateRoleReqValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := CreateRoleReqValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateRoleReqMultiError(errors)
	}

	return nil
}

// CreateRoleReqMultiError is an error wrapping multiple validation errors
// returned by CreateRoleReq.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleReqMultiError) AllErrors() []error { return m }

// CreateRoleReqValidationError is the validation error returned by
// CreateRoleReq.Validate if the designated constraints aren't met.
type CreateRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleReqValidationError) ErrorName() string { return "CreateRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleReqValidationError{}

var _CreateRoleReq_State_NotInLookup = map[protobuf.RoleState]struct{}{
	0: {},
}

// Validate checks the field values on CreateRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRoleReplyMultiError, or nil if none found.
func (m *CreateRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRoleReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreateRoleReplyMultiError(errors)
	}

	return nil
}

// CreateRoleReplyMultiError is an error wrapping multiple validation errors
// returned by CreateRoleReply.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleReplyMultiError) AllErrors() []error { return m }

// CreateRoleReplyValidationError is the validation error returned by
// CreateRoleReply.Validate if the designated constraints aren't met.
type CreateRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleReplyValidationError) ErrorName() string { return "CreateRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleReplyValidationError{}

// Validate checks the field values on UpdateRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateRoleReqMultiError, or
// nil if none found.
func (m *UpdateRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleReqMultiError(errors)
	}

	return nil
}

// UpdateRoleReqMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReqMultiError) AllErrors() []error { return m }

// UpdateRoleReqValidationError is the validation error returned by
// UpdateRoleReq.Validate if the designated constraints aren't met.
type UpdateRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReqValidationError) ErrorName() string { return "UpdateRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReqValidationError{}

// Validate checks the field values on UpdateRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleReplyMultiError, or nil if none found.
func (m *UpdateRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateRoleReplyMultiError(errors)
	}

	return nil
}

// UpdateRoleReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReplyMultiError) AllErrors() []error { return m }

// UpdateRoleReplyValidationError is the validation error returned by
// UpdateRoleReply.Validate if the designated constraints aren't met.
type UpdateRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReplyValidationError) ErrorName() string { return "UpdateRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReplyValidationError{}

// Validate checks the field values on UpdateRoleStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateReqMultiError, or nil if none found.
func (m *UpdateRoleStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleStateReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleStateReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRoleStateReqMultiError(errors)
	}

	return nil
}

// UpdateRoleStateReqMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleStateReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateReqMultiError) AllErrors() []error { return m }

// UpdateRoleStateReqValidationError is the validation error returned by
// UpdateRoleStateReq.Validate if the designated constraints aren't met.
type UpdateRoleStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateReqValidationError) ErrorName() string {
	return "UpdateRoleStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateReqValidationError{}

// Validate checks the field values on UpdateRoleStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateReplyMultiError, or nil if none found.
func (m *UpdateRoleStateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRoleStateReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRoleStateReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRoleStateReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateRoleStateReplyMultiError(errors)
	}

	return nil
}

// UpdateRoleStateReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleStateReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleStateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateReplyMultiError) AllErrors() []error { return m }

// UpdateRoleStateReplyValidationError is the validation error returned by
// UpdateRoleStateReply.Validate if the designated constraints aren't met.
type UpdateRoleStateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateReplyValidationError) ErrorName() string {
	return "UpdateRoleStateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateReplyValidationError{}

// Validate checks the field values on GetRoleReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRoleReqMultiError, or
// nil if none found.
func (m *GetRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRoleReqMultiError(errors)
	}

	return nil
}

// GetRoleReqMultiError is an error wrapping multiple validation errors
// returned by GetRoleReq.ValidateAll() if the designated constraints aren't met.
type GetRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleReqMultiError) AllErrors() []error { return m }

// GetRoleReqValidationError is the validation error returned by
// GetRoleReq.Validate if the designated constraints aren't met.
type GetRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleReqValidationError) ErrorName() string { return "GetRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleReqValidationError{}

// Validate checks the field values on DeleteRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteRoleReqMultiError, or
// nil if none found.
func (m *DeleteRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRoleReqMultiError(errors)
	}

	return nil
}

// DeleteRoleReqMultiError is an error wrapping multiple validation errors
// returned by DeleteRoleReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleReqMultiError) AllErrors() []error { return m }

// DeleteRoleReqValidationError is the validation error returned by
// DeleteRoleReq.Validate if the designated constraints aren't met.
type DeleteRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleReqValidationError) ErrorName() string { return "DeleteRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleReqValidationError{}

// Validate checks the field values on DeleteRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRoleReplyMultiError, or nil if none found.
func (m *DeleteRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRoleReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRoleReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteRoleReplyMultiError(errors)
	}

	return nil
}

// DeleteRoleReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteRoleReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleReplyMultiError) AllErrors() []error { return m }

// DeleteRoleReplyValidationError is the validation error returned by
// DeleteRoleReply.Validate if the designated constraints aren't met.
type DeleteRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleReplyValidationError) ErrorName() string { return "DeleteRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleReplyValidationError{}

// Validate checks the field values on ListRoleMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoleMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleMenuReqMultiError, or nil if none found.
func (m *ListRoleMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := ListRoleMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRoleMenuReqMultiError(errors)
	}

	return nil
}

// ListRoleMenuReqMultiError is an error wrapping multiple validation errors
// returned by ListRoleMenuReq.ValidateAll() if the designated constraints
// aren't met.
type ListRoleMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleMenuReqMultiError) AllErrors() []error { return m }

// ListRoleMenuReqValidationError is the validation error returned by
// ListRoleMenuReq.Validate if the designated constraints aren't met.
type ListRoleMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleMenuReqValidationError) ErrorName() string { return "ListRoleMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e ListRoleMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleMenuReqValidationError{}

// Validate checks the field values on ListRoleMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRoleMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRoleMenuReplyMultiError, or nil if none found.
func (m *ListRoleMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleMenuReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleMenuReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListRoleMenuReplyMultiError(errors)
	}

	return nil
}

// ListRoleMenuReplyMultiError is an error wrapping multiple validation errors
// returned by ListRoleMenuReply.ValidateAll() if the designated constraints
// aren't met.
type ListRoleMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleMenuReplyMultiError) AllErrors() []error { return m }

// ListRoleMenuReplyValidationError is the validation error returned by
// ListRoleMenuReply.Validate if the designated constraints aren't met.
type ListRoleMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleMenuReplyValidationError) ErrorName() string {
	return "ListRoleMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListRoleMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleMenuReplyValidationError{}

// Validate checks the field values on HandleRoleMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReqMultiError, or nil if none found.
func (m *HandleRoleMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleMenuReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleMenuReqMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReqMultiError is an error wrapping multiple validation errors
// returned by HandleRoleMenuReq.ValidateAll() if the designated constraints
// aren't met.
type HandleRoleMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReqMultiError) AllErrors() []error { return m }

// HandleRoleMenuReqValidationError is the validation error returned by
// HandleRoleMenuReq.Validate if the designated constraints aren't met.
type HandleRoleMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReqValidationError) ErrorName() string {
	return "HandleRoleMenuReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReqValidationError{}

// Validate checks the field values on HandleRoleMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReplyMultiError, or nil if none found.
func (m *HandleRoleMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleMenuReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return HandleRoleMenuReplyMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReplyMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuReply.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReplyMultiError) AllErrors() []error { return m }

// HandleRoleMenuReplyValidationError is the validation error returned by
// HandleRoleMenuReply.Validate if the designated constraints aren't met.
type HandleRoleMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReplyValidationError) ErrorName() string {
	return "HandleRoleMenuReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReplyValidationError{}

// Validate checks the field values on HandleRoleResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleResourceReqMultiError, or nil if none found.
func (m *HandleRoleResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleResourceReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HandleRoleResourceReqMultiError(errors)
	}

	return nil
}

// HandleRoleResourceReqMultiError is an error wrapping multiple validation
// errors returned by HandleRoleResourceReq.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleResourceReqMultiError) AllErrors() []error { return m }

// HandleRoleResourceReqValidationError is the validation error returned by
// HandleRoleResourceReq.Validate if the designated constraints aren't met.
type HandleRoleResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleResourceReqValidationError) ErrorName() string {
	return "HandleRoleResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleResourceReqValidationError{}

// Validate checks the field values on HandleRoleResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleResourceReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleResourceReplyMultiError, or nil if none found.
func (m *HandleRoleResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HandleRoleResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HandleRoleResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HandleRoleResourceReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return HandleRoleResourceReplyMultiError(errors)
	}

	return nil
}

// HandleRoleResourceReplyMultiError is an error wrapping multiple validation
// errors returned by HandleRoleResourceReply.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleResourceReplyMultiError) AllErrors() []error { return m }

// HandleRoleResourceReplyValidationError is the validation error returned by
// HandleRoleResourceReply.Validate if the designated constraints aren't met.
type HandleRoleResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleResourceReplyValidationError) ErrorName() string {
	return "HandleRoleResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleResourceReplyValidationError{}

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Method

	// no validation rules for Group

	// no validation rules for Description

	// no validation rules for Operation

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on ListResourceGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResourceGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResourceGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResourceGroupReplyMultiError, or nil if none found.
func (m *ListResourceGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResourceGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListResourceGroupReplyMultiError(errors)
	}

	return nil
}

// ListResourceGroupReplyMultiError is an error wrapping multiple validation
// errors returned by ListResourceGroupReply.ValidateAll() if the designated
// constraints aren't met.
type ListResourceGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResourceGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResourceGroupReplyMultiError) AllErrors() []error { return m }

// ListResourceGroupReplyValidationError is the validation error returned by
// ListResourceGroupReply.Validate if the designated constraints aren't met.
type ListResourceGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResourceGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResourceGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResourceGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResourceGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResourceGroupReplyValidationError) ErrorName() string {
	return "ListResourceGroupReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListResourceGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResourceGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResourceGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResourceGroupReplyValidationError{}

// Validate checks the field values on CreateResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateResourceReqMultiError, or nil if none found.
func (m *CreateResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateResourceReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
		err := CreateResourceReqValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateResourceReq_Method_InLookup[m.GetMethod()]; !ok {
		err := CreateResourceReqValidationError{
			field:  "Method",
			reason: "value must be in list [* GET POST HEAD PUT PATCH DELETE OPTIONS CONNECT TRACE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Group != nil {

		if l := utf8.RuneCountInString(m.GetGroup()); l < 0 || l > 100 {
			err := CreateResourceReqValidationError{
				field:  "Group",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
			err := CreateResourceReqValidationError{
				field:  "Description",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Operation != nil {

		if l := utf8.RuneCountInString(m.GetOperation()); l < 0 || l > 100 {
			err := CreateResourceReqValidationError{
				field:  "Operation",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateResourceReqMultiError(errors)
	}

	return nil
}

// CreateResourceReqMultiError is an error wrapping multiple validation errors
// returned by CreateResourceReq.ValidateAll() if the designated constraints
// aren't met.
type CreateResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResourceReqMultiError) AllErrors() []error { return m }

// CreateResourceReqValidationError is the validation error returned by
// CreateResourceReq.Validate if the designated constraints aren't met.
type CreateResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResourceReqValidationError) ErrorName() string {
	return "CreateResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResourceReqValidationError{}

var _CreateResourceReq_Method_InLookup = map[string]struct{}{
	"*":       {},
	"GET":     {},
	"POST":    {},
	"HEAD":    {},
	"PUT":     {},
	"PATCH":   {},
	"DELETE":  {},
	"OPTIONS": {},
	"CONNECT": {},
	"TRACE":   {},
}

// Validate checks the field values on CreateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateResourceReplyMultiError, or nil if none found.
func (m *CreateResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateResourceReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreateResourceReplyMultiError(errors)
	}

	return nil
}

// CreateResourceReplyMultiError is an error wrapping multiple validation
// errors returned by CreateResourceReply.ValidateAll() if the designated
// constraints aren't met.
type CreateResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResourceReplyMultiError) AllErrors() []error { return m }

// CreateResourceReplyValidationError is the validation error returned by
// CreateResourceReply.Validate if the designated constraints aren't met.
type CreateResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResourceReplyValidationError) ErrorName() string {
	return "CreateResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResourceReplyValidationError{}

// Validate checks the field values on UpdateResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateResourceReqMultiError, or nil if none found.
func (m *UpdateResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateResourceReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateResourceReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateResourceReqMultiError(errors)
	}

	return nil
}

// UpdateResourceReqMultiError is an error wrapping multiple validation errors
// returned by UpdateResourceReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResourceReqMultiError) AllErrors() []error { return m }

// UpdateResourceReqValidationError is the validation error returned by
// UpdateResourceReq.Validate if the designated constraints aren't met.
type UpdateResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResourceReqValidationError) ErrorName() string {
	return "UpdateResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResourceReqValidationError{}

// Validate checks the field values on UpdateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateResourceReplyMultiError, or nil if none found.
func (m *UpdateResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateResourceReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateResourceReplyMultiError(errors)
	}

	return nil
}

// UpdateResourceReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateResourceReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResourceReplyMultiError) AllErrors() []error { return m }

// UpdateResourceReplyValidationError is the validation error returned by
// UpdateResourceReply.Validate if the designated constraints aren't met.
type UpdateResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResourceReplyValidationError) ErrorName() string {
	return "UpdateResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResourceReplyValidationError{}

// Validate checks the field values on GetResourceReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetResourceReqMultiError,
// or nil if none found.
func (m *GetResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetResourceReqMultiError(errors)
	}

	return nil
}

// GetResourceReqMultiError is an error wrapping multiple validation errors
// returned by GetResourceReq.ValidateAll() if the designated constraints
// aren't met.
type GetResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceReqMultiError) AllErrors() []error { return m }

// GetResourceReqValidationError is the validation error returned by
// GetResourceReq.Validate if the designated constraints aren't met.
type GetResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceReqValidationError) ErrorName() string { return "GetResourceReqValidationError" }

// Error satisfies the builtin error interface
func (e GetResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceReqValidationError{}

// Validate checks the field values on DeleteResourceReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteResourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteResourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteResourceReqMultiError, or nil if none found.
func (m *DeleteResourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteResourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteResourceReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteResourceReqMultiError(errors)
	}

	return nil
}

// DeleteResourceReqMultiError is an error wrapping multiple validation errors
// returned by DeleteResourceReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteResourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResourceReqMultiError) AllErrors() []error { return m }

// DeleteResourceReqValidationError is the validation error returned by
// DeleteResourceReq.Validate if the designated constraints aren't met.
type DeleteResourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResourceReqValidationError) ErrorName() string {
	return "DeleteResourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteResourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteResourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResourceReqValidationError{}

// Validate checks the field values on DeleteResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteResourceReplyMultiError, or nil if none found.
func (m *DeleteResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteResourceReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteResourceReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteResourceReplyMultiError(errors)
	}

	return nil
}

// DeleteResourceReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteResourceReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResourceReplyMultiError) AllErrors() []error { return m }

// DeleteResourceReplyValidationError is the validation error returned by
// DeleteResourceReply.Validate if the designated constraints aren't met.
type DeleteResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResourceReplyValidationError) ErrorName() string {
	return "DeleteResourceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResourceReplyValidationError{}

// Validate checks the field values on Menu with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MenuMultiError, or nil if none found.
func (m *Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for IsHidden

	// no validation rules for Component

	// no validation rules for Permission

	// no validation rules for Sort

	// no validation rules for Icon

	// no validation rules for Title

	// no validation rules for IsCache

	// no validation rules for IsAffix

	// no validation rules for LinkType

	// no validation rules for LinkUrl

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuMultiError(errors)
	}

	return nil
}

// MenuMultiError is an error wrapping multiple validation errors returned by
// Menu.ValidateAll() if the designated constraints aren't met.
type MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuMultiError) AllErrors() []error { return m }

// MenuValidationError is the validation error returned by Menu.Validate if the
// designated constraints aren't met.
type MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuValidationError) ErrorName() string { return "MenuValidationError" }

// Error satisfies the builtin error interface
func (e MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuValidationError{}

// Validate checks the field values on MenuButton with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuButton) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuButton with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuButtonMultiError, or
// nil if none found.
func (m *MenuButton) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuButton) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Remarks

	if len(errors) > 0 {
		return MenuButtonMultiError(errors)
	}

	return nil
}

// MenuButtonMultiError is an error wrapping multiple validation errors
// returned by MenuButton.ValidateAll() if the designated constraints aren't met.
type MenuButtonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuButtonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuButtonMultiError) AllErrors() []error { return m }

// MenuButtonValidationError is the validation error returned by
// MenuButton.Validate if the designated constraints aren't met.
type MenuButtonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuButtonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuButtonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuButtonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuButtonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuButtonValidationError) ErrorName() string { return "MenuButtonValidationError" }

// Error satisfies the builtin error interface
func (e MenuButtonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuButton.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuButtonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuButtonValidationError{}

// Validate checks the field values on MenuParameter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuParameter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuParameterMultiError, or
// nil if none found.
func (m *MenuParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Value

	if len(errors) > 0 {
		return MenuParameterMultiError(errors)
	}

	return nil
}

// MenuParameterMultiError is an error wrapping multiple validation errors
// returned by MenuParameter.ValidateAll() if the designated constraints
// aren't met.
type MenuParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuParameterMultiError) AllErrors() []error { return m }

// MenuParameterValidationError is the validation error returned by
// MenuParameter.Validate if the designated constraints aren't met.
type MenuParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuParameterValidationError) ErrorName() string { return "MenuParameterValidationError" }

// Error satisfies the builtin error interface
func (e MenuParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuParameterValidationError{}

// Validate checks the field values on CreateMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateMenuReqMultiError, or
// nil if none found.
func (m *CreateMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _CreateMenuReq_Type_NotInLookup[m.GetType()]; ok {
		err := CreateMenuReqValidationError{
			field:  "Type",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.MenuType_name[int32(m.GetType())]; !ok {
		err := CreateMenuReqValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateMenuReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateMenuReq_IsHidden_NotInLookup[m.GetIsHidden()]; ok {
		err := CreateMenuReqValidationError{
			field:  "IsHidden",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.MenuHidden_name[int32(m.GetIsHidden())]; !ok {
		err := CreateMenuReqValidationError{
			field:  "IsHidden",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := CreateMenuReqValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateMenuReqValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateMenuReqValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
			err := CreateMenuReqValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Path != nil {

		if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "Path",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Component != nil {

		if utf8.RuneCountInString(m.GetComponent()) > 100 {
			err := CreateMenuReqValidationError{
				field:  "Component",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Permission != nil {

		if utf8.RuneCountInString(m.GetPermission()) > 100 {
			err := CreateMenuReqValidationError{
				field:  "Permission",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() >= 100000 {
			err := CreateMenuReqValidationError{
				field:  "Sort",
				reason: "value must be less than 100000",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Icon != nil {

		if l := utf8.RuneCountInString(m.GetIcon()); l < 0 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "Icon",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsCache != nil {

		if _, ok := _CreateMenuReq_IsCache_NotInLookup[m.GetIsCache()]; ok {
			err := CreateMenuReqValidationError{
				field:  "IsCache",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuCache_name[int32(m.GetIsCache())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "IsCache",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkUrl != nil {

		if l := utf8.RuneCountInString(m.GetLinkUrl()); l < 0 || l > 100 {
			err := CreateMenuReqValidationError{
				field:  "LinkUrl",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsAffix != nil {

		if _, ok := _CreateMenuReq_IsAffix_NotInLookup[m.GetIsAffix()]; ok {
			err := CreateMenuReqValidationError{
				field:  "IsAffix",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuAffix_name[int32(m.GetIsAffix())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "IsAffix",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkType != nil {

		if _, ok := _CreateMenuReq_LinkType_NotInLookup[m.GetLinkType()]; ok {
			err := CreateMenuReqValidationError{
				field:  "LinkType",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuLinkType_name[int32(m.GetLinkType())]; !ok {
			err := CreateMenuReqValidationError{
				field:  "LinkType",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateMenuReqMultiError(errors)
	}

	return nil
}

// CreateMenuReqMultiError is an error wrapping multiple validation errors
// returned by CreateMenuReq.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuReqMultiError) AllErrors() []error { return m }

// CreateMenuReqValidationError is the validation error returned by
// CreateMenuReq.Validate if the designated constraints aren't met.
type CreateMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuReqValidationError) ErrorName() string { return "CreateMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuReqValidationError{}

var _CreateMenuReq_Type_NotInLookup = map[protobuf.MenuType]struct{}{
	0: {},
}

var _CreateMenuReq_IsHidden_NotInLookup = map[protobuf.MenuHidden]struct{}{
	0: {},
}

var _CreateMenuReq_IsCache_NotInLookup = map[protobuf.MenuCache]struct{}{
	0: {},
}

var _CreateMenuReq_IsAffix_NotInLookup = map[protobuf.MenuAffix]struct{}{
	0: {},
}

var _CreateMenuReq_LinkType_NotInLookup = map[protobuf.MenuLinkType]struct{}{
	0: {},
}

// Validate checks the field values on CreateMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMenuReplyMultiError, or nil if none found.
func (m *CreateMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateMenuReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreateMenuReplyMultiError(errors)
	}

	return nil
}

// CreateMenuReplyMultiError is an error wrapping multiple validation errors
// returned by CreateMenuReply.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuReplyMultiError) AllErrors() []error { return m }

// CreateMenuReplyValidationError is the validation error returned by
// CreateMenuReply.Validate if the designated constraints aren't met.
type CreateMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuReplyValidationError) ErrorName() string { return "CreateMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuReplyValidationError{}

// Validate checks the field values on UpdateMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateMenuReqMultiError, or
// nil if none found.
func (m *UpdateMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMenuReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMenuReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMenuReqMultiError(errors)
	}

	return nil
}

// UpdateMenuReqMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReqMultiError) AllErrors() []error { return m }

// UpdateMenuReqValidationError is the validation error returned by
// UpdateMenuReq.Validate if the designated constraints aren't met.
type UpdateMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReqValidationError) ErrorName() string { return "UpdateMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReqValidationError{}

// Validate checks the field values on UpdateMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuReplyMultiError, or nil if none found.
func (m *UpdateMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMenuReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateMenuReplyMultiError(errors)
	}

	return nil
}

// UpdateMenuReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReplyMultiError) AllErrors() []error { return m }

// UpdateMenuReplyValidationError is the validation error returned by
// UpdateMenuReply.Validate if the designated constraints aren't met.
type UpdateMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReplyValidationError) ErrorName() string { return "UpdateMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReplyValidationError{}

// Validate checks the field values on GetMenuReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMenuReqMultiError, or
// nil if none found.
func (m *GetMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMenuReqMultiError(errors)
	}

	return nil
}

// GetMenuReqMultiError is an error wrapping multiple validation errors
// returned by GetMenuReq.ValidateAll() if the designated constraints aren't met.
type GetMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMenuReqMultiError) AllErrors() []error { return m }

// GetMenuReqValidationError is the validation error returned by
// GetMenuReq.Validate if the designated constraints aren't met.
type GetMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMenuReqValidationError) ErrorName() string { return "GetMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e GetMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMenuReqValidationError{}

// Validate checks the field values on DeleteMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteMenuReqMultiError, or
// nil if none found.
func (m *DeleteMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteMenuReqMultiError(errors)
	}

	return nil
}

// DeleteMenuReqMultiError is an error wrapping multiple validation errors
// returned by DeleteMenuReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMenuReqMultiError) AllErrors() []error { return m }

// DeleteMenuReqValidationError is the validation error returned by
// DeleteMenuReq.Validate if the designated constraints aren't met.
type DeleteMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMenuReqValidationError) ErrorName() string { return "DeleteMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMenuReqValidationError{}

// Validate checks the field values on DeleteMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMenuReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMenuReplyMultiError, or nil if none found.
func (m *DeleteMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteMenuReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteMenuReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteMenuReplyMultiError(errors)
	}

	return nil
}

// DeleteMenuReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteMenuReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMenuReplyMultiError) AllErrors() []error { return m }

// DeleteMenuReplyValidationError is the validation error returned by
// DeleteMenuReply.Validate if the designated constraints aren't met.
type DeleteMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMenuReplyValidationError) ErrorName() string { return "DeleteMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMenuReplyValidationError{}

// Validate checks the field values on MenuTree with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuTree) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuTree with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuTreeMultiError, or nil
// if none found.
func (m *MenuTree) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuTree) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Title

	// no validation rules for ParentId

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuTreeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuTreeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuTreeMultiError(errors)
	}

	return nil
}

// MenuTreeMultiError is an error wrapping multiple validation errors returned
// by MenuTree.ValidateAll() if the designated constraints aren't met.
type MenuTreeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuTreeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuTreeMultiError) AllErrors() []error { return m }

// MenuTreeValidationError is the validation error returned by
// MenuTree.Validate if the designated constraints aren't met.
type MenuTreeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuTreeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuTreeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuTreeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuTreeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuTreeValidationError) ErrorName() string { return "MenuTreeValidationError" }

// Error satisfies the builtin error interface
func (e MenuTreeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuTree.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuTreeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuTreeValidationError{}

// Validate checks the field values on ListMenuTreeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMenuTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuTreeReqMultiError, or nil if none found.
func (m *ListMenuTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListMenuTreeReqMultiError(errors)
	}

	return nil
}

// ListMenuTreeReqMultiError is an error wrapping multiple validation errors
// returned by ListMenuTreeReq.ValidateAll() if the designated constraints
// aren't met.
type ListMenuTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuTreeReqMultiError) AllErrors() []error { return m }

// ListMenuTreeReqValidationError is the validation error returned by
// ListMenuTreeReq.Validate if the designated constraints aren't met.
type ListMenuTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuTreeReqValidationError) ErrorName() string { return "ListMenuTreeReqValidationError" }

// Error satisfies the builtin error interface
func (e ListMenuTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuTreeReqValidationError{}

// Validate checks the field values on ListMenuTreeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListMenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMenuTreeReplyMultiError, or nil if none found.
func (m *ListMenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMenuTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMenuTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListMenuTreeReplyMultiError(errors)
	}

	return nil
}

// ListMenuTreeReplyMultiError is an error wrapping multiple validation errors
// returned by ListMenuTreeReply.ValidateAll() if the designated constraints
// aren't met.
type ListMenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuTreeReplyMultiError) AllErrors() []error { return m }

// ListMenuTreeReplyValidationError is the validation error returned by
// ListMenuTreeReply.Validate if the designated constraints aren't met.
type ListMenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuTreeReplyValidationError) ErrorName() string {
	return "ListMenuTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListMenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuTreeReplyValidationError{}

// Validate checks the field values on Dept with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Dept) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dept with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DeptMultiError, or nil if none found.
func (m *Dept) ValidateAll() error {
	return m.validate(true)
}

func (m *Dept) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeptValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeptValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeptValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeptValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeptValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeptValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for ParentId

	// no validation rules for Sort

	// no validation rules for Remarks

	// no validation rules for State

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeptValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeptValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeptMultiError(errors)
	}

	return nil
}

// DeptMultiError is an error wrapping multiple validation errors returned by
// Dept.ValidateAll() if the designated constraints aren't met.
type DeptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeptMultiError) AllErrors() []error { return m }

// DeptValidationError is the validation error returned by Dept.Validate if the
// designated constraints aren't met.
type DeptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeptValidationError) ErrorName() string { return "DeptValidationError" }

// Error satisfies the builtin error interface
func (e DeptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDept.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeptValidationError{}

// Validate checks the field values on CreateDeptReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateDeptReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeptReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateDeptReqMultiError, or
// nil if none found.
func (m *CreateDeptReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeptReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreateDeptReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := CreateDeptReqValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreateDeptReqValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateDeptReq_State_NotInLookup[m.GetState()]; ok {
		err := CreateDeptReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.DeptState_name[int32(m.GetState())]; !ok {
		err := CreateDeptReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := CreateDeptReqValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateDeptReqMultiError(errors)
	}

	return nil
}

// CreateDeptReqMultiError is an error wrapping multiple validation errors
// returned by CreateDeptReq.ValidateAll() if the designated constraints
// aren't met.
type CreateDeptReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeptReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeptReqMultiError) AllErrors() []error { return m }

// CreateDeptReqValidationError is the validation error returned by
// CreateDeptReq.Validate if the designated constraints aren't met.
type CreateDeptReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeptReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeptReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeptReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeptReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeptReqValidationError) ErrorName() string { return "CreateDeptReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateDeptReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeptReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeptReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeptReqValidationError{}

var _CreateDeptReq_State_NotInLookup = map[protobuf.DeptState]struct{}{
	0: {},
}

// Validate checks the field values on CreateDeptReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateDeptReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeptReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeptReplyMultiError, or nil if none found.
func (m *CreateDeptReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeptReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeptReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeptReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeptReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreateDeptReplyMultiError(errors)
	}

	return nil
}

// CreateDeptReplyMultiError is an error wrapping multiple validation errors
// returned by CreateDeptReply.ValidateAll() if the designated constraints
// aren't met.
type CreateDeptReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeptReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeptReplyMultiError) AllErrors() []error { return m }

// CreateDeptReplyValidationError is the validation error returned by
// CreateDeptReply.Validate if the designated constraints aren't met.
type CreateDeptReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeptReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeptReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeptReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeptReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeptReplyValidationError) ErrorName() string { return "CreateDeptReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateDeptReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeptReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeptReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeptReplyValidationError{}

// Validate checks the field values on UpdateDeptReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateDeptReqMultiError, or
// nil if none found.
func (m *UpdateDeptReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateDeptReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeptReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeptReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeptReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDeptReqMultiError(errors)
	}

	return nil
}

// UpdateDeptReqMultiError is an error wrapping multiple validation errors
// returned by UpdateDeptReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateDeptReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptReqMultiError) AllErrors() []error { return m }

// UpdateDeptReqValidationError is the validation error returned by
// UpdateDeptReq.Validate if the designated constraints aren't met.
type UpdateDeptReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptReqValidationError) ErrorName() string { return "UpdateDeptReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateDeptReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptReqValidationError{}

// Validate checks the field values on UpdateDeptReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptReplyMultiError, or nil if none found.
func (m *UpdateDeptReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeptReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeptReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeptReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdateDeptReplyMultiError(errors)
	}

	return nil
}

// UpdateDeptReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateDeptReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateDeptReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptReplyMultiError) AllErrors() []error { return m }

// UpdateDeptReplyValidationError is the validation error returned by
// UpdateDeptReply.Validate if the designated constraints aren't met.
type UpdateDeptReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptReplyValidationError) ErrorName() string { return "UpdateDeptReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateDeptReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptReplyValidationError{}

// Validate checks the field values on GetDeptReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetDeptReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDeptReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetDeptReqMultiError, or
// nil if none found.
func (m *GetDeptReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDeptReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetDeptReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDeptReqMultiError(errors)
	}

	return nil
}

// GetDeptReqMultiError is an error wrapping multiple validation errors
// returned by GetDeptReq.ValidateAll() if the designated constraints aren't met.
type GetDeptReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDeptReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDeptReqMultiError) AllErrors() []error { return m }

// GetDeptReqValidationError is the validation error returned by
// GetDeptReq.Validate if the designated constraints aren't met.
type GetDeptReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDeptReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDeptReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDeptReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDeptReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDeptReqValidationError) ErrorName() string { return "GetDeptReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDeptReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDeptReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDeptReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDeptReqValidationError{}

// Validate checks the field values on DeleteDeptReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteDeptReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDeptReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteDeptReqMultiError, or
// nil if none found.
func (m *DeleteDeptReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDeptReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteDeptReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDeptReqMultiError(errors)
	}

	return nil
}

// DeleteDeptReqMultiError is an error wrapping multiple validation errors
// returned by DeleteDeptReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteDeptReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDeptReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDeptReqMultiError) AllErrors() []error { return m }

// DeleteDeptReqValidationError is the validation error returned by
// DeleteDeptReq.Validate if the designated constraints aren't met.
type DeleteDeptReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDeptReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDeptReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDeptReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDeptReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDeptReqValidationError) ErrorName() string { return "DeleteDeptReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteDeptReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDeptReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDeptReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDeptReqValidationError{}

// Validate checks the field values on DeleteDeptReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteDeptReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDeptReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDeptReplyMultiError, or nil if none found.
func (m *DeleteDeptReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDeptReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDeptReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDeptReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDeptReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteDeptReplyMultiError(errors)
	}

	return nil
}

// DeleteDeptReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteDeptReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteDeptReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDeptReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDeptReplyMultiError) AllErrors() []error { return m }

// DeleteDeptReplyValidationError is the validation error returned by
// DeleteDeptReply.Validate if the designated constraints aren't met.
type DeleteDeptReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDeptReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDeptReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDeptReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDeptReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDeptReplyValidationError) ErrorName() string { return "DeleteDeptReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteDeptReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDeptReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDeptReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDeptReplyValidationError{}

// Validate checks the field values on ListDeptTreeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDeptTreeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeptTreeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeptTreeReqMultiError, or nil if none found.
func (m *ListDeptTreeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeptTreeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListDeptTreeReqMultiError(errors)
	}

	return nil
}

// ListDeptTreeReqMultiError is an error wrapping multiple validation errors
// returned by ListDeptTreeReq.ValidateAll() if the designated constraints
// aren't met.
type ListDeptTreeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeptTreeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeptTreeReqMultiError) AllErrors() []error { return m }

// ListDeptTreeReqValidationError is the validation error returned by
// ListDeptTreeReq.Validate if the designated constraints aren't met.
type ListDeptTreeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeptTreeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeptTreeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeptTreeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeptTreeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeptTreeReqValidationError) ErrorName() string { return "ListDeptTreeReqValidationError" }

// Error satisfies the builtin error interface
func (e ListDeptTreeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeptTreeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeptTreeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeptTreeReqValidationError{}

// Validate checks the field values on ListDeptTreeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDeptTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDeptTreeReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDeptTreeReplyMultiError, or nil if none found.
func (m *ListDeptTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDeptTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDeptTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDeptTreeReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDeptTreeReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListDeptTreeReplyMultiError(errors)
	}

	return nil
}

// ListDeptTreeReplyMultiError is an error wrapping multiple validation errors
// returned by ListDeptTreeReply.ValidateAll() if the designated constraints
// aren't met.
type ListDeptTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeptTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeptTreeReplyMultiError) AllErrors() []error { return m }

// ListDeptTreeReplyValidationError is the validation error returned by
// ListDeptTreeReply.Validate if the designated constraints aren't met.
type ListDeptTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeptTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeptTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeptTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeptTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeptTreeReplyValidationError) ErrorName() string {
	return "ListDeptTreeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeptTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeptTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeptTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeptTreeReplyValidationError{}

// Validate checks the field values on Post with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Post) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Post with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PostMultiError, or nil if none found.
func (m *Post) ValidateAll() error {
	return m.validate(true)
}

func (m *Post) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Code

	// no validation rules for Sort

	// no validation rules for Remarks

	// no validation rules for State

	if len(errors) > 0 {
		return PostMultiError(errors)
	}

	return nil
}

// PostMultiError is an error wrapping multiple validation errors returned by
// Post.ValidateAll() if the designated constraints aren't met.
type PostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostMultiError) AllErrors() []error { return m }

// PostValidationError is the validation error returned by Post.Validate if the
// designated constraints aren't met.
type PostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostValidationError) ErrorName() string { return "PostValidationError" }

// Error satisfies the builtin error interface
func (e PostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostValidationError{}

// Validate checks the field values on CreatePostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatePostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatePostReqMultiError, or
// nil if none found.
func (m *CreatePostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := CreatePostReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := CreatePostReqValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreatePostReq_State_NotInLookup[m.GetState()]; ok {
		err := CreatePostReqValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.PostState_name[int32(m.GetState())]; !ok {
		err := CreatePostReqValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Code != nil {

		if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 10 {
			err := CreatePostReqValidationError{
				field:  "Code",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := CreatePostReqValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreatePostReqMultiError(errors)
	}

	return nil
}

// CreatePostReqMultiError is an error wrapping multiple validation errors
// returned by CreatePostReq.ValidateAll() if the designated constraints
// aren't met.
type CreatePostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePostReqMultiError) AllErrors() []error { return m }

// CreatePostReqValidationError is the validation error returned by
// CreatePostReq.Validate if the designated constraints aren't met.
type CreatePostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePostReqValidationError) ErrorName() string { return "CreatePostReqValidationError" }

// Error satisfies the builtin error interface
func (e CreatePostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePostReqValidationError{}

var _CreatePostReq_State_NotInLookup = map[protobuf.PostState]struct{}{
	0: {},
}

// Validate checks the field values on CreatePostReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePostReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePostReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePostReplyMultiError, or nil if none found.
func (m *CreatePostReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePostReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePostReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePostReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePostReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return CreatePostReplyMultiError(errors)
	}

	return nil
}

// CreatePostReplyMultiError is an error wrapping multiple validation errors
// returned by CreatePostReply.ValidateAll() if the designated constraints
// aren't met.
type CreatePostReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePostReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePostReplyMultiError) AllErrors() []error { return m }

// CreatePostReplyValidationError is the validation error returned by
// CreatePostReply.Validate if the designated constraints aren't met.
type CreatePostReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePostReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePostReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePostReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePostReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePostReplyValidationError) ErrorName() string { return "CreatePostReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreatePostReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePostReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePostReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePostReplyValidationError{}

// Validate checks the field values on UpdatePostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatePostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatePostReqMultiError, or
// nil if none found.
func (m *UpdatePostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdatePostReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostReqMultiError(errors)
	}

	return nil
}

// UpdatePostReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePostReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostReqMultiError) AllErrors() []error { return m }

// UpdatePostReqValidationError is the validation error returned by
// UpdatePostReq.Validate if the designated constraints aren't met.
type UpdatePostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostReqValidationError) ErrorName() string { return "UpdatePostReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostReqValidationError{}

// Validate checks the field values on UpdatePostReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostReplyMultiError, or nil if none found.
func (m *UpdatePostReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdatePostReplyMultiError(errors)
	}

	return nil
}

// UpdatePostReplyMultiError is an error wrapping multiple validation errors
// returned by UpdatePostReply.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostReplyMultiError) AllErrors() []error { return m }

// UpdatePostReplyValidationError is the validation error returned by
// UpdatePostReply.Validate if the designated constraints aren't met.
type UpdatePostReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostReplyValidationError) ErrorName() string { return "UpdatePostReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePostReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostReplyValidationError{}

// Validate checks the field values on GetPostReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPostReqMultiError, or
// nil if none found.
func (m *GetPostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetPostReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPostReqMultiError(errors)
	}

	return nil
}

// GetPostReqMultiError is an error wrapping multiple validation errors
// returned by GetPostReq.ValidateAll() if the designated constraints aren't met.
type GetPostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPostReqMultiError) AllErrors() []error { return m }

// GetPostReqValidationError is the validation error returned by
// GetPostReq.Validate if the designated constraints aren't met.
type GetPostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPostReqValidationError) ErrorName() string { return "GetPostReqValidationError" }

// Error satisfies the builtin error interface
func (e GetPostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPostReqValidationError{}

// Validate checks the field values on DeletePostReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletePostReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePostReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletePostReqMultiError, or
// nil if none found.
func (m *DeletePostReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePostReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeletePostReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePostReqMultiError(errors)
	}

	return nil
}

// DeletePostReqMultiError is an error wrapping multiple validation errors
// returned by DeletePostReq.ValidateAll() if the designated constraints
// aren't met.
type DeletePostReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePostReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePostReqMultiError) AllErrors() []error { return m }

// DeletePostReqValidationError is the validation error returned by
// DeletePostReq.Validate if the designated constraints aren't met.
type DeletePostReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePostReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePostReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePostReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePostReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePostReqValidationError) ErrorName() string { return "DeletePostReqValidationError" }

// Error satisfies the builtin error interface
func (e DeletePostReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePostReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePostReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePostReqValidationError{}

// Validate checks the field values on DeletePostReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeletePostReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePostReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePostReplyMultiError, or nil if none found.
func (m *DeletePostReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePostReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeletePostReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeletePostReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeletePostReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeletePostReplyMultiError(errors)
	}

	return nil
}

// DeletePostReplyMultiError is an error wrapping multiple validation errors
// returned by DeletePostReply.ValidateAll() if the designated constraints
// aren't met.
type DeletePostReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePostReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePostReplyMultiError) AllErrors() []error { return m }

// DeletePostReplyValidationError is the validation error returned by
// DeletePostReply.Validate if the designated constraints aren't met.
type DeletePostReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePostReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePostReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePostReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePostReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePostReplyValidationError) ErrorName() string { return "DeletePostReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeletePostReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePostReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePostReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePostReplyValidationError{}

// Validate checks the field values on UpdatePostStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateReqMultiError, or nil if none found.
func (m *UpdatePostStateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdatePostStateReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostStateReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostStateReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePostStateReqMultiError(errors)
	}

	return nil
}

// UpdatePostStateReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePostStateReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostStateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateReqMultiError) AllErrors() []error { return m }

// UpdatePostStateReqValidationError is the validation error returned by
// UpdatePostStateReq.Validate if the designated constraints aren't met.
type UpdatePostStateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateReqValidationError) ErrorName() string {
	return "UpdatePostStateReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateReqValidationError{}

// Validate checks the field values on UpdatePostStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateReplyMultiError, or nil if none found.
func (m *UpdatePostStateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePostStateReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePostStateReplyValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePostStateReplyValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Success

	if len(errors) > 0 {
		return UpdatePostStateReplyMultiError(errors)
	}

	return nil
}

// UpdatePostStateReplyMultiError is an error wrapping multiple validation
// errors returned by UpdatePostStateReply.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostStateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateReplyMultiError) AllErrors() []error { return m }

// UpdatePostStateReplyValidationError is the validation error returned by
// UpdatePostStateReply.Validate if the designated constraints aren't met.
type UpdatePostStateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateReplyValidationError) ErrorName() string {
	return "UpdatePostStateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateReplyValidationError{}

// Validate checks the field values on LoginReq_Auth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReq_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReq_Auth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReq_AuthMultiError, or
// nil if none found.
func (m *LoginReq_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReq_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccount()); l < 1 || l > 10 {
		err := LoginReq_AuthValidationError{
			field:  "Account",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
		err := LoginReq_AuthValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 28 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginReq_AuthMultiError(errors)
	}

	return nil
}

// LoginReq_AuthMultiError is an error wrapping multiple validation errors
// returned by LoginReq_Auth.ValidateAll() if the designated constraints
// aren't met.
type LoginReq_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReq_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReq_AuthMultiError) AllErrors() []error { return m }

// LoginReq_AuthValidationError is the validation error returned by
// LoginReq_Auth.Validate if the designated constraints aren't met.
type LoginReq_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReq_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReq_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReq_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReq_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReq_AuthValidationError) ErrorName() string { return "LoginReq_AuthValidationError" }

// Error satisfies the builtin error interface
func (e LoginReq_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReq_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReq_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReq_AuthValidationError{}

// Validate checks the field values on SmsLoginReq_Auth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SmsLoginReq_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmsLoginReq_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SmsLoginReq_AuthMultiError, or nil if none found.
func (m *SmsLoginReq_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *SmsLoginReq_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SmsLoginReq_Auth_Phone_Pattern.MatchString(m.GetPhone()) {
		err := SmsLoginReq_AuthValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SmsLoginReq_Auth_Code_Pattern.MatchString(m.GetCode()) {
		err := SmsLoginReq_AuthValidationError{
			field:  "Code",
			reason: "value does not match regex pattern \"^[0-9]{6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SmsLoginReq_AuthMultiError(errors)
	}

	return nil
}

// SmsLoginReq_AuthMultiError is an error wrapping multiple validation errors
// returned by SmsLoginReq_Auth.ValidateAll() if the designated constraints
// aren't met.
type SmsLoginReq_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmsLoginReq_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmsLoginReq_AuthMultiError) AllErrors() []error { return m }

// SmsLoginReq_AuthValidationError is the validation error returned by
// SmsLoginReq_Auth.Validate if the designated constraints aren't met.
type SmsLoginReq_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmsLoginReq_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmsLoginReq_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmsLoginReq_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmsLoginReq_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmsLoginReq_AuthValidationError) ErrorName() string { return "SmsLoginReq_AuthValidationError" }

// Error satisfies the builtin error interface
func (e SmsLoginReq_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmsLoginReq_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmsLoginReq_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmsLoginReq_AuthValidationError{}

var _SmsLoginReq_Auth_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _SmsLoginReq_Auth_Code_Pattern = regexp.MustCompile("^[0-9]{6}$")

// Validate checks the field values on EmailLoginReq_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailLoginReq_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailLoginReq_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailLoginReq_AuthMultiError, or nil if none found.
func (m *EmailLoginReq_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailLoginReq_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = EmailLoginReq_AuthValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EmailLoginReq_Auth_Code_Pattern.MatchString(m.GetCode()) {
		err := EmailLoginReq_AuthValidationError{
			field:  "Code",
			reason: "value does not match regex pattern \"^[0-9]{4,6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EmailLoginReq_AuthMultiError(errors)
	}

	return nil
}

func (m *EmailLoginReq_Auth) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *EmailLoginReq_Auth) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// EmailLoginReq_AuthMultiError is an error wrapping multiple validation errors
// returned by EmailLoginReq_Auth.ValidateAll() if the designated constraints
// aren't met.
type EmailLoginReq_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailLoginReq_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailLoginReq_AuthMultiError) AllErrors() []error { return m }

// EmailLoginReq_AuthValidationError is the validation error returned by
// EmailLoginReq_Auth.Validate if the designated constraints aren't met.
type EmailLoginReq_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailLoginReq_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailLoginReq_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailLoginReq_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailLoginReq_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailLoginReq_AuthValidationError) ErrorName() string {
	return "EmailLoginReq_AuthValidationError"
}

// Error satisfies the builtin error interface
func (e EmailLoginReq_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailLoginReq_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailLoginReq_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailLoginReq_AuthValidationError{}

var _EmailLoginReq_Auth_Code_Pattern = regexp.MustCompile("^[0-9]{4,6}$")

// Validate checks the field values on RegisterReq_Auth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterReq_Auth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReq_Auth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterReq_AuthMultiError, or nil if none found.
func (m *RegisterReq_Auth) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReq_Auth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := RegisterReq_AuthValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 25 {
		err := RegisterReq_AuthValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 25 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterReq_Auth_Phone_Pattern.MatchString(m.GetPhone()) {
		err := RegisterReq_AuthValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterReq_AuthMultiError(errors)
	}

	return nil
}

// RegisterReq_AuthMultiError is an error wrapping multiple validation errors
// returned by RegisterReq_Auth.ValidateAll() if the designated constraints
// aren't met.
type RegisterReq_AuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReq_AuthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReq_AuthMultiError) AllErrors() []error { return m }

// RegisterReq_AuthValidationError is the validation error returned by
// RegisterReq_Auth.Validate if the designated constraints aren't met.
type RegisterReq_AuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReq_AuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReq_AuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReq_AuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReq_AuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReq_AuthValidationError) ErrorName() string { return "RegisterReq_AuthValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReq_AuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReq_Auth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReq_AuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReq_AuthValidationError{}

var _RegisterReq_Auth_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

// Validate checks the field values on GetUserInfoReply_UserRole with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoReply_UserRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoReply_UserRole with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoReply_UserRoleMultiError, or nil if none found.
func (m *GetUserInfoReply_UserRole) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoReply_UserRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for DefaultRouter

	// no validation rules for Sort

	if len(errors) > 0 {
		return GetUserInfoReply_UserRoleMultiError(errors)
	}

	return nil
}

// GetUserInfoReply_UserRoleMultiError is an error wrapping multiple validation
// errors returned by GetUserInfoReply_UserRole.ValidateAll() if the
// designated constraints aren't met.
type GetUserInfoReply_UserRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoReply_UserRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoReply_UserRoleMultiError) AllErrors() []error { return m }

// GetUserInfoReply_UserRoleValidationError is the validation error returned by
// GetUserInfoReply_UserRole.Validate if the designated constraints aren't met.
type GetUserInfoReply_UserRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoReply_UserRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoReply_UserRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoReply_UserRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoReply_UserRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoReply_UserRoleValidationError) ErrorName() string {
	return "GetUserInfoReply_UserRoleValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoReply_UserRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoReply_UserRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoReply_UserRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoReply_UserRoleValidationError{}

// Validate checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply_Deprecated_MenuMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Deprecated_MenuMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Deprecated_MenuMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for DynamicLevel

	// no validation rules for RealPath

	// no validation rules for IgnoreKeepAlive

	// no validation rules for Affix

	// no validation rules for Icon

	// no validation rules for FrameSrc

	// no validation rules for TransitionName

	// no validation rules for HideBreadcrumb

	// no validation rules for CarryParam

	// no validation rules for HideChildrenInMenu

	// no validation rules for CurrentActiveMenu

	// no validation rules for HideTab

	// no validation rules for HideMenu

	// no validation rules for OrderNo

	// no validation rules for IgnoreRoute

	// no validation rules for HidePathForChildren

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError is an error wrapping
// multiple validation errors returned by
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta.ValidateAll() if the
// designated constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMetaMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError is the
// validation error returned by
// ListUserRoleMenuTreeReply_Deprecated_MenuMeta.Validate if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Deprecated_MenuMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_Deprecated_MenuMetaValidationError{}

// Validate checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserRoleMenuTreeReply_Deprecated_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListUserRoleMenuTreeReply_Deprecated_Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListUserRoleMenuTreeReply_Deprecated_MenuMultiError, or nil if none found.
func (m *ListUserRoleMenuTreeReply_Deprecated_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserRoleMenuTreeReply_Deprecated_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Component

	// no validation rules for Redirect

	// no validation rules for FullPath

	// no validation rules for Alias

	// no validation rules for CaseSensitive

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUserRoleMenuTreeReply_Deprecated_MenuMultiError(errors)
	}

	return nil
}

// ListUserRoleMenuTreeReply_Deprecated_MenuMultiError is an error wrapping
// multiple validation errors returned by
// ListUserRoleMenuTreeReply_Deprecated_Menu.ValidateAll() if the designated
// constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserRoleMenuTreeReply_Deprecated_MenuMultiError) AllErrors() []error { return m }

// ListUserRoleMenuTreeReply_Deprecated_MenuValidationError is the validation
// error returned by ListUserRoleMenuTreeReply_Deprecated_Menu.Validate if the
// designated constraints aren't met.
type ListUserRoleMenuTreeReply_Deprecated_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) ErrorName() string {
	return "ListUserRoleMenuTreeReply_Deprecated_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserRoleMenuTreeReply_Deprecated_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserRoleMenuTreeReply_Deprecated_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserRoleMenuTreeReply_Deprecated_MenuValidationError{}

// Validate checks the field values on MenuRouter_Meta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MenuRouter_Meta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuRouter_Meta with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MenuRouter_MetaMultiError, or nil if none found.
func (m *MenuRouter_Meta) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuRouter_Meta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	if m.IgnoreKeepAlive != nil {
		// no validation rules for IgnoreKeepAlive
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.FrameSrc != nil {
		// no validation rules for FrameSrc
	}

	if m.HideBreadcrumb != nil {
		// no validation rules for HideBreadcrumb
	}

	if m.HideMenu != nil {
		// no validation rules for HideMenu
	}

	if m.OrderNo != nil {
		// no validation rules for OrderNo
	}

	if m.CurrentActiveMenu != nil {
		// no validation rules for CurrentActiveMenu
	}

	if len(errors) > 0 {
		return MenuRouter_MetaMultiError(errors)
	}

	return nil
}

// MenuRouter_MetaMultiError is an error wrapping multiple validation errors
// returned by MenuRouter_Meta.ValidateAll() if the designated constraints
// aren't met.
type MenuRouter_MetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuRouter_MetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuRouter_MetaMultiError) AllErrors() []error { return m }

// MenuRouter_MetaValidationError is the validation error returned by
// MenuRouter_Meta.Validate if the designated constraints aren't met.
type MenuRouter_MetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuRouter_MetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuRouter_MetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuRouter_MetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuRouter_MetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuRouter_MetaValidationError) ErrorName() string { return "MenuRouter_MetaValidationError" }

// Error satisfies the builtin error interface
func (e MenuRouter_MetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuRouter_Meta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuRouter_MetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuRouter_MetaValidationError{}

// Validate checks the field values on HandleUserRoleReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleUserRoleReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleUserRoleReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleUserRoleReq_DataMultiError, or nil if none found.
func (m *HandleUserRoleReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleUserRoleReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDomainId() <= 0 {
		err := HandleUserRoleReq_DataValidationError{
			field:  "DomainId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRoleIds()) < 1 {
		err := HandleUserRoleReq_DataValidationError{
			field:  "RoleIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleUserRoleReq_Data_RoleIds_Unique := make(map[uint64]struct{}, len(m.GetRoleIds()))

	for idx, item := range m.GetRoleIds() {
		_, _ = idx, item

		if _, exists := _HandleUserRoleReq_Data_RoleIds_Unique[item]; exists {
			err := HandleUserRoleReq_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleUserRoleReq_Data_RoleIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleUserRoleReq_DataValidationError{
				field:  fmt.Sprintf("RoleIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleUserRoleReq_DataMultiError(errors)
	}

	return nil
}

// HandleUserRoleReq_DataMultiError is an error wrapping multiple validation
// errors returned by HandleUserRoleReq_Data.ValidateAll() if the designated
// constraints aren't met.
type HandleUserRoleReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleUserRoleReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleUserRoleReq_DataMultiError) AllErrors() []error { return m }

// HandleUserRoleReq_DataValidationError is the validation error returned by
// HandleUserRoleReq_Data.Validate if the designated constraints aren't met.
type HandleUserRoleReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleUserRoleReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleUserRoleReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleUserRoleReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleUserRoleReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleUserRoleReq_DataValidationError) ErrorName() string {
	return "HandleUserRoleReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleUserRoleReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleUserRoleReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleUserRoleReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleUserRoleReq_DataValidationError{}

// Validate checks the field values on UpdateUserReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserReq_DataMultiError, or nil if none found.
func (m *UpdateUserReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateUserReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateUserReq_Data_Phone_Pattern.MatchString(m.GetPhone()) {
		err := UpdateUserReq_DataValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateUserReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateUserReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.UserState_name[int32(m.GetState())]; !ok {
		err := UpdateUserReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Password != nil {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 28 {
			err := UpdateUserReq_DataValidationError{
				field:  "Password",
				reason: "value length must be between 6 and 28 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.NickName != nil {

		if l := utf8.RuneCountInString(m.GetNickName()); l < 1 || l > 10 {
			err := UpdateUserReq_DataValidationError{
				field:  "NickName",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RealName != nil {

		if l := utf8.RuneCountInString(m.GetRealName()); l < 2 || l > 10 {
			err := UpdateUserReq_DataValidationError{
				field:  "RealName",
				reason: "value length must be between 2 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Birthday != nil {

		if !_UpdateUserReq_Data_Birthday_Pattern.MatchString(m.GetBirthday()) {
			err := UpdateUserReq_DataValidationError{
				field:  "Birthday",
				reason: "value does not match regex pattern \"^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Gender != nil {

		if _, ok := _UpdateUserReq_Data_Gender_NotInLookup[m.GetGender()]; ok {
			err := UpdateUserReq_DataValidationError{
				field:  "Gender",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.UserGender_name[int32(m.GetGender())]; !ok {
			err := UpdateUserReq_DataValidationError{
				field:  "Gender",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Email != nil {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = UpdateUserReq_DataValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if len(errors) > 0 {
		return UpdateUserReq_DataMultiError(errors)
	}

	return nil
}

func (m *UpdateUserReq_Data) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UpdateUserReq_Data) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UpdateUserReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReq_DataMultiError) AllErrors() []error { return m }

// UpdateUserReq_DataValidationError is the validation error returned by
// UpdateUserReq_Data.Validate if the designated constraints aren't met.
type UpdateUserReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReq_DataValidationError) ErrorName() string {
	return "UpdateUserReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReq_DataValidationError{}

var _UpdateUserReq_Data_Birthday_Pattern = regexp.MustCompile("^[1-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$")

var _UpdateUserReq_Data_Gender_NotInLookup = map[protobuf.UserGender]struct{}{
	0: {},
}

var _UpdateUserReq_Data_Phone_Pattern = regexp.MustCompile("^1[0-9]{10}$")

var _UpdateUserReq_Data_State_NotInLookup = map[protobuf.UserState]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDomainReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainReq_DataMultiError, or nil if none found.
func (m *UpdateDomainReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDomainReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.ParentId != nil {
		// no validation rules for ParentId
	}

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.Title != nil {

		if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
			err := UpdateDomainReq_DataValidationError{
				field:  "Title",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if m.Pic != nil {
		// no validation rules for Pic
	}

	if m.Keywords != nil {
		// no validation rules for Keywords
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.State != nil {

		if _, ok := _UpdateDomainReq_Data_State_NotInLookup[m.GetState()]; ok {
			err := UpdateDomainReq_DataValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.DomainState_name[int32(m.GetState())]; !ok {
			err := UpdateDomainReq_DataValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {
		// no validation rules for Remarks
	}

	if len(errors) > 0 {
		return UpdateDomainReq_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateDomainReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainReq_DataMultiError) AllErrors() []error { return m }

// UpdateDomainReq_DataValidationError is the validation error returned by
// UpdateDomainReq_Data.Validate if the designated constraints aren't met.
type UpdateDomainReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainReq_DataValidationError) ErrorName() string {
	return "UpdateDomainReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainReq_DataValidationError{}

var _UpdateDomainReq_Data_State_NotInLookup = map[protobuf.DomainState]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDomainStateReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDomainStateReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDomainStateReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDomainStateReq_DataMultiError, or nil if none found.
func (m *UpdateDomainStateReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDomainStateReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if _, ok := _UpdateDomainStateReq_Data_State_NotInLookup[m.GetState()]; ok {
			err := UpdateDomainStateReq_DataValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.DomainState_name[int32(m.GetState())]; !ok {
			err := UpdateDomainStateReq_DataValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDomainStateReq_DataMultiError(errors)
	}

	return nil
}

// UpdateDomainStateReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateDomainStateReq_Data.ValidateAll() if the
// designated constraints aren't met.
type UpdateDomainStateReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDomainStateReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDomainStateReq_DataMultiError) AllErrors() []error { return m }

// UpdateDomainStateReq_DataValidationError is the validation error returned by
// UpdateDomainStateReq_Data.Validate if the designated constraints aren't met.
type UpdateDomainStateReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDomainStateReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDomainStateReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDomainStateReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDomainStateReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDomainStateReq_DataValidationError) ErrorName() string {
	return "UpdateDomainStateReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDomainStateReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDomainStateReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDomainStateReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDomainStateReq_DataValidationError{}

var _UpdateDomainStateReq_Data_State_NotInLookup = map[protobuf.DomainState]struct{}{
	0: {},
}

// Validate checks the field values on HandleDomainMenuReq_Menu with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReq_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReq_Menu with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReq_MenuMultiError, or nil if none found.
func (m *HandleDomainMenuReq_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReq_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleDomainMenuReq_MenuValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleDomainMenuReq_Menu_MenuParameterIds_Unique := make(map[uint64]struct{}, len(m.GetMenuParameterIds()))

	for idx, item := range m.GetMenuParameterIds() {
		_, _ = idx, item

		if _, exists := _HandleDomainMenuReq_Menu_MenuParameterIds_Unique[item]; exists {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleDomainMenuReq_Menu_MenuParameterIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_HandleDomainMenuReq_Menu_MenuButtonIds_Unique := make(map[uint64]struct{}, len(m.GetMenuButtonIds()))

	for idx, item := range m.GetMenuButtonIds() {
		_, _ = idx, item

		if _, exists := _HandleDomainMenuReq_Menu_MenuButtonIds_Unique[item]; exists {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleDomainMenuReq_Menu_MenuButtonIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleDomainMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuReq_MenuMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReq_MenuMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReq_Menu.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReq_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReq_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReq_MenuMultiError) AllErrors() []error { return m }

// HandleDomainMenuReq_MenuValidationError is the validation error returned by
// HandleDomainMenuReq_Menu.Validate if the designated constraints aren't met.
type HandleDomainMenuReq_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReq_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReq_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReq_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReq_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReq_MenuValidationError) ErrorName() string {
	return "HandleDomainMenuReq_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReq_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReq_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReq_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReq_MenuValidationError{}

// Validate checks the field values on HandleDomainMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleDomainMenuReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleDomainMenuReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleDomainMenuReq_DataMultiError, or nil if none found.
func (m *HandleDomainMenuReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleDomainMenuReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleDomainMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleDomainMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleDomainMenuReq_DataValidationError{
					field:  fmt.Sprintf("Menus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleDomainMenuReq_DataMultiError(errors)
	}

	return nil
}

// HandleDomainMenuReq_DataMultiError is an error wrapping multiple validation
// errors returned by HandleDomainMenuReq_Data.ValidateAll() if the designated
// constraints aren't met.
type HandleDomainMenuReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleDomainMenuReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleDomainMenuReq_DataMultiError) AllErrors() []error { return m }

// HandleDomainMenuReq_DataValidationError is the validation error returned by
// HandleDomainMenuReq_Data.Validate if the designated constraints aren't met.
type HandleDomainMenuReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleDomainMenuReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleDomainMenuReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleDomainMenuReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleDomainMenuReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleDomainMenuReq_DataValidationError) ErrorName() string {
	return "HandleDomainMenuReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleDomainMenuReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleDomainMenuReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleDomainMenuReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleDomainMenuReq_DataValidationError{}

// Validate checks the field values on UpdateRoleReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleReq_DataMultiError, or nil if none found.
func (m *UpdateRoleReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateRoleReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateRoleReq_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateRoleReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateRoleReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.RoleState_name[int32(m.GetState())]; !ok {
		err := UpdateRoleReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.DefaultRouter != nil {

		if l := utf8.RuneCountInString(m.GetDefaultRouter()); l < 1 || l > 100 {
			err := UpdateRoleReq_DataValidationError{
				field:  "DefaultRouter",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateRoleReq_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
			err := UpdateRoleReq_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateRoleReq_DataMultiError(errors)
	}

	return nil
}

// UpdateRoleReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReq_DataMultiError) AllErrors() []error { return m }

// UpdateRoleReq_DataValidationError is the validation error returned by
// UpdateRoleReq_Data.Validate if the designated constraints aren't met.
type UpdateRoleReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReq_DataValidationError) ErrorName() string {
	return "UpdateRoleReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReq_DataValidationError{}

var _UpdateRoleReq_Data_State_NotInLookup = map[protobuf.RoleState]struct{}{
	0: {},
}

// Validate checks the field values on UpdateRoleStateReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleStateReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleStateReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRoleStateReq_DataMultiError, or nil if none found.
func (m *UpdateRoleStateReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleStateReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _UpdateRoleStateReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateRoleStateReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.RoleState_name[int32(m.GetState())]; !ok {
		err := UpdateRoleStateReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateRoleStateReq_DataMultiError(errors)
	}

	return nil
}

// UpdateRoleStateReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateRoleStateReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateRoleStateReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleStateReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleStateReq_DataMultiError) AllErrors() []error { return m }

// UpdateRoleStateReq_DataValidationError is the validation error returned by
// UpdateRoleStateReq_Data.Validate if the designated constraints aren't met.
type UpdateRoleStateReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleStateReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleStateReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleStateReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleStateReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleStateReq_DataValidationError) ErrorName() string {
	return "UpdateRoleStateReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRoleStateReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleStateReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleStateReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleStateReq_DataValidationError{}

var _UpdateRoleStateReq_Data_State_NotInLookup = map[protobuf.RoleState]struct{}{
	0: {},
}

// Validate checks the field values on HandleRoleMenuReq_Menu with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReq_Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReq_Menu with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReq_MenuMultiError, or nil if none found.
func (m *HandleRoleMenuReq_Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReq_Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := HandleRoleMenuReq_MenuValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_HandleRoleMenuReq_Menu_MenuParameterIds_Unique := make(map[uint64]struct{}, len(m.GetMenuParameterIds()))

	for idx, item := range m.GetMenuParameterIds() {
		_, _ = idx, item

		if _, exists := _HandleRoleMenuReq_Menu_MenuParameterIds_Unique[item]; exists {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleRoleMenuReq_Menu_MenuParameterIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuParameterIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_HandleRoleMenuReq_Menu_MenuButtonIds_Unique := make(map[uint64]struct{}, len(m.GetMenuButtonIds()))

	for idx, item := range m.GetMenuButtonIds() {
		_, _ = idx, item

		if _, exists := _HandleRoleMenuReq_Menu_MenuButtonIds_Unique[item]; exists {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_HandleRoleMenuReq_Menu_MenuButtonIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := HandleRoleMenuReq_MenuValidationError{
				field:  fmt.Sprintf("MenuButtonIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return HandleRoleMenuReq_MenuMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReq_MenuMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuReq_Menu.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuReq_MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReq_MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReq_MenuMultiError) AllErrors() []error { return m }

// HandleRoleMenuReq_MenuValidationError is the validation error returned by
// HandleRoleMenuReq_Menu.Validate if the designated constraints aren't met.
type HandleRoleMenuReq_MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReq_MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReq_MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReq_MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReq_MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReq_MenuValidationError) ErrorName() string {
	return "HandleRoleMenuReq_MenuValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReq_MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReq_Menu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReq_MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReq_MenuValidationError{}

// Validate checks the field values on HandleRoleMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleMenuReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleMenuReq_DataMultiError, or nil if none found.
func (m *HandleRoleMenuReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleMenuReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HandleRoleMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HandleRoleMenuReq_DataValidationError{
						field:  fmt.Sprintf("Menus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HandleRoleMenuReq_DataValidationError{
					field:  fmt.Sprintf("Menus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HandleRoleMenuReq_DataMultiError(errors)
	}

	return nil
}

// HandleRoleMenuReq_DataMultiError is an error wrapping multiple validation
// errors returned by HandleRoleMenuReq_Data.ValidateAll() if the designated
// constraints aren't met.
type HandleRoleMenuReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleMenuReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleMenuReq_DataMultiError) AllErrors() []error { return m }

// HandleRoleMenuReq_DataValidationError is the validation error returned by
// HandleRoleMenuReq_Data.Validate if the designated constraints aren't met.
type HandleRoleMenuReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleMenuReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleMenuReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleMenuReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleMenuReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleMenuReq_DataValidationError) ErrorName() string {
	return "HandleRoleMenuReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleMenuReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleMenuReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleMenuReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleMenuReq_DataValidationError{}

// Validate checks the field values on HandleRoleResourceReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HandleRoleResourceReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HandleRoleResourceReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HandleRoleResourceReq_DataMultiError, or nil if none found.
func (m *HandleRoleResourceReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *HandleRoleResourceReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HandleRoleResourceReq_DataMultiError(errors)
	}

	return nil
}

// HandleRoleResourceReq_DataMultiError is an error wrapping multiple
// validation errors returned by HandleRoleResourceReq_Data.ValidateAll() if
// the designated constraints aren't met.
type HandleRoleResourceReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HandleRoleResourceReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HandleRoleResourceReq_DataMultiError) AllErrors() []error { return m }

// HandleRoleResourceReq_DataValidationError is the validation error returned
// by HandleRoleResourceReq_Data.Validate if the designated constraints aren't met.
type HandleRoleResourceReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HandleRoleResourceReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HandleRoleResourceReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HandleRoleResourceReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HandleRoleResourceReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HandleRoleResourceReq_DataValidationError) ErrorName() string {
	return "HandleRoleResourceReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e HandleRoleResourceReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHandleRoleResourceReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HandleRoleResourceReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HandleRoleResourceReq_DataValidationError{}

// Validate checks the field values on UpdateResourceReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateResourceReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateResourceReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateResourceReq_DataMultiError, or nil if none found.
func (m *UpdateResourceReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateResourceReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateResourceReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
		err := UpdateResourceReq_DataValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateResourceReq_Data_Method_InLookup[m.GetMethod()]; !ok {
		err := UpdateResourceReq_DataValidationError{
			field:  "Method",
			reason: "value must be in list [* GET POST HEAD PUT PATCH DELETE OPTIONS CONNECT TRACE]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Group != nil {

		if l := utf8.RuneCountInString(m.GetGroup()); l < 0 || l > 100 {
			err := UpdateResourceReq_DataValidationError{
				field:  "Group",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if l := utf8.RuneCountInString(m.GetDescription()); l < 0 || l > 1000 {
			err := UpdateResourceReq_DataValidationError{
				field:  "Description",
				reason: "value length must be between 0 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Operation != nil {

		if l := utf8.RuneCountInString(m.GetOperation()); l < 0 || l > 100 {
			err := UpdateResourceReq_DataValidationError{
				field:  "Operation",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateResourceReq_DataMultiError(errors)
	}

	return nil
}

// UpdateResourceReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdateResourceReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdateResourceReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResourceReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResourceReq_DataMultiError) AllErrors() []error { return m }

// UpdateResourceReq_DataValidationError is the validation error returned by
// UpdateResourceReq_Data.Validate if the designated constraints aren't met.
type UpdateResourceReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResourceReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResourceReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResourceReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResourceReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResourceReq_DataValidationError) ErrorName() string {
	return "UpdateResourceReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateResourceReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateResourceReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResourceReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResourceReq_DataValidationError{}

var _UpdateResourceReq_Data_Method_InLookup = map[string]struct{}{
	"*":       {},
	"GET":     {},
	"POST":    {},
	"HEAD":    {},
	"PUT":     {},
	"PATCH":   {},
	"DELETE":  {},
	"OPTIONS": {},
	"CONNECT": {},
	"TRACE":   {},
}

// Validate checks the field values on UpdateMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMenuReq_DataMultiError, or nil if none found.
func (m *UpdateMenuReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _UpdateMenuReq_Data_Type_NotInLookup[m.GetType()]; ok {
		err := UpdateMenuReq_DataValidationError{
			field:  "Type",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.MenuType_name[int32(m.GetType())]; !ok {
		err := UpdateMenuReq_DataValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateMenuReq_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 100 {
		err := UpdateMenuReq_DataValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateMenuReq_DataValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetButtons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateMenuReq_DataValidationError{
						field:  fmt.Sprintf("Buttons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateMenuReq_DataValidationError{
					field:  fmt.Sprintf("Buttons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 50 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Path != nil {

		if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Path",
				reason: "value length must be between 1 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsHidden != nil {

		if _, ok := _UpdateMenuReq_Data_IsHidden_NotInLookup[m.GetIsHidden()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "IsHidden",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuHidden_name[int32(m.GetIsHidden())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "IsHidden",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Component != nil {

		if utf8.RuneCountInString(m.GetComponent()) > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Component",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Permission != nil {

		if utf8.RuneCountInString(m.GetPermission()) > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Permission",
				reason: "value length must be at most 100 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Sort != nil {

		if m.GetSort() < 0 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Sort",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Icon != nil {

		if l := utf8.RuneCountInString(m.GetIcon()); l < 0 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "Icon",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsCache != nil {

		if _, ok := _UpdateMenuReq_Data_IsCache_NotInLookup[m.GetIsCache()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "IsCache",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuCache_name[int32(m.GetIsCache())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "IsCache",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkUrl != nil {

		if l := utf8.RuneCountInString(m.GetLinkUrl()); l < 0 || l > 100 {
			err := UpdateMenuReq_DataValidationError{
				field:  "LinkUrl",
				reason: "value length must be between 0 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsAffix != nil {

		if _, ok := _UpdateMenuReq_Data_IsAffix_NotInLookup[m.GetIsAffix()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "IsAffix",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuAffix_name[int32(m.GetIsAffix())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "IsAffix",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.LinkType != nil {

		if _, ok := _UpdateMenuReq_Data_LinkType_NotInLookup[m.GetLinkType()]; ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "LinkType",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.MenuLinkType_name[int32(m.GetLinkType())]; !ok {
			err := UpdateMenuReq_DataValidationError{
				field:  "LinkType",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateMenuReq_DataMultiError(errors)
	}

	return nil
}

// UpdateMenuReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReq_DataMultiError) AllErrors() []error { return m }

// UpdateMenuReq_DataValidationError is the validation error returned by
// UpdateMenuReq_Data.Validate if the designated constraints aren't met.
type UpdateMenuReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReq_DataValidationError) ErrorName() string {
	return "UpdateMenuReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMenuReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReq_DataValidationError{}

var _UpdateMenuReq_Data_Type_NotInLookup = map[protobuf.MenuType]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_IsHidden_NotInLookup = map[protobuf.MenuHidden]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_IsCache_NotInLookup = map[protobuf.MenuCache]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_IsAffix_NotInLookup = map[protobuf.MenuAffix]struct{}{
	0: {},
}

var _UpdateMenuReq_Data_LinkType_NotInLookup = map[protobuf.MenuLinkType]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDeptReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeptReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeptReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeptReq_DataMultiError, or nil if none found.
func (m *UpdateDeptReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeptReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdateDeptReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetParentId() < 0 {
		err := UpdateDeptReq_DataValidationError{
			field:  "ParentId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdateDeptReq_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateDeptReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdateDeptReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.DeptState_name[int32(m.GetState())]; !ok {
		err := UpdateDeptReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Remarks != nil {

		if l := utf8.RuneCountInString(m.GetRemarks()); l < 1 || l > 1000 {
			err := UpdateDeptReq_DataValidationError{
				field:  "Remarks",
				reason: "value length must be between 1 and 1000 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateDeptReq_DataMultiError(errors)
	}

	return nil
}

// UpdateDeptReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdateDeptReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdateDeptReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeptReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeptReq_DataMultiError) AllErrors() []error { return m }

// UpdateDeptReq_DataValidationError is the validation error returned by
// UpdateDeptReq_Data.Validate if the designated constraints aren't met.
type UpdateDeptReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeptReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeptReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeptReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeptReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeptReq_DataValidationError) ErrorName() string {
	return "UpdateDeptReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeptReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeptReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeptReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeptReq_DataValidationError{}

var _UpdateDeptReq_Data_State_NotInLookup = map[protobuf.DeptState]struct{}{
	0: {},
}

// Validate checks the field values on UpdatePostReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostReq_DataMultiError, or nil if none found.
func (m *UpdatePostReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 10 {
		err := UpdatePostReq_DataValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() < 0 {
		err := UpdatePostReq_DataValidationError{
			field:  "Sort",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdatePostReq_Data_State_NotInLookup[m.GetState()]; ok {
		err := UpdatePostReq_DataValidationError{
			field:  "State",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := protobuf.PostState_name[int32(m.GetState())]; !ok {
		err := UpdatePostReq_DataValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRemarks()); l < 0 || l > 1000 {
		err := UpdatePostReq_DataValidationError{
			field:  "Remarks",
			reason: "value length must be between 0 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Code != nil {

		if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 10 {
			err := UpdatePostReq_DataValidationError{
				field:  "Code",
				reason: "value length must be between 1 and 10 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdatePostReq_DataMultiError(errors)
	}

	return nil
}

// UpdatePostReq_DataMultiError is an error wrapping multiple validation errors
// returned by UpdatePostReq_Data.ValidateAll() if the designated constraints
// aren't met.
type UpdatePostReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostReq_DataMultiError) AllErrors() []error { return m }

// UpdatePostReq_DataValidationError is the validation error returned by
// UpdatePostReq_Data.Validate if the designated constraints aren't met.
type UpdatePostReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostReq_DataValidationError) ErrorName() string {
	return "UpdatePostReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostReq_DataValidationError{}

var _UpdatePostReq_Data_State_NotInLookup = map[protobuf.PostState]struct{}{
	0: {},
}

// Validate checks the field values on UpdatePostStateReq_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePostStateReq_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePostStateReq_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePostStateReq_DataMultiError, or nil if none found.
func (m *UpdatePostStateReq_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePostStateReq_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.State != nil {

		if _, ok := _UpdatePostStateReq_Data_State_NotInLookup[m.GetState()]; ok {
			err := UpdatePostStateReq_DataValidationError{
				field:  "State",
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := protobuf.PostState_name[int32(m.GetState())]; !ok {
			err := UpdatePostStateReq_DataValidationError{
				field:  "State",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdatePostStateReq_DataMultiError(errors)
	}

	return nil
}

// UpdatePostStateReq_DataMultiError is an error wrapping multiple validation
// errors returned by UpdatePostStateReq_Data.ValidateAll() if the designated
// constraints aren't met.
type UpdatePostStateReq_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePostStateReq_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePostStateReq_DataMultiError) AllErrors() []error { return m }

// UpdatePostStateReq_DataValidationError is the validation error returned by
// UpdatePostStateReq_Data.Validate if the designated constraints aren't met.
type UpdatePostStateReq_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePostStateReq_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePostStateReq_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePostStateReq_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePostStateReq_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePostStateReq_DataValidationError) ErrorName() string {
	return "UpdatePostStateReq_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePostStateReq_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePostStateReq_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePostStateReq_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePostStateReq_DataValidationError{}

var _UpdatePostStateReq_Data_State_NotInLookup = map[protobuf.PostState]struct{}{
	0: {},
}
